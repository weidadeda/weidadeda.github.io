<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>Gridea</title>
<link rel="shortcut icon" href="/favicon.ico?v=1642412302046">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Gridea</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://weidadeda.github.io/tags/" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  gemini">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">王大伟</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>一个前端工程师</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">12</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">1</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">1</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item" style="border-top: 1px dotted #ccc; margin-top: 10px;">
      </div>
    
  
  


</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          commit规范
          <small>标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://weidadeda.github.io/post/hello-gridea">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              12-12
              <small>如何自定义commit规范</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
    
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 0px;bottom: 0px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'histoire'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'Aoba') {
				AIimgSrc.push(message_Path + "model/Aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'Aoba') {
							model = message_Path + "model/Aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/node-jie-kou-sheng-cheng-jie-kou-wen-dang"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642391805862.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里我用的是koa2+swagger&lt;/p&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// koa2-swagger-ui UI视图组件  swagger-jsdoc 识别写的 /***/ 转 json
npm install koa2-swagger-ui swagger-jsdoc --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/koa2-swagger-ui&#34;&gt;koa2-swagger-ui npm地址&lt;/a&gt; （创建接口文档）&lt;br&gt;
&lt;a href=&#34;https://www.npmjs.com/package/swagger-jsdoc&#34;&gt;swagger-jsdoc npm地址&lt;/a&gt; （这个库读取带有jsdoc注释的源代码，并生成OpenAPI (Swagger)规范。）&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/5365ef83252a&#34;&gt;OpenAPI 规范摘要&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;p&gt;router.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const router = require(&#39;koa-router&#39;)() //引入路由函数
const swaggerJSDoc = require(&#39;swagger-jsdoc&#39;)
const path = require(&#39;path&#39;)
const swaggerDefinition = {
  openapi: &#39;3.0.1&#39;,
    info: {
        title: &#39;blog项目访问地址&#39;,
        version: &#39;1.0.0&#39;,
        description: &#39;API&#39;,
    },
    basePath: &#39;/&#39;, // Base path (optional)
    tags: [
      {
        name: &#39;manage&#39;,
        description: &#39;管理系统&#39;
      },
      {
        name: &#39;client&#39;,
        description: &#39;日志上报&#39;
      }
    ],
    schemes: [&#39;http&#39;, &#39;https&#39;],
    securityDefinitions: {
    server_auth: {
      type: &#39;oauth2&#39;,
      description: &#39;登录账号密码鉴权&#39;,
      tokenUrl: &#39;http://localhost:4000/image/oauth&#39;,
      flow: &#39;password&#39;,
      scopes: {
        token: &#39;modify pets in your account&#39;
      }
    },
    token: {
      type: &#39;apiKey&#39;,
      name: &#39;token&#39;,
      in: &#39;header&#39;
    }
  }
};
const options = {
    swaggerDefinition,
    apis: [path.join(__dirname, &#39;./controllers/*.js&#39;)], // 包含上述注释的文件（）
};
const swaggerSpec = swaggerJSDoc(options)
// 通过路由获取生成的注解文件
router.get(&#39;/swagger.json&#39;, async function (ctx) {
    ctx.set(&#39;Content-Type&#39;, &#39;application/json&#39;);
    ctx.body = swaggerSpec;
})
module.exports = router
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;app.js 入口文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const swagger = require(&#39;./router&#39;)  // router中做了swagger配置
const { koaSwagger } = require(&#39;koa2-swagger-ui&#39;)

// 接口文档配置
app.use(swagger.routes(), swagger.allowedMethods())
app.use(koaSwagger({
  routePrefix: &#39;/swagger&#39;, // 接口文档访问地址
  swaggerOptions: {
    url: &#39;/swagger.json&#39;, // example path to json 其实就是之后swagger-jsdoc生成的文档地址
  }
}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动项目，访问项目接口地址 + swagger ，我的地址是 http://localhost:8000/swagger&lt;/p&gt;
&lt;h3 id=&#34;注释生成文档&#34;&gt;注释生成文档&lt;/h3&gt;
&lt;p&gt;在controller层文件每个接口上写注释，注释是以@swagger开头的，swagger-jsdoc 会识别@swagger，然后解析下面的注释，解析完给koa2-swagger-ui显示成页面，总的流程就是这样。&lt;br&gt;
get方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取博客列表
/**
 * @swagger
 * /api/blog/list:
 *   get:
 *     summary: 获取博客列表
 *     description: 获取博客列表
 *     tags:
 *       - blogs
 *     parameters:
 *       - name: author
 *         in: query
 *         required: false
 *         description: 作者
 *         type: string
 *       - name: keyword
 *         in: query
 *         required: false
 *         description: 搜索关键字
 *         type: string
 *     responses:
 *       200:
 *         description: 成功获取
 */
router.get(&#39;/list&#39;, async (ctx, next) =&amp;gt; {
  const query = ctx.query
  let author = query.author || &#39;&#39;
  const keyword = query.keyword || &#39;&#39;

  const listData = await getList(author, keyword)
  ctx.body = new SuccessModel(listData)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;post方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @swagger
 * definitions:
 *  loginparam:
 *    properties:
 *      username:
 *        type: &amp;quot;string&amp;quot;
 *        default: &amp;quot;shangsan&amp;quot;
 *        description: 用户名
 *      password:
 *        type: &amp;quot;string&amp;quot;
 *        default: &amp;quot;123&amp;quot;
 *        description: 密码
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     ProjectDetail:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *           format: int64
 *         petId:
 *           type: integer
 *           format: int64
 *         quantity:
 *           type: integer
 *           format: int32
 *         shipDate:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /api/user/login:
 *   post:
 *     summary: 登录
 *     description: 登录
 *     tags:
 *       - user
 *     consumes:
 *      - application/json
 *      - application/xml
 *     produces:
 *      - application/json
 *      - application/xml
 *     parameters:
 *       - name: body
 *         in: body
 *         schema:
 *          $ref: &#39;#/definitions/loginparam&#39; （请求参数这里单独抽出，在上面定义）
 *     responses:
 *       200:
 *         description: 发布成功
 *          content:
 *           application/json:
 *             schema:
 *               $ref: &#39;#/components/schemas/ProjectDetail&#39;（返回参数也是单独抽出定义，这里是随便举个例子）
 *       402:
 *          description: 信息填写不全
 *       403:
 *          description: 参数类型错误
 */

router.post(&#39;/login&#39;, async (ctx, next) =&amp;gt; {
    // 业务逻辑
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回示例&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1642412213197.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
基本的接口文档就生成啦，快试一下吧～&lt;/p&gt;
">node接口生成接口文档</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.sequelize.com.cn/&#34;&gt;Sequelize 中文文档&lt;/a&gt;&lt;br&gt;
可以先看文档，文档很全，它的语句帮我们做了很多处理，而且很精简，让我们不用死记硬背sql语句，也不用去库里建表。&lt;/p&gt;
&lt;h3 id=&#34;连接数据库&#34;&gt;连接数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;连接到数据库
要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将连接参数分别传递到 Sequelize 构造函数或通过传递一个连接 URI 来完成：

const { Sequelize } = require(&#39;sequelize&#39;);

// 方法 1: 传递一个连接 URI
const sequelize = new Sequelize(&#39;sqlite::memory:&#39;) // Sqlite 示例
const sequelize = new Sequelize(&#39;postgres://user:pass@example.com:5432/dbname&#39;) // Postgres 示例

// 方法 2: 分别传递参数 (sqlite)
const sequelize = new Sequelize({
  dialect: &#39;sqlite&#39;,
  storage: &#39;path/to/database.sqlite&#39;
});

// 方法 3: 分别传递参数 (其它数据库)
const sequelize = new Sequelize(&#39;database&#39;, &#39;username&#39;, &#39;password&#39;, {
  host: &#39;localhost&#39;,
  dialect: /* 选择 &#39;mysql&#39; | &#39;mariadb&#39; | &#39;postgres&#39; | &#39;mssql&#39; 其一 */
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;定义模型-定义表结构&#34;&gt;定义模型 （定义表结构）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;module.exports = function(sequelize, DataTypes) {
  return sequelize.define(
    &#39;project&#39;,
    {
      id: {
        type: DataTypes.INTEGER(11),
        allowNull: false,
        primaryKey: true,
        autoIncrement: true
      },
      name: { type: DataTypes.STRING(255), allowNull: true },
      title: { type: DataTypes.STRING(255), allowNull: true },
      report_fix_id: { type: DataTypes.STRING(1000), allowNull: true },
      fix_url: { type: DataTypes.STRING(2000), allowNull: true },
      ignore_key: {
        type: DataTypes.STRING(2000),
        allowNull: true,
        comment: &#39;简化打印对象中比较大的对象&#39;
      },
      env: {
        type: DataTypes.STRING(255),
        allowNull: true,
        comment: &#39;哪些环境能上报日志&#39;
      },
      report_interval: {
        type: DataTypes.INTEGER(11),
        allowNull: true,
        comment: &#39;上报时间间隔&#39;
      },
      ctime: {
        type: DataTypes.INTEGER(10),
        allowNull: true,
        get() {
          return moment
            .unix(this.getDataValue(&#39;ctime&#39;))
            .format(&#39;YYYY/MM/DD HH:mm:ss&#39;)
        }
      },
      del: { type: DataTypes.INTEGER(1), allowNull: true, defaultValue: &#39;0&#39; }
    },
    {
      tableName: &#39;project&#39;
    }
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;模型同步-真正从数据库创建&#34;&gt;模型同步 （真正从数据库创建）&lt;/h3&gt;
&lt;p&gt;定义模型时,你要告诉 Sequelize 有关数据库中表的一些信息. 但是,如果该表实际上不存在于数据库中怎么办？ 如果存在,但具有不同的列,较少的列或任何其他差异,该怎么办？&lt;/p&gt;
&lt;p&gt;这就是模型同步的来源.可以通过调用一个异步函数(返回一个Promise)model.sync(options). 通过此调用,Sequelize 将自动对数据库执行 SQL 查询. 请注意,这仅更改数据库中的表,而不更改 JavaScript 端的模型.&lt;/p&gt;
&lt;p&gt;User.sync() - 如果表不存在,则创建该表(如果已经存在,则不执行任何操作)&lt;/p&gt;
&lt;h4 id=&#34;usersync-force-true-将创建表如果表已经存在则将其首先删除-这个不要用也最好别试&#34;&gt;User.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除 （这个不要用，也最好别试）&lt;/h4&gt;
&lt;p&gt;User.sync({ alter: true }) - 这将检查数据库中表的当前状态(它具有哪些列,它们的数据类型等),然后在表中进行必要的更改以使其与模型匹配.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sequelize
  .authenticate()
  .then(() =&amp;gt; {
    console.log(&#39;数据库连接成功&#39;.green)
    // sequelize.sync({ alter: true })
  })
  .catch(err =&amp;gt; {
    console.log(&#39;数据库连接失败&#39;.red)
  })
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建实例修改内容insert&#34;&gt;创建实例（修改内容INSERT）&lt;/h3&gt;
&lt;p&gt;尽管模型是一个类,但是你不应直接使用 new 运算符来创建实例. 相反,应该使用 build 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const jane = User.build({ name: &amp;quot;Jane&amp;quot; });
console.log(jane instanceof User); // true
console.log(jane.name); // &amp;quot;Jane&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是,以上代码根本无法与数据库通信(请注意,它甚至不是异步的)！ 这是因为 build 方法仅创建一个对象,该对象 表示 可以 映射到数据库的数据. 为了将这个实例真正保存(即持久保存)在数据库中,应使用 save 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;await jane.save();
console.log(&#39;Jane 已保存到数据库!&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意,从上面代码段中的 await 用法来看,save 是一种异步方法. 实际上,几乎每个 Sequelize 方法都是异步的. build 是极少数例外之一.&lt;/p&gt;
&lt;p&gt;非常有用的捷径: create 方法&lt;br&gt;
Sequelize提供了 create 方法,该方法将上述的 build 方法和 save 方法合并为一个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const jane = await User.create({ name: &amp;quot;Jane&amp;quot; });
// Jane 现在存在于数据库中！
console.log(jane instanceof User); // true
console.log(jane.name); // &amp;quot;Jane&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;简单-select-查询&#34;&gt;简单 SELECT 查询&lt;/h3&gt;
&lt;p&gt;你可以使用 findAll 方法从数据库中读取整个表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查询所有用户
const users = await User.findAll();
console.log(users.every(user =&amp;gt; user instanceof User)); // true
console.log(&amp;quot;All users:&amp;quot;, JSON.stringify(users, null, 2));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相当于sql语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嗯，写一些建表与查询的流程，照着官网抄也没什么意思。使用这个我们可以很轻松的操作数据库，使我们写node接口的时候效率翻倍～&lt;/p&gt;
">Sequelize node连接数据库的ORM</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/sequelize"" data-c="
          &lt;p&gt;官网介绍：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。&lt;br&gt;
&lt;a href=&#34;https://nacos.io/zh-cn/docs/what-is-nacos.html&#34;&gt;Nacos中文文档&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;概览&lt;br&gt;
欢迎来到 Nacos 的世界！&lt;br&gt;
Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。&lt;br&gt;
Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个东西主要用于微服务，但我作为一个前端，只用了它的配置管理功能，虽然有点大材小用，但确实方便,而且还可以通过网页去直接查看数据结构。&lt;/p&gt;
&lt;p&gt;假设前端要搞一个平台，但是并没有后端支持，那么权限管理以及一些必要的数据获取该怎么做呢，我们想到的肯定是node起服务，然后写接口，然后连接数据库。从而实现数据的增删改查。&lt;/p&gt;
&lt;p&gt;但有一种更简单的方式，就是在服务器的docker中下载一个nacos,把数据放到nacos中管理，这样数据依然在我们的服务器上，并且不需要我们自己去写接口，nacos提供了openApi，我们直接调用接口就可以，是不是很方便呢。下面开始安装：&lt;/p&gt;
&lt;h3 id=&#34;nacos-docker-快速开始&#34;&gt;Nacos Docker 快速开始&lt;/h3&gt;
&lt;p&gt;操作步骤&lt;br&gt;
Clone 项目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/nacos-group/nacos-docker.git
cd nacos-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单机模式 Derby&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-derby.yaml up
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单机模式 MySQL&lt;/p&gt;
&lt;p&gt;如果希望使用MySQL5.7&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-mysql-5.7.yaml up
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果希望使用MySQL8&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-mysql-8.yaml up
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;集群模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-compose -f example/cluster-hostname.yaml up 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务注册&lt;/p&gt;
&lt;p&gt;curl -X POST &#39;http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;amp;ip=20.18.7.10&amp;amp;port=8080&#39;&lt;br&gt;
服务发现&lt;/p&gt;
&lt;p&gt;curl -X GET &#39;http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName&#39;&lt;br&gt;
发布配置&lt;/p&gt;
&lt;p&gt;curl -X POST &amp;quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;amp;group=test&amp;amp;content=helloWorld&amp;quot;&lt;br&gt;
获取配置&lt;/p&gt;
&lt;p&gt;curl -X GET &amp;quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;amp;group=test&amp;quot;&lt;br&gt;
Nacos 控制台&lt;/p&gt;
&lt;p&gt;link：http://127.0.0.1:8848/nacos/（因为是在服务器上，所以可以直接使用对应的域名或者ip来访问）&lt;/p&gt;
&lt;h3 id=&#34;注意这里要用openapi提供的字段信息多了tenant字段-有哪里不明白的可以看下开头的官方文档哈&#34;&gt;注意，这里要用openApi提供的字段信息，多了tenant字段。有哪里不明白的可以看下开头的官方文档哈。&lt;/h3&gt;
">前端使用Nacos</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/mysql-cha-xun-yu-ju"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.mysqlzh.com/doc/124.html&#34;&gt;mysql中文文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1查询记录&#34;&gt;1.查询记录&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select*from 表名 [where 条件];

eg:select*from students;//查询 students 表中所有记录，所有字段的值都显示出来

select field1,field2,...fieldn... from 表名 [where 条件];

eg:select id,name,age from students;//查询 students 表中所有记录, 只显示出 id，name，age三个字段的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.“*”表示将所有的字段都显示出来&lt;/p&gt;
&lt;p&gt;2.用逗号分割，列出需要显示的字段&lt;/p&gt;
&lt;h3 id=&#34;2查询不重复的记录&#34;&gt;2.查询不重复的记录&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select distinct 字段 from 表名;

eg: select distinct name from students;//查询名字不相同的学生;
　　select distinct name,age from students;//查询名字和年龄同时不同的学生
　　
　　1.distinct必须放在最开头
　　2.distinct只能使用需要去重的字段进行操作。  ----也就是说我sidtinct了name,age两个字段，我后面想根据id进行排序，是不可以的，因为只能name,age两个字段进行操作.
　　3.distinct去重多个字段时，含义是：几个字段 同时重复 时才会被 过滤。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3条件查询&#34;&gt;3.条件查询&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select 字段 from 表名 where 条件;

eg:select * from student where sex=&#39;男&#39; and age&amp;gt;20; //查询性别是男，并且年龄大于20岁的人。

where后面的条件可以用&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、!=等多种比较运算符，多个条件之间可以用or、and等逻辑运算符
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4排序和限制&#34;&gt;4.排序和限制&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;排序
select * from 表名 [where 条件] [ order by  field1 [desc/asc],field2 [desc/asc]... ];

eg:select *from student order by age desc;//查询学生表并按年龄降序排列。

1.desc 降序排列，asc 升序排列
2.order by 后面可以跟多个不同的排序字段，每个排序字段都可以有不同的排序顺序。
3.如果排序字段的值一样，则相同的字段按照第二个排序字段进行排序。
4.如果只有一个排序字段，则字段相同的记录将会无序排列。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;限制
select ... [limit 起始偏移量,行数];

eg:select * from student order by mark desc limit 5;//取出成绩前五名的学生(省略了起始偏移量，此时默认为0)

1.默认情况下，起始偏移量为0，只写记录行数就可以。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5聚合&#34;&gt;5.聚合&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select 字段 fun_name from 表名 [where 条件] [group by field1,field2...] [with rollup] [having 条件];

eg:

1.fun_name 表示要做的聚合操作，也就是说聚合函数，常用的有 : sum(求和)、count(*)(记录数)、max(最大值)、min(最小值)。
2.group by关键字 表示要进行分类聚合的字段。比如要按照部门分类统计员工数量，部门就应该写在group by 后面。
3.with rollup 是可选语法，表明是否对分类聚合后的结果进行再汇总
4.having 关键字表示对分类后的结果再进行条件过滤。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;公司员工表A如下 (编号，姓，名，薪水) ：&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143111386.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;统计总人数
select count(1) from A;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143169839.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;统计各个姓的人数
select xing,count(1) from A group by xing;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143194061.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;既要统计各个姓的人数，又统计总人数
select xing,count(1) from A group by xing with rollup;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143250933.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;统计人数大4的姓
select xing,count(1) from A group by xing having count(1)&amp;gt;4;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143298558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;统计薪水总额，最低薪资，最高薪资
select count(1),min(salary),max(salary) from A;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143319528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;6为表和字段取别名&#34;&gt;6.为表和字段取别名&lt;/h3&gt;
&lt;p&gt;在查询数据时，可以为表和字段取别名，这个别名可以代替指定的表和字段。如果表名很长，用起来不方便，则可以用一个别名来代替，语法如下：(as关键字可省略)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from 表名 [as] 别名  （为表取别名）
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT 字段名 [AS] 别名[,字段名 [AS] 别名,……] FROM 表名; (为字段取别名)
&lt;/code&gt;&lt;/pre&gt;
">mysql查询语句</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/docker-de-an-zhuang-yu-shi-yong"" data-c="
          &lt;p&gt;&lt;a href=&#34;http://www.dockerinfo.net/document&#34;&gt;docker中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近Docker突然火得不得了，到处都是谈论Docker的声音，相信大家和小编一样的心情，看这个东西有点高大上，但尝试去阅读Docker文章时又发现概念很模糊、不接地气、难以理解、无从下手…于是三天打鱼两天晒网，最终不了了之，反正公司也没要求用这玩意儿，不费劲了… 这不，当前几天项目要求快速上线并且部署多台服务器环境时，小编一台一台服务器的yum install、vim、restart…想屎的心都有，那时小编心里想要是有一个这么一个U盘，能把整个环境一台一台的Ctrl+V过去，那该多好啊。那时脑子一下子闪过一个念头：Docker不就是我想拥有的那个U盘吗。&lt;/p&gt;
&lt;p&gt;怀着这样的一个念头，小编花了一些时间去查阅Docker相关的书籍、看视频、逛论坛，刚开始学习时非常难受，搞不懂什么是容器什么是镜像什么是鲸鱼船…而涉及到一些原理底层的知识，书籍里的那些概念比代码都能懂，小编硬啃了一段时间并且实操了几次之后，再回过头来，才豁然开朗。念及许多想要学Docker却苦于难以入门的开发者们，正在学习却很挣扎的初学者们，故而把小编这段时间的学习成果，以一个初学者的角度，遵循循序渐进的原则，编成一份通俗易懂的文章，希望能以此引导入门，早日成Docker大神。&lt;/p&gt;
&lt;p&gt;文章提纲：&lt;/p&gt;
&lt;p&gt;1、什么是Docker&lt;/p&gt;
&lt;p&gt;2、Docker对我们有什么用处&lt;/p&gt;
&lt;p&gt;3、Docker安装和使用&lt;/p&gt;
&lt;p&gt;4、彩蛋&lt;/p&gt;
&lt;p&gt;1、什么是Docker&lt;br&gt;
什么是docker？恐怕90%的人脑子一闪而过的都是那张图：一条鲸鱼背上扛着一堆箱子，图片下方是大大的“docker”。&lt;/p&gt;
&lt;p&gt;docker是什么？&lt;/p&gt;
&lt;p&gt;是鲸鱼？&lt;/p&gt;
&lt;p&gt;还是一堆箱子？&lt;/p&gt;
&lt;p&gt;或者说是载着箱子的鲸鱼？&lt;br&gt;
这里小编不做解释，先引用一下官方的解释：&lt;/p&gt;
&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
&lt;p&gt;顾名思义，docker是一个容器引擎，容器且不说，什么是引擎？&lt;/p&gt;
&lt;p&gt;我们知道：&lt;/p&gt;
&lt;p&gt;汽车的引擎是发动机，有了发动起，汽车才能跑起来&lt;/p&gt;
&lt;p&gt;游戏需要游戏引擎（如Unity3D..），基于引擎的开发，能让游戏动起来。&lt;/p&gt;
&lt;p&gt;如官言，docker也是一种引擎，基于这个引擎，开发者能让他们开发的应用处于一个有隔离性的、可移植性的容器中，以便于发布于各种机器中而无需考虑兼容性问题。&lt;/p&gt;
&lt;p&gt;因此就不难解释，为什么docker的logo是一条装着一堆箱子的鲸鱼.&lt;/p&gt;
&lt;p&gt;这是因为：docker扮演的是图中鲸鱼的角色，而鲸鱼之上的集装箱就是一个个容器，容器中是我们开发的应用程序（不仅限于web应用），每个容器都有自己独立的环境（环境设置、网络、文件系统…），互不干扰。而每个箱子，又可以打包成一个新的镜像，放到其它服务器的docker环境中直接运行，不再需要重复安装程序运行环境。&lt;/p&gt;
&lt;p&gt;上面的解释插入了两个生疏的概念：&lt;/p&gt;
&lt;p&gt;1、镜像&lt;/p&gt;
&lt;p&gt;2、容器&lt;/p&gt;
&lt;p&gt;我们先讲容器&lt;/p&gt;
&lt;p&gt;容器，顾名思义：就是装东西的器皿，在docker中，容器就是装载我们的应用程序的器皿，在docker的logo中，容器就是一个个箱子。我们知道，运行JavaWeb应用程序需要有Tomcat，那么我们就需要创建一个Tomcat的容器，才能把我们的程序放进去运行。&lt;/p&gt;
&lt;p&gt;那么，容器哪里来的呢&lt;/p&gt;
&lt;p&gt;我们知道，给电脑安装Windows系统需要有Windows镜像，因此给docker安装容器也是需要镜像的，所以，通俗一点，镜像就类似于我们日常中的安装软件，甚至说是操作系统镜像更为形象点。&lt;/p&gt;
&lt;p&gt;那容器和镜像有什么关系？&lt;/p&gt;
&lt;p&gt;网上说是类和对象的关系，没错，但是这样的比喻没什么实际卵用。&lt;/p&gt;
&lt;p&gt;我们知道:要运行一个web程序，需要有个Tomcat环境，需要Tomcat环境，那就下载一个Tomcat解压出来，然后把web程序放入Tomcat的webapps中启动即可，&lt;/p&gt;
&lt;p&gt;那么在docker中要运行一个web程序，就需要有Tomcat容器，需要Tomcat容器，就得去下载Tomcat镜像（也可以自己构建），把镜像pull下来之后，运行起来，就是一个Tomcat容器，此时把web程序至于Tomcat挂载的数据目录webapps中既可以运行。&lt;/p&gt;
&lt;p&gt;所以docker中，容器和镜像的关系更像是一种动静的关系，也就是说，存于仓库中的镜像是一个死的软件，而运行起来的容器则像是一个正在运行的程序（进程）。&lt;/p&gt;
&lt;p&gt;2、Docker有什么用&lt;br&gt;
对docker有了清晰的了解之后，我们心里可能在想： 这玩儿对我有什么用？ 我在哪里能用得上？ 怎么用才对？&lt;/p&gt;
&lt;p&gt;这里引用几个案例来让大家体会体会。&lt;/p&gt;
&lt;p&gt;1、案例一 前几天，公司一批服务器就要到期了，由于服务器是15年购买的，硬件的性能远比现在新出的云主机低，因此决定把所有服务器都换成新一代服务器，但是小编整准备动手迁移服务器时，内心一阵阵崩溃感涌上心头，仔细一算，每台服务器都要做同样的事情：&lt;/p&gt;
&lt;p&gt;1、安装jdk、Tomcat、nginx 2、配置jdk环境变量和系统变量 3、配置Tomcat 4、配置nginx 5、安装项目所需的视频解码组件 6、导入项目所需的一些特殊字体&lt;/p&gt;
&lt;p&gt;后来决定用docker部署的办法，在每台服务器都把docker安装之后，只需要在其中一台服务器中把Tomcat镜像从镜像仓库拉取下来，把这些配置都设置好，做成一个自己的镜像上传到镜像仓库中，之后在其他几台服务器都下载自己做的镜像，运行于docker中，把代码上传，就万事大吉了。&lt;/p&gt;
&lt;p&gt;2、案例二&lt;/p&gt;
&lt;p&gt;前不久的圣诞活动中，公司临时的活动方案在程序员的加班加点中终于上线，但是一上线之后发现推广海报中的中文名字乱码，领导问责测试人员怎么没做好测试，测试很委屈的说我已经测试无数遍并且测试报告都提交了，解决了所有问题才上线的；没办法只能让服务器同事查看正式服务器中的tomcat配置，发现原来 tomcat用了默认编码方式：iso8859-1，而测试环境中是UTF-8。针对这个问题，项目组决定把开发环境迁移到docker中，在测试环境中测试无误后，把镜像打包发布到正式环境中，解决了环境不同导致的问题。&lt;/p&gt;
&lt;p&gt;3、docker的安装&lt;br&gt;
感知到docker对我们开发者的好处之后，相信大家也跃跃欲试了吧，下面 就Linux centOS（版本大于等于7.0）系统进行演示docker的安装步骤：&lt;/p&gt;
&lt;p&gt;1、删除可能存在的旧版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 sudo yum remove docker
2 docker-client
3 docker-client-latest
4 docker-common
5 docker-latest
6 docker-latest-logrotate
7 docker-logrotate
8 docker-selinux
9 docker-engine-selinux
10 docker-engine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;2、安装一些必备工具：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 yum install -y yum-utils device-mapper-persistent-data lvm2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、添加Docker源：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1yum-config-manager
2 --add-repo
3 https://download.docker.com/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、更新yum缓存&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 yum makecache fast
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install docker-ce
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、创建docker用户&lt;/p&gt;
&lt;p&gt;温馨提示：以下操作不是必备，但是为了养成一个Linux用户的使用的良好习惯，小编不建议直接使用root操作，因此创建一个用户用来操作docker。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useradd docker_manager
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker_manager是用户名，可以根据喜好起名，创建完用户之后，设置密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 passwd docker_manager
2
3 docker_manager_wsdt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会提示输入密码和确认密码,按照提示操作即可&lt;/p&gt;
&lt;p&gt;7、配置docker用户的权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;visudo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;visudo是配置用户权限的文件，在命令行中输入visudo回车之后，会进入文件操作，找到“# %wheel ALL=(ALL) NOPASSWD: ALL”这一行，把前面的“#”去掉，保存文件&lt;/p&gt;
&lt;p&gt;8、授权&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;usermod -aG wheel,docker docker_manager
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9、启动 Docker CE&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl enable docker
sudo systemctl start docker
```　
此时在命令行中输入“docker info”之后，能够展示docker相关信息，就表示docker安装成功。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker info&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
10、镜像加速：

编辑daemon.json文件（首次安装daemon.json是个新文件，不要惊讶）

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vim /etc/docker/daemon.json&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;加入以下内容：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1{&lt;br&gt;
2 &amp;quot;registry-mirrors&amp;quot;: [&lt;br&gt;
3 &amp;quot;https://registry.docker-cn.com&amp;quot;&lt;br&gt;
4 ]&lt;br&gt;
5}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;保存，sudo systemctl restart docker重启即可。

4、总结
上面针对docker使用了一种比较通俗诙谐的语言来讲述，也是为了方便读者能容易的解读和理解，理解并且成功安装docker之后，你们就会想方设法的要把自己的web项目部署到docker了，这我没说错吧，大家可以网上查找一些资料去学习这一块。
学习转载：https://www.cnblogs.com/myprogramer/p/10288634.html&lt;/code&gt;&lt;/pre&gt;
">docker的安装与使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/docker-zhong-shi-yong-redis"" data-c="
          &lt;p&gt;项目中频繁使用Redis，为了不用每次打开Redis目录去启动Redis想到了Docker可以作为Redis的容器 直接下载使用就行 把Docker使用Redis的过程分享下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;拉取redis    （如果想直接运行也可以直接执行第二步省略第一步）
   docker pull redis

   拉取完成后可使用 docker images 查看镜像列表检查
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;后台运行redis server
   
   docker run --name redis-test -p 6379:6379 -d redis
   或者 docker run --name redis-test -p 6379:6379  --rm -d redis

   -d表示后台运行 
   -p表示本机端口映射到运行的容积端口  第一个是本机端口 第二个是容器端口
   --rm表示用完自动删除 容器停止运行后自动删除  一般不用
   --name表示指定名称 之后会用到
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 客户端连接redis 
   
   docker run -it --rm  redis redis-cli -h 192.168.1.99
   或者 完整 docker run -it --rm redis redis-cli -h 192.168.1.99 -p 6379 -a 123123
   
   -it表示运行后进入容器内部命令模式
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;启动已关闭的redis服务
   步骤二指定了redis的名称为redis-test 执行命令 redis start redis-test 启动redis服务
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;不小心关掉了正在连接的客户端界面redis-cli 
  - 查找当前运行的容器 docker ps  
  - 直接进入容器中 docker attach 容器标识
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;删除容器
   - docker rm [containerName||ID] 或者强制删除加-f参数
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐一个好用的redis可视化软件，免费的，“Another Redis Desktop Manager” 地址：https://github.com/qishibo/AnotherRedisDesktopManager/&lt;/p&gt;
&lt;!-- more --&gt;
">docker中使用redis</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/nuxt-fu-wu-duan-xuan-ran-he-yu-xuan-ran-de-qu-bie"" data-c="
          &lt;p&gt;nuxt分spa和非spa，预渲染直接nuxt generate打好的静态页面放在服务器就能访问(也是服务端渲染)， 服务端渲染需要先build完，把打出来的项目放到服务器，然后允许start，还要配置nginx转发&lt;br&gt;
使用nuxt的服务端渲染插件在node中可以直接返回&lt;br&gt;
预渲染不像服务器渲染那样即时编译 HTML，它只在构建时为了特定的路由生成特定的几个静态页面，等于我们可以通过 Webpack 插件将一些特定页面组件 build 时就编译为 html 文件，直接以静态资源的形式输出给搜索引擎。预渲染不执行js的，只适应于纯静态页面&lt;br&gt;
先说结论，都必然会优化SEO，原因如下：&lt;/p&gt;
&lt;p&gt;1、seo的本质是爬虫动态抓取根html里面的关键标签关键字；&lt;br&gt;
2、现代主流前端开发框架基本都是html拉回来之后，异步执行js动态挂载dom，根html在渲染之前里面提供给爬虫的信息极少；&lt;/p&gt;
&lt;p&gt;综上，如果不做服务器渲染或预渲染，seo只能抓到手动配置的顶级标签的关键字，效率与效果非常差&lt;br&gt;
不论是服务器渲染还是预渲染，它们都能“加速浏览器显示页面的速度”和seo优化。首先客户端程序只有js。现代网页出现以后这些js程度越来越复杂，于是必须有一些类似react、angular这样的东西。但这些东西全都有一个问题：第一次渲染结束前，页面是白的。于是有了服务端渲染：如果服务器恰好是nodejs，那么可以让服务器提前运行“第一次渲染”。浏览器只需要显示就好了，如果需要，再进行以后的渲染。&lt;/p&gt;
">nuxt 服务端渲染和预渲染的区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/docker-attach-ming-ling"" data-c="
          &lt;p&gt;docker attach :连接到正在运行中的容器。&lt;br&gt;
要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。&lt;/p&gt;
&lt;p&gt;官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了😨&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上--sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。&lt;br&gt;
runoob@runoob:~$ docker attach --sig-proxy=false mynginx&lt;/p&gt;
">Docker attach 命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/shell-dollar-huo-qu-han-shu-fan-hui-zhi-huo-zhe-shang-yi-ge-ming-ling-de-tui-chu-zhuang-tai"" data-c="
          &lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;?&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;否&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;标&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;志&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;如&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;果&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;则&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;? 是上一个程序执行是否成功的标志，如果执行成功则&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;程&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;序&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;执&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;否&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;成&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;功&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;标&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;志&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;如&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;果&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;执&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;成&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;功&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;? 为0，否则 不为0。&lt;br&gt;
比如判断一个node服务是该启动还是该重启，则可以执行pm2 info ***&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1641956978962.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">shell $? 获取函数返回值或者上一个命令的退出状态</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/wo-shi-ce-shi"" data-c="
          &lt;p&gt;作用：时间戳转化个格式&lt;/p&gt;
&lt;p&gt;原因：数据库中为了快速查询，一般保持日期是int(1415873634479),但是这样查询的时候很难知道确切的日期&lt;/p&gt;
&lt;p&gt;格式：select from_unixtime(1459338786);2016-03-30 19:53:06&lt;/p&gt;
&lt;p&gt;select from_unixtime(1459338786, &#39;%Y-%m-%d %H:%i:%s&#39;);2016-03-30 19:53:06&lt;/p&gt;
&lt;p&gt;SELECT id ,FROM_UNIXTIME(&#39;last_update_time&#39;) FROM current_inventory WHERE seat_code = &#39;hk2-i0302c03&#39; //字段要加引号&lt;/p&gt;
&lt;p&gt;备注：默认转化格式是%Y-%m-%d %H:%i:%s&lt;/p&gt;
&lt;p&gt;格式说明：&lt;/p&gt;
&lt;p&gt;%M 月名字(January～December)&lt;br&gt;
%W 星期名字(Sunday～Saturday)&lt;br&gt;
%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）&lt;br&gt;
%Y 年, 数字, 4 位&lt;br&gt;
%y 年, 数字, 2 位&lt;br&gt;
%a 缩写的星期名字(Sun～Sat)&lt;br&gt;
%d 月份中的天数, 数字(00～31)&lt;br&gt;
%e 月份中的天数, 数字(0～31)&lt;br&gt;
%m 月, 数字(01～12)&lt;br&gt;
%c 月, 数字(1～12)&lt;br&gt;
%b 缩写的月份名字(Jan～Dec)&lt;br&gt;
%j 一年中的天数(001～366)&lt;br&gt;
%H 小时(00～23)&lt;br&gt;
%k 小时(0～23)&lt;br&gt;
%h 小时(01～12)&lt;br&gt;
%I 小时(01～12)&lt;br&gt;
%l 小时(1～12)&lt;br&gt;
%i 分钟, 数字(00～59)&lt;br&gt;
%r 时间,12 小时(hh:mm:ss [AP]M)&lt;br&gt;
%T 时间,24 小时(hh:mm:ss)&lt;br&gt;
%S 秒(00～59)&lt;br&gt;
%s 秒(00～59)&lt;br&gt;
%p AM或PM&lt;br&gt;
%w 一个星期中的天数(0=Sunday ～6=Saturday ）&lt;br&gt;
%U 星期(0～52), 这里星期天是星期的第一天&lt;br&gt;
%u 星期(0～52), 这里星期一是星期的第一天&lt;br&gt;
%% 一个文字%&lt;/p&gt;
&lt;p&gt;原文链接：https://blog.csdn.net/yangliu4683/article/details/78340939&lt;/p&gt;
">mysql 时间戳格式化函数from_unixtime</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/about"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1640761677993.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&amp;gt; 欢迎来到我的小站呀，很高兴遇见你嘿嘿！🤝&lt;/p&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;https://www.cnblogs.com/lovesong/p/10847433.html&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/hello-gridea"" data-c="
          &lt;p&gt;强制commit规范常用的有两种，一种是在package项目中的gitHooks选项下的&amp;quot;commit-msg&amp;quot;设置自己的commit规则脚本。比如我要强制commit内容为feat:加空格xxx或者fix:加空格xxx，如果不符合给出相应提示，则我应该这么写：&lt;br&gt;
&lt;img src=&#34;https://note.youdao.com/yws/public/resource/d60e09a825bba46e1719f2dc06a2f7e3/xmlnote/302F691AA217499EA4DC783EA5E361B8/3538&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
verify-commit-msg.js中代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const chalk = require(&amp;quot;chalk&amp;quot;);
const msgPath = process.env.GIT_PARAMS;
const msg = require(&amp;quot;fs&amp;quot;)
  .readFileSync(msgPath, &amp;quot;utf-8&amp;quot;)
  .trim();

const commitRE = /^(revert: )?(feat|fix|polish|docs|style|refactor|perf|test|workflow|ci|chore|types|build|Merge)(\(.+\))?: .{1,50}|Merge /;

if (!commitRE.test(msg)) {
  console.error(
    `  ${chalk.bgRed.white(&amp;quot; ERROR &amp;quot;)} ${chalk.red(
      `invalid commit message format.`
    )}\n\n` +
      chalk.red(
        `  Proper commit message format is required for automated changelog generation. Examples:\n\n`
      ) +
      `    ${chalk.green(`feat: add &#39;comments&#39; option`)}\n` +
      `    ${chalk.green(`fix: handle events on blur (close #28)`)}\n\n` +
      chalk.red(
        `  You can also use ${chalk.cyan(
          `yarn commit`
        )} to interactively generate a commit message.\n`
      )
  );
  process.exit(1);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种是也可以使用&lt;a href=&#34;https://www.npmjs.com/package/git-cz/v/4.2.0&#34;&gt;git-cz&lt;/a&gt; 通过交互的方式生成更专业的commit，效果如下&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1642390440510.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">如何自定义commit规范</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642391805862.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n这里我用的是koa2+swagger&lt;/p&gt;\n&lt;h3 id=\&#34;安装\&#34;&gt;安装&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;// koa2-swagger-ui UI视图组件  swagger-jsdoc 识别写的 /***/ 转 json\nnpm install koa2-swagger-ui swagger-jsdoc --save\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.npmjs.com/package/koa2-swagger-ui\&#34;&gt;koa2-swagger-ui npm地址&lt;/a&gt; （创建接口文档）&lt;br&gt;\n&lt;a href=\&#34;https://www.npmjs.com/package/swagger-jsdoc\&#34;&gt;swagger-jsdoc npm地址&lt;/a&gt; （这个库读取带有jsdoc注释的源代码，并生成OpenAPI (Swagger)规范。）&lt;br&gt;\n&lt;a href=\&#34;https://www.jianshu.com/p/5365ef83252a\&#34;&gt;OpenAPI 规范摘要&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;配置\&#34;&gt;配置&lt;/h3&gt;\n&lt;p&gt;router.js&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const router = require(&#39;koa-router&#39;)() //引入路由函数\nconst swaggerJSDoc = require(&#39;swagger-jsdoc&#39;)\nconst path = require(&#39;path&#39;)\nconst swaggerDefinition = {\n  openapi: &#39;3.0.1&#39;,\n    info: {\n        title: &#39;blog项目访问地址&#39;,\n        version: &#39;1.0.0&#39;,\n        description: &#39;API&#39;,\n    },\n    basePath: &#39;/&#39;, // Base path (optional)\n    tags: [\n      {\n        name: &#39;manage&#39;,\n        description: &#39;管理系统&#39;\n      },\n      {\n        name: &#39;client&#39;,\n        description: &#39;日志上报&#39;\n      }\n    ],\n    schemes: [&#39;http&#39;, &#39;https&#39;],\n    securityDefinitions: {\n    server_auth: {\n      type: &#39;oauth2&#39;,\n      description: &#39;登录账号密码鉴权&#39;,\n      tokenUrl: &#39;http://localhost:4000/image/oauth&#39;,\n      flow: &#39;password&#39;,\n      scopes: {\n        token: &#39;modify pets in your account&#39;\n      }\n    },\n    token: {\n      type: &#39;apiKey&#39;,\n      name: &#39;token&#39;,\n      in: &#39;header&#39;\n    }\n  }\n};\nconst options = {\n    swaggerDefinition,\n    apis: [path.join(__dirname, &#39;./controllers/*.js&#39;)], // 包含上述注释的文件（）\n};\nconst swaggerSpec = swaggerJSDoc(options)\n// 通过路由获取生成的注解文件\nrouter.get(&#39;/swagger.json&#39;, async function (ctx) {\n    ctx.set(&#39;Content-Type&#39;, &#39;application/json&#39;);\n    ctx.body = swaggerSpec;\n})\nmodule.exports = router\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;app.js 入口文件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const swagger = require(&#39;./router&#39;)  // router中做了swagger配置\nconst { koaSwagger } = require(&#39;koa2-swagger-ui&#39;)\n\n// 接口文档配置\napp.use(swagger.routes(), swagger.allowedMethods())\napp.use(koaSwagger({\n  routePrefix: &#39;/swagger&#39;, // 接口文档访问地址\n  swaggerOptions: {\n    url: &#39;/swagger.json&#39;, // example path to json 其实就是之后swagger-jsdoc生成的文档地址\n  }\n}))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;启动项目，访问项目接口地址 + swagger ，我的地址是 http://localhost:8000/swagger&lt;/p&gt;\n&lt;h3 id=\&#34;注释生成文档\&#34;&gt;注释生成文档&lt;/h3&gt;\n&lt;p&gt;在controller层文件每个接口上写注释，注释是以@swagger开头的，swagger-jsdoc 会识别@swagger，然后解析下面的注释，解析完给koa2-swagger-ui显示成页面，总的流程就是这样。&lt;br&gt;\nget方式&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 获取博客列表\n/**\n * @swagger\n * /api/blog/list:\n *   get:\n *     summary: 获取博客列表\n *     description: 获取博客列表\n *     tags:\n *       - blogs\n *     parameters:\n *       - name: author\n *         in: query\n *         required: false\n *         description: 作者\n *         type: string\n *       - name: keyword\n *         in: query\n *         required: false\n *         description: 搜索关键字\n *         type: string\n *     responses:\n *       200:\n *         description: 成功获取\n */\nrouter.get(&#39;/list&#39;, async (ctx, next) =&amp;gt; {\n  const query = ctx.query\n  let author = query.author || &#39;&#39;\n  const keyword = query.keyword || &#39;&#39;\n\n  const listData = await getList(author, keyword)\n  ctx.body = new SuccessModel(listData)\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;post方式&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @swagger\n * definitions:\n *  loginparam:\n *    properties:\n *      username:\n *        type: &amp;quot;string&amp;quot;\n *        default: &amp;quot;shangsan&amp;quot;\n *        description: 用户名\n *      password:\n *        type: &amp;quot;string&amp;quot;\n *        default: &amp;quot;123&amp;quot;\n *        description: 密码\n */\n\n/**\n * @swagger\n * components:\n *   schemas:\n *     ProjectDetail:\n *       type: object\n *       properties:\n *         id:\n *           type: integer\n *           format: int64\n *         petId:\n *           type: integer\n *           format: int64\n *         quantity:\n *           type: integer\n *           format: int32\n *         shipDate:\n *           type: string\n *           format: date-time\n */\n\n/**\n * @swagger\n * /api/user/login:\n *   post:\n *     summary: 登录\n *     description: 登录\n *     tags:\n *       - user\n *     consumes:\n *      - application/json\n *      - application/xml\n *     produces:\n *      - application/json\n *      - application/xml\n *     parameters:\n *       - name: body\n *         in: body\n *         schema:\n *          $ref: &#39;#/definitions/loginparam&#39; （请求参数这里单独抽出，在上面定义）\n *     responses:\n *       200:\n *         description: 发布成功\n *          content:\n *           application/json:\n *             schema:\n *               $ref: &#39;#/components/schemas/ProjectDetail&#39;（返回参数也是单独抽出定义，这里是随便举个例子）\n *       402:\n *          description: 信息填写不全\n *       403:\n *          description: 参数类型错误\n */\n\nrouter.post(&#39;/login&#39;, async (ctx, next) =&amp;gt; {\n    // 业务逻辑\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;返回示例&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642412213197.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n基本的接口文档就生成啦，快试一下吧～&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;node-jie-kou-sheng-cheng-jie-kou-wen-dang&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;node接口生成接口文档&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-01-17 11:21:22&#34;,&#34;dateFormat&#34;:&#34;2022-01-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/node-jie-kou-sheng-cheng-jie-kou-wen-dang&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:194000,&#34;words&#34;:670,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n这里我用的是koa2+swagger\n安装\n// koa2-swagger-ui UI视图组件  swagger-jsdoc 识别写的 /***/ 转 json\nnpm install koa2-swagger-ui swagger-js...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85\&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE\&#34;&gt;配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E9%87%8A%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3\&#34;&gt;注释生成文档&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;https://www.sequelize.com.cn/\&#34;&gt;Sequelize 中文文档&lt;/a&gt;&lt;br&gt;\n可以先看文档，文档很全，它的语句帮我们做了很多处理，而且很精简，让我们不用死记硬背sql语句，也不用去库里建表。&lt;/p&gt;\n&lt;h3 id=\&#34;连接数据库\&#34;&gt;连接数据库&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;连接到数据库\n要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将连接参数分别传递到 Sequelize 构造函数或通过传递一个连接 URI 来完成：\n\nconst { Sequelize } = require(&#39;sequelize&#39;);\n\n// 方法 1: 传递一个连接 URI\nconst sequelize = new Sequelize(&#39;sqlite::memory:&#39;) // Sqlite 示例\nconst sequelize = new Sequelize(&#39;postgres://user:pass@example.com:5432/dbname&#39;) // Postgres 示例\n\n// 方法 2: 分别传递参数 (sqlite)\nconst sequelize = new Sequelize({\n  dialect: &#39;sqlite&#39;,\n  storage: &#39;path/to/database.sqlite&#39;\n});\n\n// 方法 3: 分别传递参数 (其它数据库)\nconst sequelize = new Sequelize(&#39;database&#39;, &#39;username&#39;, &#39;password&#39;, {\n  host: &#39;localhost&#39;,\n  dialect: /* 选择 &#39;mysql&#39; | &#39;mariadb&#39; | &#39;postgres&#39; | &#39;mssql&#39; 其一 */\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;定义模型-定义表结构\&#34;&gt;定义模型 （定义表结构）&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;module.exports = function(sequelize, DataTypes) {\n  return sequelize.define(\n    &#39;project&#39;,\n    {\n      id: {\n        type: DataTypes.INTEGER(11),\n        allowNull: false,\n        primaryKey: true,\n        autoIncrement: true\n      },\n      name: { type: DataTypes.STRING(255), allowNull: true },\n      title: { type: DataTypes.STRING(255), allowNull: true },\n      report_fix_id: { type: DataTypes.STRING(1000), allowNull: true },\n      fix_url: { type: DataTypes.STRING(2000), allowNull: true },\n      ignore_key: {\n        type: DataTypes.STRING(2000),\n        allowNull: true,\n        comment: &#39;简化打印对象中比较大的对象&#39;\n      },\n      env: {\n        type: DataTypes.STRING(255),\n        allowNull: true,\n        comment: &#39;哪些环境能上报日志&#39;\n      },\n      report_interval: {\n        type: DataTypes.INTEGER(11),\n        allowNull: true,\n        comment: &#39;上报时间间隔&#39;\n      },\n      ctime: {\n        type: DataTypes.INTEGER(10),\n        allowNull: true,\n        get() {\n          return moment\n            .unix(this.getDataValue(&#39;ctime&#39;))\n            .format(&#39;YYYY/MM/DD HH:mm:ss&#39;)\n        }\n      },\n      del: { type: DataTypes.INTEGER(1), allowNull: true, defaultValue: &#39;0&#39; }\n    },\n    {\n      tableName: &#39;project&#39;\n    }\n  )\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;模型同步-真正从数据库创建\&#34;&gt;模型同步 （真正从数据库创建）&lt;/h3&gt;\n&lt;p&gt;定义模型时,你要告诉 Sequelize 有关数据库中表的一些信息. 但是,如果该表实际上不存在于数据库中怎么办？ 如果存在,但具有不同的列,较少的列或任何其他差异,该怎么办？&lt;/p&gt;\n&lt;p&gt;这就是模型同步的来源.可以通过调用一个异步函数(返回一个Promise)model.sync(options). 通过此调用,Sequelize 将自动对数据库执行 SQL 查询. 请注意,这仅更改数据库中的表,而不更改 JavaScript 端的模型.&lt;/p&gt;\n&lt;p&gt;User.sync() - 如果表不存在,则创建该表(如果已经存在,则不执行任何操作)&lt;/p&gt;\n&lt;h4 id=\&#34;usersync-force-true-将创建表如果表已经存在则将其首先删除-这个不要用也最好别试\&#34;&gt;User.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除 （这个不要用，也最好别试）&lt;/h4&gt;\n&lt;p&gt;User.sync({ alter: true }) - 这将检查数据库中表的当前状态(它具有哪些列,它们的数据类型等),然后在表中进行必要的更改以使其与模型匹配.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;sequelize\n  .authenticate()\n  .then(() =&amp;gt; {\n    console.log(&#39;数据库连接成功&#39;.green)\n    // sequelize.sync({ alter: true })\n  })\n  .catch(err =&amp;gt; {\n    console.log(&#39;数据库连接失败&#39;.red)\n  })\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;创建实例修改内容insert\&#34;&gt;创建实例（修改内容INSERT）&lt;/h3&gt;\n&lt;p&gt;尽管模型是一个类,但是你不应直接使用 new 运算符来创建实例. 相反,应该使用 build 方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const jane = User.build({ name: &amp;quot;Jane&amp;quot; });\nconsole.log(jane instanceof User); // true\nconsole.log(jane.name); // &amp;quot;Jane&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是,以上代码根本无法与数据库通信(请注意,它甚至不是异步的)！ 这是因为 build 方法仅创建一个对象,该对象 表示 可以 映射到数据库的数据. 为了将这个实例真正保存(即持久保存)在数据库中,应使用 save 方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;await jane.save();\nconsole.log(&#39;Jane 已保存到数据库!&#39;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;请注意,从上面代码段中的 await 用法来看,save 是一种异步方法. 实际上,几乎每个 Sequelize 方法都是异步的. build 是极少数例外之一.&lt;/p&gt;\n&lt;p&gt;非常有用的捷径: create 方法&lt;br&gt;\nSequelize提供了 create 方法,该方法将上述的 build 方法和 save 方法合并为一个方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const jane = await User.create({ name: &amp;quot;Jane&amp;quot; });\n// Jane 现在存在于数据库中！\nconsole.log(jane instanceof User); // true\nconsole.log(jane.name); // &amp;quot;Jane&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;简单-select-查询\&#34;&gt;简单 SELECT 查询&lt;/h3&gt;\n&lt;p&gt;你可以使用 findAll 方法从数据库中读取整个表：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 查询所有用户\nconst users = await User.findAll();\nconsole.log(users.every(user =&amp;gt; user instanceof User)); // true\nconsole.log(&amp;quot;All users:&amp;quot;, JSON.stringify(users, null, 2));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;相当于sql语句&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT * FROM ...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;嗯，写一些建表与查询的流程，照着官网抄也没什么意思。使用这个我们可以很轻松的操作数据库，使我们写node接口的时候效率翻倍～&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;sequelize-node-lian-jie-shu-ju-ku-de-orm&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Sequelize node连接数据库的ORM&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-01-14 15:36:06&#34;,&#34;dateFormat&#34;:&#34;2022-01-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:257000,&#34;words&#34;:1033,&#34;minutes&#34;:5},&#34;description&#34;:&#34;Sequelize 中文文档\n可以先看文档，文档很全，它的语句帮我们做了很多处理，而且很精简，让我们不用死记硬背sql语句，也不用去库里建表。\n连接数据库\n连接到数据库\n要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93\&#34;&gt;连接数据库&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B-%E5%AE%9A%E4%B9%89%E8%A1%A8%E7%BB%93%E6%9E%84\&#34;&gt;定义模型 （定义表结构）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A8%A1%E5%9E%8B%E5%90%8C%E6%AD%A5-%E7%9C%9F%E6%AD%A3%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA\&#34;&gt;模型同步 （真正从数据库创建）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#usersync-force-true-%E5%B0%86%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%A6%82%E6%9E%9C%E8%A1%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E5%88%99%E5%B0%86%E5%85%B6%E9%A6%96%E5%85%88%E5%88%A0%E9%99%A4-%E8%BF%99%E4%B8%AA%E4%B8%8D%E8%A6%81%E7%94%A8%E4%B9%9F%E6%9C%80%E5%A5%BD%E5%88%AB%E8%AF%95\&#34;&gt;User.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除 （这个不要用，也最好别试）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9insert\&#34;&gt;创建实例（修改内容INSERT）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E5%8D%95-select-%E6%9F%A5%E8%AF%A2\&#34;&gt;简单 SELECT 查询&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;官网介绍：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。&lt;br&gt;\n&lt;a href=\&#34;https://nacos.io/zh-cn/docs/what-is-nacos.html\&#34;&gt;Nacos中文文档&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;概览&lt;br&gt;\n欢迎来到 Nacos 的世界！&lt;br&gt;\nNacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。&lt;br&gt;\nNacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;这个东西主要用于微服务，但我作为一个前端，只用了它的配置管理功能，虽然有点大材小用，但确实方便,而且还可以通过网页去直接查看数据结构。&lt;/p&gt;\n&lt;p&gt;假设前端要搞一个平台，但是并没有后端支持，那么权限管理以及一些必要的数据获取该怎么做呢，我们想到的肯定是node起服务，然后写接口，然后连接数据库。从而实现数据的增删改查。&lt;/p&gt;\n&lt;p&gt;但有一种更简单的方式，就是在服务器的docker中下载一个nacos,把数据放到nacos中管理，这样数据依然在我们的服务器上，并且不需要我们自己去写接口，nacos提供了openApi，我们直接调用接口就可以，是不是很方便呢。下面开始安装：&lt;/p&gt;\n&lt;h3 id=\&#34;nacos-docker-快速开始\&#34;&gt;Nacos Docker 快速开始&lt;/h3&gt;\n&lt;p&gt;操作步骤&lt;br&gt;\nClone 项目&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;git clone https://github.com/nacos-group/nacos-docker.git\ncd nacos-docker\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;单机模式 Derby&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-derby.yaml up\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;单机模式 MySQL&lt;/p&gt;\n&lt;p&gt;如果希望使用MySQL5.7&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-mysql-5.7.yaml up\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果希望使用MySQL8&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-mysql-8.yaml up\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;集群模式&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker-compose -f example/cluster-hostname.yaml up \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;服务注册&lt;/p&gt;\n&lt;p&gt;curl -X POST &#39;http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;amp;ip=20.18.7.10&amp;amp;port=8080&#39;&lt;br&gt;\n服务发现&lt;/p&gt;\n&lt;p&gt;curl -X GET &#39;http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName&#39;&lt;br&gt;\n发布配置&lt;/p&gt;\n&lt;p&gt;curl -X POST &amp;quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;amp;group=test&amp;amp;content=helloWorld&amp;quot;&lt;br&gt;\n获取配置&lt;/p&gt;\n&lt;p&gt;curl -X GET &amp;quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;amp;group=test&amp;quot;&lt;br&gt;\nNacos 控制台&lt;/p&gt;\n&lt;p&gt;link：http://127.0.0.1:8848/nacos/（因为是在服务器上，所以可以直接使用对应的域名或者ip来访问）&lt;/p&gt;\n&lt;h3 id=\&#34;注意这里要用openapi提供的字段信息多了tenant字段-有哪里不明白的可以看下开头的官方文档哈\&#34;&gt;注意，这里要用openApi提供的字段信息，多了tenant字段。有哪里不明白的可以看下开头的官方文档哈。&lt;/h3&gt;\n&#34;,&#34;fileName&#34;:&#34;sequelize&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;前端使用Nacos&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-01-14 15:36:06&#34;,&#34;dateFormat&#34;:&#34;2022-01-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/sequelize&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:162000,&#34;words&#34;:664,&#34;minutes&#34;:3},&#34;description&#34;:&#34;官网介绍：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\nNacos中文文档\n\n概览\n欢迎来到 Nacos 的世界！\nNacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#nacos-docker-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B\&#34;&gt;Nacos Docker 快速开始&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F%E8%BF%99%E9%87%8C%E8%A6%81%E7%94%A8openapi%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF%E5%A4%9A%E4%BA%86tenant%E5%AD%97%E6%AE%B5-%E6%9C%89%E5%93%AA%E9%87%8C%E4%B8%8D%E6%98%8E%E7%99%BD%E7%9A%84%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%B8%8B%E5%BC%80%E5%A4%B4%E7%9A%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%93%88\&#34;&gt;注意，这里要用openApi提供的字段信息，多了tenant字段。有哪里不明白的可以看下开头的官方文档哈。&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;https://www.mysqlzh.com/doc/124.html\&#34;&gt;mysql中文文档&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;1查询记录\&#34;&gt;1.查询记录&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select*from 表名 [where 条件];\n\neg:select*from students;//查询 students 表中所有记录，所有字段的值都显示出来\n\nselect field1,field2,...fieldn... from 表名 [where 条件];\n\neg:select id,name,age from students;//查询 students 表中所有记录, 只显示出 id，name，age三个字段的值\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;1.“*”表示将所有的字段都显示出来&lt;/p&gt;\n&lt;p&gt;2.用逗号分割，列出需要显示的字段&lt;/p&gt;\n&lt;h3 id=\&#34;2查询不重复的记录\&#34;&gt;2.查询不重复的记录&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select distinct 字段 from 表名;\n\neg: select distinct name from students;//查询名字不相同的学生;\n　　select distinct name,age from students;//查询名字和年龄同时不同的学生\n　　\n　　1.distinct必须放在最开头\n　　2.distinct只能使用需要去重的字段进行操作。  ----也就是说我sidtinct了name,age两个字段，我后面想根据id进行排序，是不可以的，因为只能name,age两个字段进行操作.\n　　3.distinct去重多个字段时，含义是：几个字段 同时重复 时才会被 过滤。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;3条件查询\&#34;&gt;3.条件查询&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select 字段 from 表名 where 条件;\n\neg:select * from student where sex=&#39;男&#39; and age&amp;gt;20; //查询性别是男，并且年龄大于20岁的人。\n\nwhere后面的条件可以用&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、!=等多种比较运算符，多个条件之间可以用or、and等逻辑运算符\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;4排序和限制\&#34;&gt;4.排序和限制&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;排序\nselect * from 表名 [where 条件] [ order by  field1 [desc/asc],field2 [desc/asc]... ];\n\neg:select *from student order by age desc;//查询学生表并按年龄降序排列。\n\n1.desc 降序排列，asc 升序排列\n2.order by 后面可以跟多个不同的排序字段，每个排序字段都可以有不同的排序顺序。\n3.如果排序字段的值一样，则相同的字段按照第二个排序字段进行排序。\n4.如果只有一个排序字段，则字段相同的记录将会无序排列。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;限制\nselect ... [limit 起始偏移量,行数];\n\neg:select * from student order by mark desc limit 5;//取出成绩前五名的学生(省略了起始偏移量，此时默认为0)\n\n1.默认情况下，起始偏移量为0，只写记录行数就可以。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;5聚合\&#34;&gt;5.聚合&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select 字段 fun_name from 表名 [where 条件] [group by field1,field2...] [with rollup] [having 条件];\n\neg:\n\n1.fun_name 表示要做的聚合操作，也就是说聚合函数，常用的有 : sum(求和)、count(*)(记录数)、max(最大值)、min(最小值)。\n2.group by关键字 表示要进行分类聚合的字段。比如要按照部门分类统计员工数量，部门就应该写在group by 后面。\n3.with rollup 是可选语法，表明是否对分类聚合后的结果进行再汇总\n4.having 关键字表示对分类后的结果再进行条件过滤。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;公司员工表A如下 (编号，姓，名，薪水) ：&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143111386.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;统计总人数\nselect count(1) from A;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143169839.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code&gt;统计各个姓的人数\nselect xing,count(1) from A group by xing;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143194061.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code&gt;既要统计各个姓的人数，又统计总人数\nselect xing,count(1) from A group by xing with rollup;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143250933.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code&gt;统计人数大4的姓\nselect xing,count(1) from A group by xing having count(1)&amp;gt;4;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143298558.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code&gt;统计薪水总额，最低薪资，最高薪资\nselect count(1),min(salary),max(salary) from A;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143319528.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;6为表和字段取别名\&#34;&gt;6.为表和字段取别名&lt;/h3&gt;\n&lt;p&gt;在查询数据时，可以为表和字段取别名，这个别名可以代替指定的表和字段。如果表名很长，用起来不方便，则可以用一个别名来代替，语法如下：(as关键字可省略)&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;select * from 表名 [as] 别名  （为表取别名）\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;SELECT 字段名 [AS] 别名[,字段名 [AS] 别名,……] FROM 表名; (为字段取别名)\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-cha-xun-yu-ju&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;mysql查询语句&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-01-14 14:46:38&#34;,&#34;dateFormat&#34;:&#34;2022-01-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/mysql-cha-xun-yu-ju&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:220000,&#34;words&#34;:918,&#34;minutes&#34;:4},&#34;description&#34;:&#34;mysql中文文档\n1.查询记录\nselect*from 表名 [where 条件];\n\neg:select*from students;//查询 students 表中所有记录，所有字段的值都显示出来\n\nselect field1,fie...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95\&#34;&gt;1.查询记录&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E6%9F%A5%E8%AF%A2%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E8%AE%B0%E5%BD%95\&#34;&gt;2.查询不重复的记录&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2\&#34;&gt;3.条件查询&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E6%8E%92%E5%BA%8F%E5%92%8C%E9%99%90%E5%88%B6\&#34;&gt;4.排序和限制&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5%E8%81%9A%E5%90%88\&#34;&gt;5.聚合&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6%E4%B8%BA%E8%A1%A8%E5%92%8C%E5%AD%97%E6%AE%B5%E5%8F%96%E5%88%AB%E5%90%8D\&#34;&gt;6.为表和字段取别名&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;http://www.dockerinfo.net/document\&#34;&gt;docker中文文档&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;最近Docker突然火得不得了，到处都是谈论Docker的声音，相信大家和小编一样的心情，看这个东西有点高大上，但尝试去阅读Docker文章时又发现概念很模糊、不接地气、难以理解、无从下手…于是三天打鱼两天晒网，最终不了了之，反正公司也没要求用这玩意儿，不费劲了… 这不，当前几天项目要求快速上线并且部署多台服务器环境时，小编一台一台服务器的yum install、vim、restart…想屎的心都有，那时小编心里想要是有一个这么一个U盘，能把整个环境一台一台的Ctrl+V过去，那该多好啊。那时脑子一下子闪过一个念头：Docker不就是我想拥有的那个U盘吗。&lt;/p&gt;\n&lt;p&gt;怀着这样的一个念头，小编花了一些时间去查阅Docker相关的书籍、看视频、逛论坛，刚开始学习时非常难受，搞不懂什么是容器什么是镜像什么是鲸鱼船…而涉及到一些原理底层的知识，书籍里的那些概念比代码都能懂，小编硬啃了一段时间并且实操了几次之后，再回过头来，才豁然开朗。念及许多想要学Docker却苦于难以入门的开发者们，正在学习却很挣扎的初学者们，故而把小编这段时间的学习成果，以一个初学者的角度，遵循循序渐进的原则，编成一份通俗易懂的文章，希望能以此引导入门，早日成Docker大神。&lt;/p&gt;\n&lt;p&gt;文章提纲：&lt;/p&gt;\n&lt;p&gt;1、什么是Docker&lt;/p&gt;\n&lt;p&gt;2、Docker对我们有什么用处&lt;/p&gt;\n&lt;p&gt;3、Docker安装和使用&lt;/p&gt;\n&lt;p&gt;4、彩蛋&lt;/p&gt;\n&lt;p&gt;1、什么是Docker&lt;br&gt;\n什么是docker？恐怕90%的人脑子一闪而过的都是那张图：一条鲸鱼背上扛着一堆箱子，图片下方是大大的“docker”。&lt;/p&gt;\n&lt;p&gt;docker是什么？&lt;/p&gt;\n&lt;p&gt;是鲸鱼？&lt;/p&gt;\n&lt;p&gt;还是一堆箱子？&lt;/p&gt;\n&lt;p&gt;或者说是载着箱子的鲸鱼？&lt;br&gt;\n这里小编不做解释，先引用一下官方的解释：&lt;/p&gt;\n&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;\n&lt;p&gt;顾名思义，docker是一个容器引擎，容器且不说，什么是引擎？&lt;/p&gt;\n&lt;p&gt;我们知道：&lt;/p&gt;\n&lt;p&gt;汽车的引擎是发动机，有了发动起，汽车才能跑起来&lt;/p&gt;\n&lt;p&gt;游戏需要游戏引擎（如Unity3D..），基于引擎的开发，能让游戏动起来。&lt;/p&gt;\n&lt;p&gt;如官言，docker也是一种引擎，基于这个引擎，开发者能让他们开发的应用处于一个有隔离性的、可移植性的容器中，以便于发布于各种机器中而无需考虑兼容性问题。&lt;/p&gt;\n&lt;p&gt;因此就不难解释，为什么docker的logo是一条装着一堆箱子的鲸鱼.&lt;/p&gt;\n&lt;p&gt;这是因为：docker扮演的是图中鲸鱼的角色，而鲸鱼之上的集装箱就是一个个容器，容器中是我们开发的应用程序（不仅限于web应用），每个容器都有自己独立的环境（环境设置、网络、文件系统…），互不干扰。而每个箱子，又可以打包成一个新的镜像，放到其它服务器的docker环境中直接运行，不再需要重复安装程序运行环境。&lt;/p&gt;\n&lt;p&gt;上面的解释插入了两个生疏的概念：&lt;/p&gt;\n&lt;p&gt;1、镜像&lt;/p&gt;\n&lt;p&gt;2、容器&lt;/p&gt;\n&lt;p&gt;我们先讲容器&lt;/p&gt;\n&lt;p&gt;容器，顾名思义：就是装东西的器皿，在docker中，容器就是装载我们的应用程序的器皿，在docker的logo中，容器就是一个个箱子。我们知道，运行JavaWeb应用程序需要有Tomcat，那么我们就需要创建一个Tomcat的容器，才能把我们的程序放进去运行。&lt;/p&gt;\n&lt;p&gt;那么，容器哪里来的呢&lt;/p&gt;\n&lt;p&gt;我们知道，给电脑安装Windows系统需要有Windows镜像，因此给docker安装容器也是需要镜像的，所以，通俗一点，镜像就类似于我们日常中的安装软件，甚至说是操作系统镜像更为形象点。&lt;/p&gt;\n&lt;p&gt;那容器和镜像有什么关系？&lt;/p&gt;\n&lt;p&gt;网上说是类和对象的关系，没错，但是这样的比喻没什么实际卵用。&lt;/p&gt;\n&lt;p&gt;我们知道:要运行一个web程序，需要有个Tomcat环境，需要Tomcat环境，那就下载一个Tomcat解压出来，然后把web程序放入Tomcat的webapps中启动即可，&lt;/p&gt;\n&lt;p&gt;那么在docker中要运行一个web程序，就需要有Tomcat容器，需要Tomcat容器，就得去下载Tomcat镜像（也可以自己构建），把镜像pull下来之后，运行起来，就是一个Tomcat容器，此时把web程序至于Tomcat挂载的数据目录webapps中既可以运行。&lt;/p&gt;\n&lt;p&gt;所以docker中，容器和镜像的关系更像是一种动静的关系，也就是说，存于仓库中的镜像是一个死的软件，而运行起来的容器则像是一个正在运行的程序（进程）。&lt;/p&gt;\n&lt;p&gt;2、Docker有什么用&lt;br&gt;\n对docker有了清晰的了解之后，我们心里可能在想： 这玩儿对我有什么用？ 我在哪里能用得上？ 怎么用才对？&lt;/p&gt;\n&lt;p&gt;这里引用几个案例来让大家体会体会。&lt;/p&gt;\n&lt;p&gt;1、案例一 前几天，公司一批服务器就要到期了，由于服务器是15年购买的，硬件的性能远比现在新出的云主机低，因此决定把所有服务器都换成新一代服务器，但是小编整准备动手迁移服务器时，内心一阵阵崩溃感涌上心头，仔细一算，每台服务器都要做同样的事情：&lt;/p&gt;\n&lt;p&gt;1、安装jdk、Tomcat、nginx 2、配置jdk环境变量和系统变量 3、配置Tomcat 4、配置nginx 5、安装项目所需的视频解码组件 6、导入项目所需的一些特殊字体&lt;/p&gt;\n&lt;p&gt;后来决定用docker部署的办法，在每台服务器都把docker安装之后，只需要在其中一台服务器中把Tomcat镜像从镜像仓库拉取下来，把这些配置都设置好，做成一个自己的镜像上传到镜像仓库中，之后在其他几台服务器都下载自己做的镜像，运行于docker中，把代码上传，就万事大吉了。&lt;/p&gt;\n&lt;p&gt;2、案例二&lt;/p&gt;\n&lt;p&gt;前不久的圣诞活动中，公司临时的活动方案在程序员的加班加点中终于上线，但是一上线之后发现推广海报中的中文名字乱码，领导问责测试人员怎么没做好测试，测试很委屈的说我已经测试无数遍并且测试报告都提交了，解决了所有问题才上线的；没办法只能让服务器同事查看正式服务器中的tomcat配置，发现原来 tomcat用了默认编码方式：iso8859-1，而测试环境中是UTF-8。针对这个问题，项目组决定把开发环境迁移到docker中，在测试环境中测试无误后，把镜像打包发布到正式环境中，解决了环境不同导致的问题。&lt;/p&gt;\n&lt;p&gt;3、docker的安装&lt;br&gt;\n感知到docker对我们开发者的好处之后，相信大家也跃跃欲试了吧，下面 就Linux centOS（版本大于等于7.0）系统进行演示docker的安装步骤：&lt;/p&gt;\n&lt;p&gt;1、删除可能存在的旧版本&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;1 sudo yum remove docker\n2 docker-client\n3 docker-client-latest\n4 docker-common\n5 docker-latest\n6 docker-latest-logrotate\n7 docker-logrotate\n8 docker-selinux\n9 docker-engine-selinux\n10 docker-engine\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;2、安装一些必备工具：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;1 yum install -y yum-utils device-mapper-persistent-data lvm2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;3、添加Docker源：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;1yum-config-manager\n2 --add-repo\n3 https://download.docker.com/linux/centos/docker-ce.repo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;4、更新yum缓存&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;1 yum makecache fast\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;5、安装&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;yum install docker-ce\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;6、创建docker用户&lt;/p&gt;\n&lt;p&gt;温馨提示：以下操作不是必备，但是为了养成一个Linux用户的使用的良好习惯，小编不建议直接使用root操作，因此创建一个用户用来操作docker。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;useradd docker_manager\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;docker_manager是用户名，可以根据喜好起名，创建完用户之后，设置密码&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;1 passwd docker_manager\n2\n3 docker_manager_wsdt\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;会提示输入密码和确认密码,按照提示操作即可&lt;/p&gt;\n&lt;p&gt;7、配置docker用户的权限&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;visudo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;visudo是配置用户权限的文件，在命令行中输入visudo回车之后，会进入文件操作，找到“# %wheel ALL=(ALL) NOPASSWD: ALL”这一行，把前面的“#”去掉，保存文件&lt;/p&gt;\n&lt;p&gt;8、授权&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;usermod -aG wheel,docker docker_manager\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;9、启动 Docker CE&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;sudo systemctl enable docker\nsudo systemctl start docker\n```　\n此时在命令行中输入“docker info”之后，能够展示docker相关信息，就表示docker安装成功。\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;docker info&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\n10、镜像加速：\n\n编辑daemon.json文件（首次安装daemon.json是个新文件，不要惊讶）\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;vim /etc/docker/daemon.json&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;加入以下内容：\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;1{&lt;br&gt;\n2 &amp;quot;registry-mirrors&amp;quot;: [&lt;br&gt;\n3 &amp;quot;https://registry.docker-cn.com&amp;quot;&lt;br&gt;\n4 ]&lt;br&gt;\n5}&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;保存，sudo systemctl restart docker重启即可。\n\n4、总结\n上面针对docker使用了一种比较通俗诙谐的语言来讲述，也是为了方便读者能容易的解读和理解，理解并且成功安装docker之后，你们就会想方设法的要把自己的web项目部署到docker了，这我没说错吧，大家可以网上查找一些资料去学习这一块。\n学习转载：https://www.cnblogs.com/myprogramer/p/10288634.html&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-de-an-zhuang-yu-shi-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;docker的安装与使用&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-01-13 17:14:24&#34;,&#34;dateFormat&#34;:&#34;2022-01-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/docker-de-an-zhuang-yu-shi-yong&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:530000,&#34;words&#34;:2426,&#34;minutes&#34;:9},&#34;description&#34;:&#34;docker中文文档\n最近Docker突然火得不得了，到处都是谈论Docker的声音，相信大家和小编一样的心情，看这个东西有点高大上，但尝试去阅读Docker文章时又发现概念很模糊、不接地气、难以理解、无从下手…于是三天打鱼两天晒网，最终不...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;项目中频繁使用Redis，为了不用每次打开Redis目录去启动Redis想到了Docker可以作为Redis的容器 直接下载使用就行 把Docker使用Redis的过程分享下：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;拉取redis    （如果想直接运行也可以直接执行第二步省略第一步）\n   docker pull redis\n\n   拉取完成后可使用 docker images 查看镜像列表检查\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;后台运行redis server\n   \n   docker run --name redis-test -p 6379:6379 -d redis\n   或者 docker run --name redis-test -p 6379:6379  --rm -d redis\n\n   -d表示后台运行 \n   -p表示本机端口映射到运行的容积端口  第一个是本机端口 第二个是容器端口\n   --rm表示用完自动删除 容器停止运行后自动删除  一般不用\n   --name表示指定名称 之后会用到\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt; 客户端连接redis \n   \n   docker run -it --rm  redis redis-cli -h 192.168.1.99\n   或者 完整 docker run -it --rm redis redis-cli -h 192.168.1.99 -p 6379 -a 123123\n   \n   -it表示运行后进入容器内部命令模式\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;启动已关闭的redis服务\n   步骤二指定了redis的名称为redis-test 执行命令 redis start redis-test 启动redis服务\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;不小心关掉了正在连接的客户端界面redis-cli \n  - 查找当前运行的容器 docker ps  \n  - 直接进入容器中 docker attach 容器标识\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;删除容器\n   - docker rm [containerName||ID] 或者强制删除加-f参数\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;推荐一个好用的redis可视化软件，免费的，“Another Redis Desktop Manager” 地址：https://github.com/qishibo/AnotherRedisDesktopManager/&lt;/p&gt;\n&lt;!-- more --&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-zhong-shi-yong-redis&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;项目中频繁使用Redis，为了不用每次打开Redis目录去启动Redis想到了Docker可以作为Redis的容器 直接下载使用就行 把Docker使用Redis的过程分享下：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;拉取redis    （如果想直接运行也可以直接执行第二步省略第一步）\n   docker pull redis\n\n   拉取完成后可使用 docker images 查看镜像列表检查\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;后台运行redis server\n   \n   docker run --name redis-test -p 6379:6379 -d redis\n   或者 docker run --name redis-test -p 6379:6379  --rm -d redis\n\n   -d表示后台运行 \n   -p表示本机端口映射到运行的容积端口  第一个是本机端口 第二个是容器端口\n   --rm表示用完自动删除 容器停止运行后自动删除  一般不用\n   --name表示指定名称 之后会用到\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt; 客户端连接redis \n   \n   docker run -it --rm  redis redis-cli -h 192.168.1.99\n   或者 完整 docker run -it --rm redis redis-cli -h 192.168.1.99 -p 6379 -a 123123\n   \n   -it表示运行后进入容器内部命令模式\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;启动已关闭的redis服务\n   步骤二指定了redis的名称为redis-test 执行命令 redis start redis-test 启动redis服务\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;不小心关掉了正在连接的客户端界面redis-cli \n  - 查找当前运行的容器 docker ps  \n  - 直接进入容器中 docker attach 容器标识\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;删除容器\n   - docker rm [containerName||ID] 或者强制删除加-f参数\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;推荐一个好用的redis可视化软件，免费的，“Another Redis Desktop Manager” 地址：https://github.com/qishibo/AnotherRedisDesktopManager/&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;docker中使用redis&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-01-13 17:08:41&#34;,&#34;dateFormat&#34;:&#34;2022-01-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/docker-zhong-shi-yong-redis&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:91000,&#34;words&#34;:376,&#34;minutes&#34;:2},&#34;description&#34;:&#34;项目中频繁使用Redis，为了不用每次打开Redis目录去启动Redis想到了Docker可以作为Redis的容器 直接下载使用就行 把Docker使用Redis的过程分享下：\n\n\n拉取redis    （如果想直接运行也可以直接执行第二步...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;nuxt分spa和非spa，预渲染直接nuxt generate打好的静态页面放在服务器就能访问(也是服务端渲染)， 服务端渲染需要先build完，把打出来的项目放到服务器，然后允许start，还要配置nginx转发&lt;br&gt;\n使用nuxt的服务端渲染插件在node中可以直接返回&lt;br&gt;\n预渲染不像服务器渲染那样即时编译 HTML，它只在构建时为了特定的路由生成特定的几个静态页面，等于我们可以通过 Webpack 插件将一些特定页面组件 build 时就编译为 html 文件，直接以静态资源的形式输出给搜索引擎。预渲染不执行js的，只适应于纯静态页面&lt;br&gt;\n先说结论，都必然会优化SEO，原因如下：&lt;/p&gt;\n&lt;p&gt;1、seo的本质是爬虫动态抓取根html里面的关键标签关键字；&lt;br&gt;\n2、现代主流前端开发框架基本都是html拉回来之后，异步执行js动态挂载dom，根html在渲染之前里面提供给爬虫的信息极少；&lt;/p&gt;\n&lt;p&gt;综上，如果不做服务器渲染或预渲染，seo只能抓到手动配置的顶级标签的关键字，效率与效果非常差&lt;br&gt;\n不论是服务器渲染还是预渲染，它们都能“加速浏览器显示页面的速度”和seo优化。首先客户端程序只有js。现代网页出现以后这些js程度越来越复杂，于是必须有一些类似react、angular这样的东西。但这些东西全都有一个问题：第一次渲染结束前，页面是白的。于是有了服务端渲染：如果服务器恰好是nodejs，那么可以让服务器提前运行“第一次渲染”。浏览器只需要显示就好了，如果需要，再进行以后的渲染。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;nuxt-fu-wu-duan-xuan-ran-he-yu-xuan-ran-de-qu-bie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;nuxt 服务端渲染和预渲染的区别&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-01-13 15:38:15&#34;,&#34;dateFormat&#34;:&#34;2022-01-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/nuxt-fu-wu-duan-xuan-ran-he-yu-xuan-ran-de-qu-bie&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:100000,&#34;words&#34;:479,&#34;minutes&#34;:2},&#34;description&#34;:&#34;nuxt分spa和非spa，预渲染直接nuxt generate打好的静态页面放在服务器就能访问(也是服务端渲染)， 服务端渲染需要先build完，把打出来的项目放到服务器，然后允许start，还要配置nginx转发\n使用nuxt的服务端渲...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;docker attach :连接到正在运行中的容器。&lt;br&gt;\n要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。&lt;/p&gt;\n&lt;p&gt;官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了😨&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上--sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。&lt;br&gt;\nrunoob@runoob:~$ docker attach --sig-proxy=false mynginx&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-attach-ming-ling&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;docker attach :连接到正在运行中的容器。&lt;br&gt;\n要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。&lt;/p&gt;\n&lt;p&gt;官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了😨&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Docker attach 命令&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-01-12 15:34:57&#34;,&#34;dateFormat&#34;:&#34;2022-01-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/docker-attach-ming-ling&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:44000,&#34;words&#34;:194,&#34;minutes&#34;:1},&#34;description&#34;:&#34;docker attach :连接到正在运行中的容器。\n要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。\n官方文档中说attach后可以通过CTRL-C来det...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;?&lt;/mo&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;否&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;标&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;志&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;如&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;果&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;则&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;? 是上一个程序执行是否成功的标志，如果执行成功则&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.69444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;?&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;是&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;上&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;一&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;个&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;程&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;序&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;执&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;行&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;是&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;否&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;成&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;功&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;标&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;志&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;，&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;如&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;果&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;执&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;行&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;成&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;功&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;? 为0，否则 不为0。&lt;br&gt;\n比如判断一个node服务是该启动还是该重启，则可以执行pm2 info ***&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1641956978962.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;shell-dollar-huo-qu-han-shu-fan-hui-zhi-huo-zhe-shang-yi-ge-ming-ling-de-tui-chu-zhuang-tai&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;shell $? 获取函数返回值或者上一个命令的退出状态&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-01-12 11:03:58&#34;,&#34;dateFormat&#34;:&#34;2022-01-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/shell-dollar-huo-qu-han-shu-fan-hui-zhi-huo-zhe-shang-yi-ge-ming-ling-de-tui-chu-zhuang-tai&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:20000,&#34;words&#34;:98,&#34;minutes&#34;:1},&#34;description&#34;:&#34;?是上一个程序执行是否成功的标志，如果执行成功则? 是上一个程序执行是否成功的标志，如果执行成功则?是上一个程序执行是否成功的标志，如果执行成功则? 为0，否则 不为0。\n比如判断一个node服务是该启动还是该重启，则可以执行pm2 inf...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;作用：时间戳转化个格式&lt;/p&gt;\n&lt;p&gt;原因：数据库中为了快速查询，一般保持日期是int(1415873634479),但是这样查询的时候很难知道确切的日期&lt;/p&gt;\n&lt;p&gt;格式：select from_unixtime(1459338786);2016-03-30 19:53:06&lt;/p&gt;\n&lt;p&gt;select from_unixtime(1459338786, &#39;%Y-%m-%d %H:%i:%s&#39;);2016-03-30 19:53:06&lt;/p&gt;\n&lt;p&gt;SELECT id ,FROM_UNIXTIME(&#39;last_update_time&#39;) FROM current_inventory WHERE seat_code = &#39;hk2-i0302c03&#39; //字段要加引号&lt;/p&gt;\n&lt;p&gt;备注：默认转化格式是%Y-%m-%d %H:%i:%s&lt;/p&gt;\n&lt;p&gt;格式说明：&lt;/p&gt;\n&lt;p&gt;%M 月名字(January～December)&lt;br&gt;\n%W 星期名字(Sunday～Saturday)&lt;br&gt;\n%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）&lt;br&gt;\n%Y 年, 数字, 4 位&lt;br&gt;\n%y 年, 数字, 2 位&lt;br&gt;\n%a 缩写的星期名字(Sun～Sat)&lt;br&gt;\n%d 月份中的天数, 数字(00～31)&lt;br&gt;\n%e 月份中的天数, 数字(0～31)&lt;br&gt;\n%m 月, 数字(01～12)&lt;br&gt;\n%c 月, 数字(1～12)&lt;br&gt;\n%b 缩写的月份名字(Jan～Dec)&lt;br&gt;\n%j 一年中的天数(001～366)&lt;br&gt;\n%H 小时(00～23)&lt;br&gt;\n%k 小时(0～23)&lt;br&gt;\n%h 小时(01～12)&lt;br&gt;\n%I 小时(01～12)&lt;br&gt;\n%l 小时(1～12)&lt;br&gt;\n%i 分钟, 数字(00～59)&lt;br&gt;\n%r 时间,12 小时(hh:mm:ss [AP]M)&lt;br&gt;\n%T 时间,24 小时(hh:mm:ss)&lt;br&gt;\n%S 秒(00～59)&lt;br&gt;\n%s 秒(00～59)&lt;br&gt;\n%p AM或PM&lt;br&gt;\n%w 一个星期中的天数(0=Sunday ～6=Saturday ）&lt;br&gt;\n%U 星期(0～52), 这里星期天是星期的第一天&lt;br&gt;\n%u 星期(0～52), 这里星期一是星期的第一天&lt;br&gt;\n%% 一个文字%&lt;/p&gt;\n&lt;p&gt;原文链接：https://blog.csdn.net/yangliu4683/article/details/78340939&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;wo-shi-ce-shi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;mysql 时间戳格式化函数from_unixtime&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-04-06 11:01:44&#34;,&#34;dateFormat&#34;:&#34;2021-04-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/wo-shi-ce-shi&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:91000,&#34;words&#34;:341,&#34;minutes&#34;:2},&#34;description&#34;:&#34;作用：时间戳转化个格式\n原因：数据库中为了快速查询，一般保持日期是int(1415873634479),但是这样查询的时候很难知道确切的日期\n格式：select from_unixtime(1459338786);2016-03-30 19...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1640761677993.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&amp;gt; 欢迎来到我的小站呀，很高兴遇见你嘿嘿！🤝&lt;/p&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;h2 id=\&#34;博主是谁\&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;\n&lt;h2 id=\&#34;兴趣爱好\&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&lt;p&gt;https://www.cnblogs.com/lovesong/p/10847433.html&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-25 19:09:48&#34;,&#34;dateFormat&#34;:&#34;2019-01-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/about&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:9000,&#34;words&#34;:42,&#34;minutes&#34;:1},&#34;description&#34;:&#34;&amp;gt; 欢迎来到我的小站呀，很高兴遇见你嘿嘿！🤝\n🏠 关于本站\n👨‍💻 博主是谁\n⛹ 兴趣爱好\n📬 联系我呀\nhttps://www.cnblogs.com/lovesong/p/10847433.html\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E4%B8%BB%E6%98%AF%E8%B0%81\&#34;&gt;👨‍💻 博主是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD\&#34;&gt;⛹ 兴趣爱好&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;强制commit规范常用的有两种，一种是在package项目中的gitHooks选项下的&amp;quot;commit-msg&amp;quot;设置自己的commit规则脚本。比如我要强制commit内容为feat:加空格xxx或者fix:加空格xxx，如果不符合给出相应提示，则我应该这么写：&lt;br&gt;\n&lt;img src=\&#34;https://note.youdao.com/yws/public/resource/d60e09a825bba46e1719f2dc06a2f7e3/xmlnote/302F691AA217499EA4DC783EA5E361B8/3538\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\nverify-commit-msg.js中代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const chalk = require(&amp;quot;chalk&amp;quot;);\nconst msgPath = process.env.GIT_PARAMS;\nconst msg = require(&amp;quot;fs&amp;quot;)\n  .readFileSync(msgPath, &amp;quot;utf-8&amp;quot;)\n  .trim();\n\nconst commitRE = /^(revert: )?(feat|fix|polish|docs|style|refactor|perf|test|workflow|ci|chore|types|build|Merge)(\\(.+\\))?: .{1,50}|Merge /;\n\nif (!commitRE.test(msg)) {\n  console.error(\n    `  ${chalk.bgRed.white(&amp;quot; ERROR &amp;quot;)} ${chalk.red(\n      `invalid commit message format.`\n    )}\\n\\n` +\n      chalk.red(\n        `  Proper commit message format is required for automated changelog generation. Examples:\\n\\n`\n      ) +\n      `    ${chalk.green(`feat: add &#39;comments&#39; option`)}\\n` +\n      `    ${chalk.green(`fix: handle events on blur (close #28)`)}\\n\\n` +\n      chalk.red(\n        `  You can also use ${chalk.cyan(\n          `yarn commit`\n        )} to interactively generate a commit message.\\n`\n      )\n  );\n  process.exit(1);\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;另一种是也可以使用&lt;a href=\&#34;https://www.npmjs.com/package/git-cz/v/4.2.0\&#34;&gt;git-cz&lt;/a&gt; 通过交互的方式生成更专业的commit，效果如下&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642390440510.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;hello-gridea&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;如何自定义commit规范&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;commit规范&#34;,&#34;slug&#34;:&#34;Z8QV8E2Pt&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/Z8QV8E2Pt&#34;}],&#34;date&#34;:&#34;2018-12-12 00:00:00&#34;,&#34;dateFormat&#34;:&#34;2018-12-12&#34;,&#34;feature&#34;:&#34;https://weidadeda.github.io/post-images/hello-gridea.png&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/hello-gridea&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:69000,&#34;words&#34;:229,&#34;minutes&#34;:2},&#34;description&#34;:&#34;强制commit规范常用的有两种，一种是在package项目中的gitHooks选项下的&amp;quot;commit-msg&amp;quot;设置自己的commit规则脚本。比如我要强制commit内容为feat:加空格xxx或者fix:加空格xxx...&#34;,&#34;toc&#34;:&#34;&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/peace.js"></script>



</html>