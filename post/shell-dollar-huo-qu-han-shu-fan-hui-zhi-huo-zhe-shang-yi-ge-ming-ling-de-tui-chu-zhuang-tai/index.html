<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="大伟的静态个人博客">
<meta name="description" content="温故而知新">
<meta name="theme-color" content="#000">
<title>shell $? 获取函数返回值或者上一个命令的退出状态 | 大伟的博客</title>
<link rel="shortcut icon" href="/favicon.ico?v=1649992491046">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



  <meta name="description" content="shell $? 获取函数返回值或者上一个命令的退出状态" />
  <meta name="keywords" content="shell" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>大伟的博客</span>
            </a>  
          
        </div>
        
          <p class="subtitle">保持热爱❤️保持善良✨</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about//" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">王大伟</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>一个前端工程师</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">38</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">23</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">23</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item" style="border-top: 1px dotted #ccc; margin-top: 10px;">
      </div>
    
  
  


</div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://weidadeda.github.io/post/shell-dollar-huo-qu-han-shu-fan-hui-zhi-huo-zhe-shang-yi-ge-ming-ling-de-tui-chu-zhuang-tai">
      shell $? 获取函数返回值或者上一个命令的退出状态
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2021-05-17</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://weidadeda.github.io/tag/qt4i7BiKQ">
        <span>shell</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>1分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>98<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>?</mo><mi mathvariant="normal">是</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">程</mi><mi mathvariant="normal">序</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">志</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">则</mi></mrow><annotation encoding="application/x-tex">? 是上一个程序执行是否成功的标志，如果执行成功则</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mclose">?</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">程</span><span class="mord cjk_fallback">序</span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">功</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">志</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">功</span><span class="mord cjk_fallback">则</span></span></span></span>? 为0，否则 不为0。<br>
比如判断一个node服务是该启动还是该重启，则可以执行pm2 info ***<br>
<img src="https://weidadeda.github.io/post-images/1644843836198.jpg" alt="" loading="lazy"></p>

            </div>
            <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      王大伟
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://weidadeda.github.io/post/shell-dollar-huo-qu-han-shu-fan-hui-zhi-huo-zhe-shang-yi-ge-ming-ling-de-tui-chu-zhuang-tai" title="shell $? 获取函数返回值或者上一个命令的退出状态">https://weidadeda.github.io/post/shell-dollar-huo-qu-han-shu-fan-hui-zhi-huo-zhe-shang-yi-ge-ming-ling-de-tui-chu-zhuang-tai</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://weidadeda.github.io/tag/qt4i7BiKQ"># shell</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Sequelize node连接数据库的ORM" href="https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm">Sequelize node连接数据库的ORM</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Sequelize node连接数据库的ORM" href="https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="docker中使用redis" href="https://weidadeda.github.io/post/docker-zhong-shi-yong-redis">docker中使用redis</a>
        <a class="nav-mobile-next" title="docker中使用redis" href="https://weidadeda.github.io/post/docker-zhong-shi-yong-redis">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '3a4deceed6ea5431a5eb',
    clientSecret: '7ac83272cfb0cb0c210af882e657e38fc771a217',
    repo: 'iorepository',
    owner: 'weidadeda',
    admin: ['weidadeda'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
    
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 0px;bottom: 0px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'histoire'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'Aoba') {
				AIimgSrc.push(message_Path + "model/Aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'Aoba') {
							model = message_Path + "model/Aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/js-zan-shi-xing-si-qu"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;暂时性死区(TDZ)是针对&#39;const&#39;,&#39;let&#39;这两个关键字而产生的概念。&lt;br&gt;
首先变量提升这个js的基本概念无法撼动，&#39;const&#39;和&#39;let&#39;作为块级作用域也不能避免。&lt;br&gt;
和&#39;var&#39;不同，这两个关键字将作用域限制在了‘块’中，且规定了在该块中，由这两个关键字定义的变量已经被分配内存。&lt;br&gt;
即其实已经&#39;存在&#39;了，但程序未执行到声明处时，访问该变量都会报引用错误。&lt;br&gt;
这个时候，对于该变量来说就是&#39;暂时性死区&#39;，通俗来说就是该变量存在，但并未完全存在&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (true) {
  // TDZ开始
  tmp = &#39;abc&#39;; // ReferenceError
  console.log(tmp); // ReferenceError


  let tmp; // TDZ结束
  console.log(tmp); // undefined


  tmp = 123;
  console.log(tmp); // 123
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var tmp = 123;
if (true) {
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。&lt;/p&gt;
&lt;p&gt;ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 不报错
var x = x;
// 报错
let x = x;
// ReferenceError: x is not defined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“&lt;/p&gt;
&lt;p&gt;本文转载自https://blog.csdn.net/zzzzz111333/article/details/122562000&lt;/p&gt;
">js暂时性死区</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/li-yong-imagedata-shi-xian-tu-pian-fan-zhuan-he-shi-pin-jing-xiang"" data-c="
          &lt;pre&gt;&lt;code&gt;最近在搞视频直播，其中有一个功能是视频镜像，那么有两种实现方式。
- 一种是老师端点击镜像，通过css把自己的video标签镜像，然后发送信令给学生端，学生端收到消息之后也通过css去实现镜像
- 第二种就是老师端对视频流做一个镜像处理，学生端无需操作，很显然第二种方法比较好

怎么实现对视频流的镜像呢，首先要知道的就是视频是由一帧帧的图片组合而成，我们要对视频流镜像，首先要对图片进行镜像。

对图片镜像的话，就要对ImageData做处理
首先了解一下什么是ImageData：
&amp;gt; ImageData 接口描述 canvas 元素的一个隐含像素数据的区域。使用 ImageData() 构造函数创建或者使用和 canvas 在一起的 CanvasRenderingContext2D 对象的创建方法： createImageData() 和 getImageData()。也可以使用 putImageData() 设置 canvas 的一部分。

## 我们先以旋转图片为例子做个说明
### 基本原理1——像素矩阵变换
ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：

- width  图片宽度，单位是像素
- height  图片高度，单位是像素
- data  [Uint8ClampedArray](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray)类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。
data属性返回一个 Uint8ClampedArray，它可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是&amp;quot;RGBA&amp;quot;格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。

具体请看[像素操作](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas)

我们通过ImageData可以对图片的每个像素点做操作。比如我们现在要将图片向右旋转90度

一个 4 × 3 像素的原始图片，可以看作如下形式的像素矩阵 A：
![](https://weidadeda.github.io/post-images/1647858122464.png)
图片向右旋转 90°，实质就是设法将 A 变为 A’ ——
![](https://weidadeda.github.io/post-images/1647858132107.png)
这可以通过原矩阵一次 转置、与多次初等 列 变换（逆序排列各列）得到：
![](https://weidadeda.github.io/post-images/1647858162556.png)
同理，图片向左旋转 90°，实际上就是得到矩阵 A’&#39; ：
![](https://weidadeda.github.io/post-images/1647858170777.png)
这可以通过原矩阵一次 转置、与多次初等 行 变换（逆序排列各行）得到——
![](https://weidadeda.github.io/post-images/1647858177575.png)
### 基本原理2——像素数组与矩阵的对应关系
由于 ImageData.data 对应一个数组，对于 4 × 3 的图片而言，ImageData.data 就是一个具有 48 个元素的数组 D，不妨每个元素的值就是其下标值，则：
```js
D=[0,1,2,3,4,5,6,7...44,45,46,47]
```

其中：
元组 (0, 1, 2, 3) 表示第 1(= 0 / 4 + 1) 个像素的颜色为 rgba(0, 1, 2, 3/255)；
元组 (4, 5, 6, 7) 表示第 2(= 4 / 4 + 1) 个像素的颜色为 rgba(4, 5, 6, 7/255)；
元组 (8, 9, 10, 11) 表示第 3(= 8 / 4 + 1) 个像素的颜色为 rgba(8, 9, 10, 11/255)；
…

元组 (i, i+1, i+2, i+3) 表示第 (i / 4 + 1) 个像素的颜色为 rgba(i, i+1, i+2, (i+3)/255)；
…
元组 (44, 45, 46, 47) 表示第 12(= 44 / 4 + 1) 个像素的颜色为 rgba(44, 45, 46, 47/255)。

可见从 0 开始遍历 D 数组，每次递增 4 个单位，即可依次得到各个像素的红色值 R，再依次加1、加2、加3，即得到对应的绿色值 G、蓝色值 B、等效 α 通道值 A。

反之，如果知道图片的像素尺寸为 4 × 3，则可以通过下图找到数组 D 的各个元素：
![](https://weidadeda.github.io/post-images/1647858189293.png)

可见各像素点是按照 从左至右、从上至下 的顺序排列的。设图片总宽度像素为 W，总高度像素为 H，任一像素点 P 的坐标为 (x, y)，P 的红色值在数组 D 的下标为 R(x, y)，则：
```js
R(x,y)=(x+W*y)×4
```
验证：（x 与 y 均从 0 开始计数）

R(2, 1) = (2 + 1 × 4) × 4 = 24
R(1, 2) = (1 + 2 × 4) × 4 = 36
R(3, 1) = (3 + 1 × 4) × 4 = 28

拿到了 R(x, y)，不难求出该像素的纵向中心对称像素 Rh(x, y)、横向中心对称像素 Rw(x, y)、以及主对角线对称像素 Rd(x, y)：
```js
Rh(x,y)=[x+W*(H−1−y)]*4 // 初等行变换
Rw(x,y)=[(W−1−x)+W*y]*4 // 初等列变换
Rd(x,y)=(y+H*x)*4
```

### 具体实现

基本思路：

- 通过 canvas 获取目标图片的 ImageData 对象；
- 转置原图片数组，得到数组 AT；
- 对 AT 执行一组初等行变换，使各行逆序排列，得到左旋 90° 效果；
- 对 AT 执行一组初等列变换，使各列逆序排列，得到右旋 90° 效果；
- 将新的像素数组写回图片源标签。

HTML：
```html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Rotate by ImageData&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        .image{ margin-top: 5px; }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;btns&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;左转 90°&amp;quot; id=&amp;quot;turnLeft&amp;quot; /&amp;gt;
        &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;右转 90°&amp;quot; id=&amp;quot;turnRight&amp;quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;image&amp;quot;&amp;gt;
        &amp;lt;img id=&amp;quot;fruit&amp;quot; src=&amp;quot;fruit.jpg&amp;quot; class=&amp;quot;image&amp;quot; alt=&amp;quot;fruit&amp;quot; title=&amp;quot;fruit&amp;quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&amp;quot;imageRotate.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
```
imageRotate.js：
```js
document.querySelector(&#39;#turnLeft&#39; ).addEventListener(&#39;click&#39;, e =&amp;gt; rotateImage(&#39;l&#39;))
document.querySelector(&#39;#turnRight&#39;).addEventListener(&#39;click&#39;, e =&amp;gt; rotateImage(&#39;r&#39;))

function rotateImage(direction = &#39;l&#39;) {
    // 1. Prepare ImageData
    let img = document.querySelector(&#39;#fruit&#39;)
    const { width: W, height: H } = img
    let cvs = document.createElement(&#39;canvas&#39;)
    cvs.width = W
    cvs.height = H
    let ctx = cvs.getContext(&#39;2d&#39;)
    ctx.drawImage(img, 0, 0)
    let imgDt0 = ctx.getImageData(0, 0, W, H)
    let imgDt1 = new ImageData(H, W)
    let imgDt2 = new ImageData(H, W)
    let dt0 = imgDt0.data
    let dt1 = imgDt1.data
    let dt2 = imgDt2.data

    // 2. Transpose
    let r = r1 = 0  // index of red pixel in old and new ImageData, respectively
    for (let y = 0, lenH = H; y &amp;lt; lenH; y++) {
        for (let x = 0, lenW = W; x &amp;lt; lenW; x++) {
            r  = (x + lenW * y) * 4
            r1 = (y + lenH * x) * 4
            dt1[r1 + 0] = dt0[r + 0]
            dt1[r1 + 1] = dt0[r + 1]
            dt1[r1 + 2] = dt0[r + 2]
            dt1[r1 + 3] = dt0[r + 3]
        }
    }
    
    // 3. Reverse width / height
    for (let y = 0, lenH = W; y &amp;lt; lenH; y++) {
        for (let x = 0, lenW = H; x &amp;lt; lenW; x++) {
            r  = (x + lenW * y) * 4
            r1 = direction === &#39;l&#39;
                ? (x + lenW * (lenH - 1 - y)) * 4
                : ((lenW - 1 - x) + lenW * y) * 4
            dt2[r1 + 0] = dt1[r + 0]
            dt2[r1 + 1] = dt1[r + 1]
            dt2[r1 + 2] = dt1[r + 2]
            dt2[r1 + 3] = dt1[r + 3]
        }
    }
    
    // 4. Redraw image
    cvs.width = H
    cvs.height = W
    ctx.clearRect(0, 0, W, H)
    ctx.putImageData(imgDt2, 0, 0, 0, 0, H, W)
    img.src = cvs.toDataURL(&#39;image/jpeg&#39;, 1)
}
```

运行结果：
原始图片
![](https://weidadeda.github.io/post-images/1647858200595.png)
左转90度
![](https://weidadeda.github.io/post-images/1647858207477.png)
右转90度
![](https://weidadeda.github.io/post-images/1647858214763.png)

好了，现在实现了图片旋转，那么我们接着套用公式实现图片镜像和视频镜像

html
```html
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot; /&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;js通过浏览器调用摄像头&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
    #video {
        /* transform: rotate3d(1, 1, 1, 45deg); */
    }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;
    &amp;lt;video id=&amp;quot;video&amp;quot; width=&amp;quot;500px&amp;quot; height=&amp;quot;500px&amp;quot; autoplay=&amp;quot;autoplay&amp;quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;canvas width=&amp;quot;500&amp;quot; height=&amp;quot;500&amp;quot; id=&amp;quot;canvas&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
    &amp;lt;video
    id=&amp;quot;video2&amp;quot;
    width=&amp;quot;500px&amp;quot;
    height=&amp;quot;500px&amp;quot;
    autoplay=&amp;quot;autoplay&amp;quot;
    controls=&amp;quot;controls&amp;quot;
    /&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;!-- &amp;lt;script src=&amp;quot;./test.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
&amp;lt;script&amp;gt;
    function getMedia() {
    let video = document.getElementById(&amp;quot;video&amp;quot;);
    let constraints = {
        video: { width: 500, height: 500 },
        audio: false,
    };
    navigator.getUserMedia =
        navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.msGetUserMedia;
    let promise = navigator.mediaDevices.getUserMedia(
        constraints,
        function (stream) {
        video.src = stream;
        video.play();
        },
        function (error) {
        console.log(error);
        }
    );
    promise.then(function (MediaStream) {
        video.srcObject = MediaStream;
        video.play();
    });
    }

    getMedia();
    window.onload = () =&amp;gt; {
    const data = [];
    var recorder;
    // 获取视频流之后，用canvas对视频进行反转，然后使用captureStream获取视频流，此时可以通过声网自定义流获取视频轨道getVideoTracks。代码中为了测试canvas转视频可用，调用了MediaRecorder录制
    function imageDataHRevert(sourceData, newData) {
        for (var i = 0, h = sourceData.height; i &amp;lt; h; i++) {
        for (j = 0, w = sourceData.width; j &amp;lt; w; j++) {
            newData.data[i * w * 4 + j * 4 + 0] =
            // (y*W+x)*4
            sourceData.data[i * w * 4 + (w - j) * 4  -4+ 0];
            // (y*W+(W-x-1))*4
            newData.data[i * w * 4 + j * 4 + 1] =
            sourceData.data[i * w * 4 + (w - j) * 4 -4+ 1];

            newData.data[i * w * 4 + j * 4 + 2] =
            sourceData.data[i * w * 4 + (w - j) * 4 -4+ 2];

            newData.data[i * w * 4 + j * 4 + 3] =
            sourceData.data[i * w * 4 + (w - j) * 4-4 + 3];
        }
        }
        return newData;
    }
    function imageDataVRevert(sourceData, newData) {
        for (var i = 0, h = sourceData.height; i &amp;lt; h; i++) {
        for (var j = 0, w = sourceData.width; j &amp;lt; w; j++) {
            newData.data[i * w * 4 + j * 4 + 0] =
            sourceData.data[(h - i) * w * 4 + j * 4 + 0];

            newData.data[i * w * 4 + j * 4 + 1] =
            sourceData.data[(h - i) * w * 4 + j * 4 + 1];

            newData.data[i * w * 4 + j * 4 + 2] =
            sourceData.data[(h - i) * w * 4 + j * 4 + 2];

            newData.data[i * w * 4 + j * 4 + 3] =
            sourceData.data[(h - i) * w * 4 + j * 4 + 3];
        }
        }

        return newData;
    }

    function render() {
        var canvas = document.getElementById(&amp;quot;canvas&amp;quot;);
        var video = document.getElementById(&amp;quot;video&amp;quot;);
        var ctx1 = canvas.getContext(&amp;quot;2d&amp;quot;);
        ctx1.drawImage(video, 0, 0, 500, 500);
        var imgData = ctx1.getImageData(0, 0, 500, 500);
        var newImgData = ctx1.getImageData(0, 0, 500, 500);
        const HRevet = imageDataHRevert(newImgData, imgData);
        console.error(HRevet, &amp;quot;HRevet&amp;quot;);
        // 亮一点
        for (var i = 0; i &amp;lt; HRevet.data.length; i += 4) {
        HRevet.data[i] += 5;
        HRevet.data[i + 1] += 5;
        HRevet.data[i + 2] += 5;
        }
        ctx1.putImageData(HRevet, 0, 0);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
    const stream = canvas.captureStream(30);
    // todo 自定义视频 canvas.captureStream(30).getVideoTracks()[0]
    console.error(stream, &amp;quot;stream&amp;quot;);
    // 自己测试录制视频的，可以不用看
    recorder = new MediaRecorder(stream, { mimeType: &amp;quot;video/webm&amp;quot; });
    recorder.ondataavailable = function (event) {
        if (event.data &amp;amp;&amp;amp; event.data.size) {
        data.push(event.data);
        }
    };
    recorder.onstop = () =&amp;gt; {
        const url = URL.createObjectURL(new Blob(data, { type: &amp;quot;video/webm&amp;quot; }));
        document.getElementById(&amp;quot;video2&amp;quot;).src = url;
    };
    recorder.start();
    setTimeout(() =&amp;gt; {
        recorder.stop();
    }, 6000);
    };
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
```
结果：
![](https://weidadeda.github.io/post-images/1647859629847.png)
&amp;lt;!-- more --&amp;gt;

#### 大家看的可能有点懵，没关系，拿个纸画一下，然后去套用公式就好了，一次不懂就多试几次。看不懂一定要拿张纸画一下！

简单的增加美白效果（亮度），可给每个rgb通道加特定值。
```js
r1 = (x + W * y) * 4;
r1 = (x + W * (H - 1 - y)) * 4;
```
推荐一个美颜库：opencvjs  
推荐一个人脸识别库：face-api.js https://www.cnblogs.com/neozhu/p/11771148.html

部分内容参考自 https://blog.csdn.net/frgod/article/details/106055830
&lt;/code&gt;&lt;/pre&gt;
">利用 ImageData 实现图片翻转和视频镜像</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/taro-jie-jue-xiao-cheng-xu-bao-ti-ji-guo-da-de-wen-ti"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1646137679298.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;目前小程序分包大小有以下限制：&lt;br&gt;
整个小程序所有分包大小不超过 8M&lt;br&gt;
单个分包/主包大小不能超过 2M&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以说8M的限制是要分包至少4个包，单个分包上限其实还是2M&lt;/p&gt;
&lt;h3 id=&#34;解决这个问题一种是分包&#34;&gt;解决这个问题一种是分包&lt;/h3&gt;
&lt;p&gt;官方给出的分包&lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html&#34;&gt;官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;另一种是减少包中的图片&#34;&gt;另一种是减少包中的图片&lt;/h3&gt;
&lt;p&gt;其实造成包体积过大的因素，很大原因是因为包里有图片，那体积就会变得很大。那我们可以将图片上传到CDN上，变成网络链接，这样的话就不会把图片打包进去了。但是这样又有一个不足，比如说我们一开始开发项目的时候，UI同学给了我们设计图，那我们要将图片一张张的上传到CDN上去吗？如果后期UI走查的时候要换图片呢？而且万一CDN上的图片被人误删了或者服务到期了呢（当然这种可能性很小，但也可以考虑进去），这时候我们的原图都会找不到，只能干着急。。。&lt;/p&gt;
&lt;h4 id=&#34;那么最好的方式就是将图片放在项目中本地开发的时候引用的就是本地的增删改找起来也方便但是打包构建的时候将图片压缩并上传cdn同时将项目中的图片引用路径改成网络链接然后删除dist中的所有图片-那么接下来我们就写个脚本实现一下&#34;&gt;那么最好的方式就是将图片放在项目中，本地开发的时候引用的就是本地的，增删改找起来也方便，但是打包构建的时候将图片压缩并上传CDN，同时将项目中的图片引用路径改成网络链接，然后删除dist中的所有图片。那么接下来我们就写个脚本实现一下。&lt;/h4&gt;
&lt;p&gt;直接上代码吧&lt;/p&gt;
&lt;h4 id=&#34;先写上传方法用于打包完上传先压缩再上传到阿里oss&#34;&gt;先写上传方法，用于打包完上传，先压缩再上传到阿里oss&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// config/upload.js
const OSS = require(&amp;quot;ali-oss&amp;quot;);
const fs = require(&amp;quot;fs&amp;quot;);
const path = require(&amp;quot;path&amp;quot;);
const rimraf = require(&amp;quot;rimraf&amp;quot;);
const imagemin = require(&#39;imagemin&#39;)
const imageminJpegtran = require(&#39;imagemin-jpegtran&#39;)
const imageminPngquant = require(&#39;imagemin-pngquant&#39;)
const imageminSvgo = require(&#39;imagemin-svgo&#39;)
const imageminGifsicle = require(&#39;imagemin-gifsicle&#39;)

const client = new OSS({
  region: &amp;quot;&amp;quot;,
  endpoint: &amp;quot;&amp;quot;,
  accessKeyId: &amp;quot;&amp;quot;,
  accessKeySecret: &amp;quot;&amp;quot;,
  bucket: &amp;quot;&amp;quot;
});
async function compress() {
  const files = await imagemin([&#39;../dist/**/*.{jpg,jpeg,png,svg,gif}&#39;], {
    destination: &#39;../dist/assets&#39;,
    plugins: [
      imageminJpegtran({
        progressive: true,
        quality: 80,
      }),
      imageminPngquant({
        quality: [0.6, 0.8],
      }),
      imageminSvgo({
        plugins: [{ removeViewBox: false }],
      }),
      imageminGifsicle(),
    ],
  })
  console.log(&#39;compress all images success!&#39;.info)
  return files
}
const putOSS = async function(src, dist) {
  try {
    let result = await client.put(dist, src);
    console.log(&amp;quot;oss上传成功: &amp;quot; + result.name);
  } catch (e) {
    console.log(e);
  }
};

const workList = [];

/**
 *
 * @param {string} src 需要上传的文件夹
 * @param {string} dist oss文件夹
 */

const addFileToOSSSync = function(src, dist) {
  try {
    await compress()
    var docs = fs.readdirSync(src);
  } catch (error) {
    console.log(src + &amp;quot;不存在&amp;quot;);
    return;
  }

  docs.forEach(function(doc) {
    const _src = src + &amp;quot;/&amp;quot; + doc;
    const _dist = dist + &amp;quot;/&amp;quot; + doc;
    const st = fs.statSync(_src);
    // 判断是否为文件
    if (st.isFile() &amp;amp;&amp;amp; doc !== &amp;quot;.DS_Store&amp;quot;) {
      workList.push(putOSS(_src, _dist));
      // console.log(_src + &#39;是文件&#39;, _dist);
    } else if (st.isDirectory()) {
      addFileToOSSSync(_src, _dist);
    }
  });
};

addFileToOSSSync(&amp;quot;dist/assets&amp;quot;, &amp;quot;weixin/gongyi/sdg/images&amp;quot;);

Promise.all(workList).then(res =&amp;gt; {
  rimraf(path.join(__dirname, &amp;quot;../dist/assets&amp;quot;), error =&amp;gt; {
    if (error) {
      throw error;
    }
    console.log(&amp;quot;done!&amp;quot;);
  });
});

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;上传方法写完了什么时候调用呢应该在构建完之后调用因为上传完要删除包中dist下的图片那么我们应该packagejson中更改命令&#34;&gt;上传方法写完了，什么时候调用呢，应该在构建完之后调用，因为上传完要删除包中dist下的图片，那么我们应该package.json中更改命令&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// package.json
&amp;quot;build:weapp&amp;quot;: &amp;quot;NODE_ENV=online taro build --type weapp &amp;amp;&amp;amp; node config/upload.js&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;还有设置一个全局变量&#34;&gt;还有设置一个全局变量&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// Taro打包入口处
const ossPath = &#39;你的cdn域名&#39;
let projectPublicPath = &#39;/&#39;

if (process.env.NODE_ENV !== &#39;development&#39;) {
  // 你上传的cdn路径
  projectPublicPath = `${ossPath}/1v1mp/${process.env.TARO_ENV}/${process.env.NODE_ENV}`
}

let assetsPre =
  process.env.TARO_ENV === &#39;weapp&#39;
    ? process.env.NODE_ENV === &#39;development&#39;
      ? &#39;&#39;
      : projectPublicPath
    : &#39;&#39;
var config = {
  // ...其他配置正常写，主要是注意这两项
  alias: {
    &#39;@&#39;: path.resolve(__dirname, &#39;..&#39;, &#39;src&#39;),
  },
  defineConstants: {
    assetsPre: `&amp;quot;${assetsPre}&amp;quot;`,
  },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;最后使用需要注意&#34;&gt;最后使用需要注意：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有图片文件放入&lt;code&gt;src/assets&lt;/code&gt;目录下，可以在&lt;code&gt;assets&lt;/code&gt;目录下创建各模块目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;import&lt;/code&gt; 引入后在&lt;code&gt;src&lt;/code&gt;处使用 &lt;code&gt;${assetsPre}${pic}&lt;/code&gt;的方式使用, &lt;code&gt;assetsPre&lt;/code&gt;是全局定义好的常量，可以直接使用。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;import pic from &#39;@/assets/defualt.jpg&#39;

export default function Index() {
  // do some logic

  return &amp;lt;Image src={`${assetsPre}${pic}`} /&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;tip: 有一点要说一下，虽然import引入了，但其实是个pic是个路径，webpack5以前会把它通过loader转为路径，webpack5通过内置Asset Modules转为路径。具体文档可见：&lt;a href=&#34;https://webpack.docschina.org/guides/asset-management/#loading-images&#34;&gt;加载images图像&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">Taro解决小程序包体积过大的问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/createjs-chuang-jian-tu-pian-wei-tu-bing-she-zhi-zhong-xin-dian-wei-tu-pian-zhong-xin"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;public static createBitmap(imgUrl: string): Promise&amp;lt;any&amp;gt; {
    return new Promise&amp;lt;object | number&amp;gt;((resolve, reject) =&amp;gt; {
      const image: any = new Image()
      image.src = imgUrl || &#39;&#39;
      image.onload = () =&amp;gt; {
        const Bitmap = new createjs.Bitmap(image)
        const { width, height } = Bitmap.image
        // Bitmap.setBounds(0, 0, width, height);
        Bitmap.regX = width / 2
        Bitmap.regY = height / 2
        resolve(Bitmap)
      }
      image.onerror = (error: any) =&amp;gt; {
        console.warn(`&amp;quot;image load fail&amp;quot;${imgUrl}`, error)
      }
    })
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;注意默认注册中心点旋转时围绕的点是在左上角regxregy并不是改变注册中心点而是向左上方向偏移宽高的一半但只是偏移物体这个物体的注册中心点是不变的-想改变注册中心点只能靠xy来设置位置注册中心点永远都在左上角但通过regxregy可以把物体本身往反方向平移一半但注册中心点还在之前的位置这样的话我们的旋转位置看起来就是围着中间点旋转了-这么说大家可能有点懵没关系这里确实有点难理解~有个博客写的很好大家可以结合我总结的看一下&#34;&gt;注意：默认注册中心点（旋转时围绕的点）是在左上角，regX，regY并不是改变注册中心点，而是向左上方向偏移宽高的一半，但只是偏移物体，这个物体的注册中心点是不变的。想改变注册中心点，只能靠x,y来设置位置，注册中心点永远都在左上角，但通过regX，regY可以把物体本身往反方向平移一半（但注册中心点还在之前的位置），这样的话，我们的旋转位置看起来就是围着中间点旋转了。这么说大家可能有点懵，没关系，这里确实有点难理解～有个博客写的很好，大家可以结合我总结的看一下：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000016445744&#34;&gt;Easeljs之regX/regY详解&lt;/a&gt;&lt;/p&gt;
">createjs 创建图片位图并设置中心点为图片中心</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/vite-zi-ding-yi-cha-jian"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://vitejs.cn/guide/api-plugin.html&#34;&gt;vite官网自定义插件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vite 插件扩展了设计出色的 Rollup 接口，带有一些 Vite 独有的配置项。因为vite是使用rollup打包的所以最好你能了解&lt;a href=&#34;https://rollupjs.org/guide/en/#plugin-development&#34;&gt;Rollup 插件文档&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面的都是按照官网介绍写的，因为毕竟你看到我这了，直接给你个链接再让你跳转到官网去看有点不负责任，如果你已经从官网看过了，并且对自定义插件很熟悉了，那么请直接到最下面看 &lt;a href=&#34;#test&#34;&gt;项目实战部分&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;约定&#34;&gt;约定&lt;/h3&gt;
&lt;p&gt;如果插件不使用 Vite 特有的钩子，可以作为 &lt;a href=&#34;https://vitejs.cn/guide/api-plugin.html#rollup-plugin-compatibility&#34;&gt;兼容 Rollup 的插件&lt;/a&gt; 来实现，推荐使用 &lt;a href=&#34;https://rollupjs.org/guide/en/#conventions&#34;&gt;Rollup 插件名称约定&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rollup 插件应该有一个带 rollup-plugin- 前缀、语义清晰的名称。&lt;/li&gt;
&lt;li&gt;在 package.json 中包含 rollup-plugin 和 vite-plugin 关键字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，插件也可以用于纯 Rollup 或基于 WMR 的项目。&lt;/p&gt;
&lt;p&gt;对于 Vite 专属的插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vite 插件应该有一个带 vite-plugin- 前缀、语义清晰的名称。&lt;/li&gt;
&lt;li&gt;在 package.json 中包含 vite-plugin 关键字。&lt;/li&gt;
&lt;li&gt;在插件文档增加一部分关于为什么本插件是一个 Vite 专属插件的详细说明（如，本插件使用了 Vite 特有的插件钩子）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你的插件只适用于特定的框架，它的名字应该遵循以下前缀格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vite-plugin-vue- 前缀作为 Vue 插件&lt;/li&gt;
&lt;li&gt;vite-plugin-react- 前缀作为 React 插件&lt;/li&gt;
&lt;li&gt;vite-plugin-svelte- 前缀作为 Svelte 插件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插件配置&#34;&gt;插件配置&lt;/h3&gt;
&lt;p&gt;用户会将插件添加到项目的 devDependencies 中并使用数组形式的 plugins 选项配置它们。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// vite.config.js
import vitePlugin from &#39;vite-plugin-feature&#39;
import rollupPlugin from &#39;rollup-plugin-feature&#39;

export default defineConfig({
  plugins: [vitePlugin(), rollupPlugin()]
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假值的插件将被忽略，可以用来轻松地启用或停用插件。&lt;/p&gt;
&lt;p&gt;plugins 也可以接受将多个插件作为单个元素的预设。这对于使用多个插件实现的复杂特性（如框架集成）很有用。该数组将在内部被扁平化（flatten）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 框架插件
import frameworkRefresh from &#39;vite-plugin-framework-refresh&#39;
import frameworkDevtools from &#39;vite-plugin-framework-devtools&#39;

export default function framework(config) {
  return [frameworkRefresh(config), frameworkDevTools(config)]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// vite.config.js
import { defineConfig } from &#39;vite&#39;
import framework from &#39;vite-plugin-framework&#39;

export default defineConfig({
  plugins: [framework()]
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;简单示例&#34;&gt;简单示例&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;TIP&lt;br&gt;
通常的惯例是创建一个 Vite/Rollup 插件作为一个返回实际插件对象的工厂函数。该函数可以接受允许用户自定义插件行为的选项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;转换自定义文件类型&#34;&gt;转换自定义文件类型&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fileRegex = /\.(my-file-ext)$/

export default function myPlugin() {
  return {
    name: &#39;transform-file&#39;,

    transform(src, id) {
      if (fileRegex.test(id)) {
        return {
          code: compileFileToJS(src),
          map: null // 如果可行将提供 source map
        }
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通用钩子&#34;&gt;通用钩子&lt;/h3&gt;
&lt;p&gt;在开发中，Vite 开发服务器会创建一个插件容器来调用 &lt;a href=&#34;https://rollupjs.org/guide/en/#build-hooks&#34;&gt;Rollup 构建钩子&lt;/a&gt;，与 Rollup 如出一辙。&lt;/p&gt;
&lt;p&gt;以下钩子在服务器启动时被调用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;options&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;buildStart&lt;br&gt;
以下钩子会在每个传入模块请求时被调用：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;resolveId&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;load&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;transform&lt;br&gt;
以下钩子在服务器关闭时被调用：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;buildEnd&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;closeBundle&lt;br&gt;
请注意 moduleParsed 钩子在开发中是 不会 被调用的，因为 Vite 为了性能会避免完整的 AST 解析。&lt;br&gt;
Output Generation Hooks（除了 closeBundle) 在开发中是 不会 被调用的。你可以认为 Vite 的开发服务器只调用了 rollup.rollup() 而没有调用 bundle.generate()。&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1645006280268.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vite-独有钩子&#34;&gt;Vite 独有钩子&lt;/h3&gt;
&lt;p&gt;Vite 插件也可以提供钩子来服务于特定的 Vite 目标。这些钩子会被 Rollup 忽略。&lt;/p&gt;
&lt;h4 id=&#34;config&#34;&gt;config&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型： (config: UserConfig, env: { mode: string, command: string }) =&amp;gt; UserConfig | null | void&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;种类： async, sequential&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在解析 Vite 配置前调用。钩子接收原始用户配置（命令行选项指定的会与配置文件合并）和一个描述配置环境的变量，包含正在使用的 mode 和 command。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置（如果默认的合并不能达到预期的结果）。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 返回部分配置（推荐）
const partialConfigPlugin = () =&amp;gt; ({
  name: &#39;return-partial&#39;,
  config: () =&amp;gt; ({
    alias: {
      foo: &#39;bar&#39;
    }
  })
})

// 直接改变配置（应仅在合并不起作用时使用）
const mutateConfigPlugin = () =&amp;gt; ({
  name: &#39;mutate-config&#39;,
  config(config, { command }) {
    if (command === &#39;build&#39;) {
      config.root = __dirname
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意&lt;br&gt;
用户插件在运行这个钩子之前会被解析，因此在 config 钩子中注入其他插件不会有任何效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;configresolved&#34;&gt;configResolved&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型： (config: ResolvedConfig) =&amp;gt; void | Promise&lt;void&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;种类： async, parallel&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在解析 Vite 配置后调用。使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const exmaplePlugin = () =&amp;gt; {
  let config

  return {
    name: &#39;read-config&#39;,

    configResolved(resolvedConfig) {
      // 存储最终解析的配置
      config = resolvedConfig
    },

    // 在其他钩子中使用存储的配置
    transform(code, id) {
      if (config.command === &#39;serve&#39;) {
        // dev: 由开发服务器调用的插件
      } else {
        // build: 由 Rollup 调用的插件
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，在开发环境下，command 的值为 serve（在 CLI 中，vite 和 vite dev 是 vite serve 的别名）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;configureserver&#34;&gt;configureServer&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型： (server: ViteDevServer) =&amp;gt; (() =&amp;gt; void) | void | Promise&amp;lt;(() =&amp;gt; void) | void&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;种类： async, sequential&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此外请看 &lt;a href=&#34;https://vitejs.cn/guide/api-javascript.html#vitedevserver&#34;&gt;ViteDevServer&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是用于配置开发服务器的钩子。最常见的用例是在内部 connect 应用程序中添加自定义中间件:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const myPlugin = () =&amp;gt; ({
  name: &#39;configure-server&#39;,
  configureServer(server) {
    server.middlewares.use((req, res, next) =&amp;gt; {
      // 自定义请求处理...
    })
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注入后置中间件&lt;/p&gt;
&lt;p&gt;configureServer 钩子将在内部中间件被安装前调用，所以自定义的中间件将会默认会比内部中间件早运行。如果你想注入一个在内部中间件 之后 运行的中间件，你可以从 configureServer 返回一个函数，将会在内部中间件安装后被调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const myPlugin = () =&amp;gt; ({
  name: &#39;configure-server&#39;,
  configureServer(server) {
    // 返回一个在内部中间件安装后
    // 被调用的后置钩子
    return () =&amp;gt; {
      server.middlewares.use((req, res, next) =&amp;gt; {
        // 自定义请求处理...
      })
    }
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;存储服务器访问&lt;/p&gt;
&lt;p&gt;在某些情况下，其他插件钩子可能需要访问开发服务器实例（例如访问 websocket 服务器、文件系统监视程序或模块图）。这个钩子也可以用来存储服务器实例以供其他钩子访问:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const myPlugin = () =&amp;gt; {
  let server
  return {
    name: &#39;configure-server&#39;,
    configureServer(_server) {
      server = _server
    },
    transform(code, id) {
      if (server) {
        // 使用 server...
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意 configureServer 在运行生产版本时不会被调用，所以其他钩子需要防范它缺失。&lt;/p&gt;
&lt;h4 id=&#34;transformindexhtml&#34;&gt;transformIndexHtml&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型： IndexHtmlTransformHook | { enforce?: &#39;pre&#39; | &#39;post&#39;, transform: IndexHtmlTransformHook }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;种类： async, sequential&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文。上下文在开发期间暴露ViteDevServer实例，在构建期间暴露 Rollup 输出的包。&lt;br&gt;
这个钩子可以是异步的，并且可以返回以下其中之一:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经过转换的 HTML 字符串&lt;/li&gt;
&lt;li&gt;注入到现有 HTML 中的标签描述符对象数组（{ tag, attrs, children }）。每个标签也可以指定它应该被注入到哪里（默认是在 &lt;head&gt; 之前）&lt;/li&gt;
&lt;li&gt;一个包含 { html, tags } 的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基础示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const htmlPlugin = () =&amp;gt; {
  return {
    name: &#39;html-transform&#39;,
    transformIndexHtml(html) {
      return html.replace(
        /&amp;lt;title&amp;gt;(.*?)&amp;lt;\/title&amp;gt;/,
        `&amp;lt;title&amp;gt;Title replaced!&amp;lt;/title&amp;gt;`
      )
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;handlehotupdate&#34;&gt;handleHotUpdate&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;类型： (ctx: HmrContext) =&amp;gt; Array&lt;ModuleNode&gt; | void | Promise&amp;lt;Array&lt;ModuleNode&gt; | void&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行自定义 HMR 更新处理。钩子接收一个带有以下签名的上下文对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;interface HmrContext {
  file: string
  timestamp: number
  modules: Array&amp;lt;ModuleNode&amp;gt;
  read: () =&amp;gt; string | Promise&amp;lt;string&amp;gt;
  server: ViteDevServer
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;modules 是受更改文件影响的模块数组。它是一个数组，因为单个文件可能映射到多个服务模块（例如 Vue 单文件组件）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;read 这是一个异步读函数，它返回文件的内容。之所以这样做，是因为在某些系统上，文件更改的回调函数可能会在编辑器完成文件更新之前过快地触发，并 fs.readFile 直接会返回空内容。传入的 read 函数规范了这种行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;钩子可以选择:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;过滤和缩小受影响的模块列表，使 HMR 更准确。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回一个空数组，并通过向客户端发送自定义事件来执行完整的自定义 HMR 处理:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;handleHotUpdate({ server }) {
  server.ws.send({
    type: &#39;custom&#39;,
    event: &#39;special-update&#39;,
    data: {}
  })
  return []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;客户端代码应该使用 &lt;a href=&#34;https://vitejs.cn/guide/api-hmr.html&#34;&gt;HMR API&lt;/a&gt; 注册相应的处理器（这应该被相同插件的 transform 钩子注入）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if (import.meta.hot) {
  import.meta.hot.on(&#39;special-update&#39;, (data) =&amp;gt; {
    // 执行自定义更新
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;插件顺序&#34;&gt;插件顺序&lt;/h3&gt;
&lt;p&gt;一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。解析后的插件将按照以下顺序排列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alias&lt;/li&gt;
&lt;li&gt;带有 enforce: &#39;pre&#39; 的用户插件&lt;/li&gt;
&lt;li&gt;Vite 核心插件&lt;/li&gt;
&lt;li&gt;没有 enforce 值的用户插件&lt;/li&gt;
&lt;li&gt;Vite 构建用的插件&lt;/li&gt;
&lt;li&gt;带有 enforce: &#39;post&#39; 的用户插件&lt;/li&gt;
&lt;li&gt;Vite 后置构建插件（最小化，manifest，报告）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;情景应用&#34;&gt;情景应用&lt;/h3&gt;
&lt;p&gt;默认情况下插件在开发（serve）和构建（build）模式中都会调用。如果插件只需要在预览或构建期间有条件地应用，请使用 apply 属性指明它们仅在 &#39;build&#39; 或 &#39;serve&#39; 模式时调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function myPlugin() {
  return {
    name: &#39;build-only&#39;,
    apply: &#39;build&#39; // 或 &#39;serve&#39;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时，还可以使用函数来进行更精准的控制：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;apply(config, { command }) {
  // 非 SSR 情况下的 build
  return command === &#39;build&#39; &amp;amp;&amp;amp; !config.build.ssr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;rollup-插件兼容性&#34;&gt;Rollup 插件兼容性&lt;/h3&gt;
&lt;p&gt;相当数量的 Rollup 插件将直接作为 Vite 插件工作（例如：@rollup/plugin-alias 或 @rollup/plugin-json），但并不是所有的，因为有些插件钩子在非构建式的开发服务器上下文中没有意义。&lt;/p&gt;
&lt;p&gt;一般来说，只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有使用 moduleParsed 钩子。&lt;/li&gt;
&lt;li&gt;它在打包钩子和输出钩子之间没有很强的耦合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。&lt;/p&gt;
&lt;p&gt;你也可以用 Vite 独有的属性来扩展现有的 Rollup 插件:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// vite.config.js
import example from &#39;rollup-plugin-example&#39;
import { defineConfig } from &#39;vite&#39;

export default defineConfig({
  plugins: [
    {
      ...example(),
      enforce: &#39;post&#39;,
      apply: &#39;build&#39;
    }
  ]
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看 &lt;a href=&#34;https://vite-rollup-plugins.patak.dev/&#34;&gt;Vite Rollup 插件&lt;/a&gt; 获取兼容的官方 Rollup 插件列表及其使用指南。&lt;/p&gt;
&lt;h3 id=&#34;a-idtest-nametest项目实战a&#34;&gt;&lt;a id=&#34;test&#34; name=&#34;test&#34;&gt;项目实战&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先说下我们要做什么，我们用vite打包完之后需要将打包出来的静态资源上传到cdn上，但现有的插件不够灵活，比如&lt;a href=&#34;https://www.npmjs.com/package/vite-plugin-assets-uploader&#34;&gt;vite-plugin-assets-uploader&lt;br&gt;
&lt;/a&gt;这个很好，但是需要将oss的密钥等信息写在前端，不够安全。对此我们就用node写了个接口，前端只需要调用node接口就能够上传到oss。而且将代码上传到cdn之后，我们的base路径也要改成cdn的路径。&lt;/p&gt;
&lt;p&gt;自定义上传插件代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/* eslint-disable no-prototype-builtins */
/* eslint-disable no-self-assign */
const path = require(&#39;path&#39;)
const fs = require(&#39;fs-extra&#39;)
const request = require(&#39;request&#39;)
const glob = require(&#39;glob&#39;)
import { Ioptions } from &#39;../type&#39;
import &#39;colors&#39;
const packageInfo: any = require(path.resolve(&#39;package.json&#39;))
class FileUploader {
  bucket?: string
  uploadUrl: string
  domain: string
  env: string
  prefix?: string
  constructor({ bucket, prefix, env }: { bucket?: string; prefix?: string; env: string }) {
    this.env = env
    if (!env) {
      new Error(&#39;请传入env&#39;)
      return
    }
    this.bucket = bucket || &#39;默认bucket&#39;
    this.prefix = prefix || `${packageInfo.name}/${this.env}/${packageInfo.version}/`
    this.uploadUrl = &#39;接口域名&#39;
    this.domain = &#39;domain&#39;
  }
  // 获取base
  getBase() {
    return `${this.domain}/${this.prefix}`
  }
  // vite上传插件
  UploadPlugin() {
    const options: Ioptions = {
      assetsDir: &#39;&#39;,
      mode: &#39;&#39;,
      outDir: &#39;&#39;
    }
    const that = this
    return {
      name: &#39;vite-plugin-upload&#39;,
      configResolved: function(config: any) {
        const outDir = config.build.hasOwnProperty(&#39;outDir&#39;) ? config.build.outDir : &#39;dist&#39;
        const outDirArr = outDir.split(path.sep)
        options.outDir = outDirArr[outDirArr.length - 1]
        options.assetsDir = `${options.outDir}/${config.build.assetsDir}`
        options.mode = config.mode
      },
      closeBundle() {
        const files = glob.sync(`${options.assetsDir}/*`)
        files.map((item: any) =&amp;gt; {
          that.uploadPre(path.relative(options.outDir, path.resolve(item)), options.outDir)
        })
      }
    }
  }
  // init判断是否支持此bucket
  init() {
    return new Promise((resolve, reject) =&amp;gt; {
      request.get(
        { url: this.uploadUrl + &#39;/api/bucketList&#39; },
        (err: any, response: { statusCode: any }, body: string) =&amp;gt; {
          const { code, data } = typeof body === &#39;object&#39; ? body : JSON.parse(body)
          if (err) {
            reject(false)
          }
          if (code !== 0) {
            reject(false)
          } else {
            let cdnInfo = new Map([])
            data.forEach((v: any) =&amp;gt; {
              cdnInfo.set(v.bucket, v.url)
            })
            if (!cdnInfo.has(this.bucket)) {
              throw new Error(`目前仅支持以下bucket${data.map((v: any) =&amp;gt; v.bucket).join(&#39; | &#39;)}`)
            } else {
              this.domain = cdnInfo.get(this.bucket) as string
              resolve(this.getBase())
            }
          }
        }
      )
    })
  }
  // 检查是否存在该文件
  isExistObject(filePath: string) {
    return new Promise(reslove =&amp;gt; {
      request.get(
        {
          url: `${this.uploadUrl}/api/isExistObject?name=${this.prefix + filePath}&amp;amp;bucket=${
            this.bucket
          }`
        },
        (err: any, response: any, body: string) =&amp;gt; {
          if (err) {
            console.log(&#39;err&#39;, err)
            process.exit(1)
          }
          if (response.statusCode !== 200) {
            console.log(&#39;err&#39;, &#39;http err&#39;)
            process.exit(1)
          }
          const bodys = JSON.parse(body)
          if (bodys.code === 0) {
            console.log(this.prefix + filePath, &#39;已存在&#39;.yellow)
            reslove(0)
          } else {
            reslove(1)
          }
        }
      )
    })
  }
  // 上传
  upload(filePath: string, outDir: string) {
    return new Promise(reslove =&amp;gt; {
      const formData = {
        key: this.prefix + filePath,
        file: fs.createReadStream(path.resolve(path.join(outDir, filePath))),
        bucket: this.bucket
      }
      request.post(
        {
          url: `${this.uploadUrl}/api/upload`,
          formData
        },
        (err: any, response: any, body: string) =&amp;gt; {
          if (err) {
            console.log(&#39;err&#39;, err)
            process.exit(1)
          }
          if (response.statusCode !== 200) {
            console.log(&#39;err&#39;, &#39;http err&#39;)
            process.exit(1)
          }
          const bodys = JSON.parse(body)
          if (bodys.code === 0) {
            console.log(bodys.data.fixUrl, &#39;success~&#39;.green)
            reslove(1)
          }
        }
      )
    })
  }
  // 上传前检测
  uploadPre(filePath: string, outDir: string) {
    this.isExistObject(filePath).then((res: number) =&amp;gt; {
      if (res === 1) {
        return this.upload(filePath, outDir)
      }
    })
  }
}
export default FileUploader

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们将它封装到前端组件库中，然后在vite中使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// vite.config.js
import { FileUploader } from &#39;@msb-next/vite-plugin-upload&#39;
const isProd = process.env.VITE_APP_ENV &amp;amp;&amp;amp; process.env.VITE_APP_ENV !== &#39;dev&#39;
  let plugins = [
    reactRefresh(),
    antdDayjs(),
    vitePluginImp({
      libList: [
        {
          libName: &#39;lodash&#39;,
          libDirectory: &#39;&#39;,
          camel2DashComponentName: false,
          style: () =&amp;gt; {
            return false
          },
        },
        {
          libName: &#39;antd&#39;,
          style(name) {
            return `antd/es/${name}/style/index.css`
          },
        },
      ],
    }),
  ]
  let base = &#39;/&#39;
  let sourcemap = true
  //////////////////////////// 主要是这里 /////////////////////////////////////
  if (isProd) {
    const uploader = new FileUploader({
      env: process.env.VITE_APP_ENV,
    })
    // 修改base路径
    base = (await uploader.init()) as string
    plugins.push(uploader.UploadPlugin())
    sourcemap = false
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到这里，其实思路就很清晰了，大家基本能够完成一个自定义vite插件了，下面就是我node层的代码了，大家应该能看明白：&lt;br&gt;
先自定义一个koa中间件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const OSS = require(&#39;ali-oss&#39;);
/**
 * oss 连接oss
 * @param ctx
 * @param next
 * @returns {Promise&amp;lt;void&amp;gt;}
 */
const connect = async (ctx, next) =&amp;gt; {
  let bucket = &#39;&#39;;
  if (ctx.request.method === &#39;POST&#39;) {
    const body = ctx.request.body;
    bucket = body.bucket;
  } else {
    bucket = ctx.query.bucket;
  }
  // 从redis中获取oss密钥等重要信息，看看是否支持当前的bucket，这样新增bucket时比较灵活，当然也可以直接写死。
  const ossAccessRes = await redisClient.get(&#39;ossAccess&#39;);
  const ossAccess = JSON.parse(ossAccessRes);

  const ossConf = ossAccess.find(v =&amp;gt; v.bucket === bucket);
  let client, urlPrefix;
  try {
    client = new OSS(ossConf);
    urlPrefix = ossConf.url;
  } catch (e) {
    ctx.DATA.msg = &#39;暂不支持当前bucket&#39;;
    ctx.body = ctx.DATA;
    throw new HttpError(200);
  }
  ctx.OSS = client;
  ctx.urlPrefix = urlPrefix;
  await next();
};

module.exports = {
  connect
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;router.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const router = require(&#39;koa-router&#39;)();

// 刚才定义的 oss 中间件
const oss = require(&#39;../utils/middleware/oss&#39;);

// 控制器
const {index, bucketList} = require(&#39;../controllers/index&#39;);
const api = require(&#39;../controllers/api&#39;);

// 添加路由
router.post(&#39;/api/upload&#39;, oss.connect, api.upload);
router.get(&#39;/api/list&#39;, oss.connect, api.list);
router.get(&#39;/api/url&#39;, oss.connect, api.url);
router.post(&#39;/api/del&#39;, oss.connect, api.del);
router.get(&#39;/api/isExistObject&#39;, oss.connect, api.isExistObject);
router.get(&#39;/api/bucketList&#39;, bucketList);

module.exports = router;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;controller/api.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const fs = require(&#39;fs&#39;);
const {CustomError} = require(&#39;../utils/tool/error&#39;);
const DEL_SWITCH = false;

/**
 * 上传
 */
const upload = async (ctx) =&amp;gt; {
  const {file} = ctx.request.files;
  const {key} = ctx.request.body;
  const stream = fs.createReadStream(file.path);
  const {name, res, url} = await ctx.OSS.putStream(key, stream);
  ctx.DATA.data = {
    ...res,
    name,
    url,
    fixUrl: `${ctx.urlPrefix}/${name}`
  };
  ctx.body = ctx.DATA;
};

/**
 * 获取oss列表
 */
const list = async (ctx, next) =&amp;gt; {
  const name = ctx.query.name;
  console.log(name);
  ctx.DATA.data = await ctx.OSS.list({
    prefix: name,
    delimiter: &#39;/&#39;
  });
  if (ctx.DATA.data.res.status !== 200) {
    throw new CustomError(0, &#39;文件查找失败&#39;);
  }
  delete ctx.DATA.data.res;
  ctx.body = ctx.DATA;
};

/**
 * 获取文件下载链接，有效期1分钟
 */
const url = async (ctx) =&amp;gt; {
  const name = ctx.query.name;
  ctx.DATA.data = ctx.OSS.signatureUrl(name, {expires: 3600});
  ctx.body = ctx.DATA;
};

/**
 * 删除文件、文件夹
 */
const del = async (ctx) =&amp;gt; {
  if (DEL_SWITCH) {
    let dat = ctx.request.body;
    let delList = dat[0];
    let directory = dat[1];
    try {
      for (let i = 0; i &amp;lt; directory.length; i++) {
        let retList = await ctx.OSS.list({
          prefix: directory[i]
        });
        retList.objects.reverse();
        retList.objects.map(item =&amp;gt; {
          delList.push(item.name);
        });
      }
    } catch (e) {
      throw new CustomError(0, &#39;删除文件:整合失败&#39;);
    }
    let result = await ctx.OSS.deleteMulti(delList, {quiet: true});
    if (result.res.status !== 200) {
      throw new CustomError(0, &#39;删除失败&#39;);
    }
    ctx.DATA.msg = &#39;删除成功&#39;;
    ctx.body = ctx.DATA;
  } else {
    ctx.DATA.msg = &#39;删除文件、文件夹功能未开放！&#39;;
    ctx.body = ctx.DATA;
  }
};

/**
 * 判断文件是否存在
 * @param ctx
 * @returns {Promise&amp;lt;void&amp;gt;}
 */
const isExistObject = async (ctx) =&amp;gt; {
  // 用于判断受版本控制Bucket中指定versionId的Object是否存在。
  const options = {
    // 填写Object的versionId。
    versionId: &#39;&#39;
  };
  const name = ctx.query.name;
  try {
    const res = await ctx.OSS.head(name, options);
    ctx.DATA.data = res;
    ctx.DATA.msg = &#39;文件存在&#39;;
    ctx.body = ctx.DATA;
  }  catch (error) {
    if (error.code === &#39;NoSuchKey&#39;) {
      ctx.DATA.code = 1;
      ctx.DATA.msg = &#39;文件不存在&#39;;
      ctx.body = ctx.DATA;
    }
  }
};

module.exports = {
  upload,
  list,
  url,
  del,
  isExistObject,
};

&lt;/code&gt;&lt;/pre&gt;
">vite自定义上传插件</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/zi-ding-yi-yi-ge-webpack-de-cha-jian"" data-c="
          &lt;h3 id=&#34;1-webpack插件的基本原理&#34;&gt;1、webpack插件的基本原理&lt;/h3&gt;
&lt;p&gt;我们知道，webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。&lt;br&gt;
webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好。&lt;br&gt;
&lt;a href=&#34;https://www.webpackjs.com/contribute/writing-a-plugin/&#34;&gt;官网提供的自定义插件文档&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tapable 是一个类似于 Node.js 中的 EventEmitter的库，但更专注于自定义事件的触发和处理。webpack 通过 tapable 将实现与流程解耦，所有具体实现通过插件的形式存在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;tapable作为webpack的主模块，需要单独抽一篇出来讲。需要注意的是，如果你要写sdk需要向外层吐露数据的话，建议还是用EventEmitter库，不建议用tapable，因为它销毁全部注册事件不是很容易。&lt;br&gt;
好了，写webpack插件必须要了解tapable，这里我们先简单介绍一下它的几个常用的钩子，其他的可以网上查，这里有篇写的还不错&lt;a href=&#34;https://blog.csdn.net/mafan121/article/details/113120081&#34;&gt;tapable详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;const {
  SyncHook,
  SyncBailHook,
  SyncWaterfallHook,
  SyncLoopHook,
  AsyncParallelHook,
  AsyncParallelBailHook,
  AsyncSeriesHook,
  AsyncSeriesBailHook,
  AsyncSeriesWaterfallHook
} = require(&#39;tapable&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;tapable通过tap注册一个事件通过call执行该钩子注册的所有事件-tapable的每个hooks都tap一个或多个事件-tapasynccallasync-tappromisepromise用于注册同步执行的异步事件callasync用在并行执行的异步钩子完成后再执行该函数&#34;&gt;tapable通过tap注册一个事件，通过call执行该钩子注册的所有事件。tapable的每个hooks都tap一个或多个事件。tapAsync/callAsync、tapPromise/Promise用于注册同步执行的异步事件，callAsync用在并行执行的异步钩子完成后再执行该函数。&lt;/h3&gt;
&lt;p&gt;具体使用举个例子（比如SyncHook，依次执行注册事件，无法中断）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; const hook = new SyncHook([&#39;name&#39;, &#39;sex&#39;])
  /*
  tap(options,function):
  options是事件描述，可以为一个字符串，也可以为一个对象,为对象时必须包含name属性，描述该插件名称。
  function:回调函数
  */
  // 打印我的名字
  hook.tap(&#39;printName&#39;, (name) =&amp;gt; {
    console.log(&#39;my name is &#39; + name);
  })
  hook.tap(&#39;printSex&#39;, (name, sex) =&amp;gt; {
    console.log(&#39;I’m a &#39; + sex);
  })
  // call(arg1,arg2,...)
  hook.call(&#39;张三&#39;, &#39;man&#39;);

  执行结果：

    my name is 张三

    I’m a man
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了，说了一堆tapable了，该说webpack插件了。&lt;/p&gt;
&lt;p&gt;webpack 插件由以下组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个 JavaScript 命名函数。&lt;/li&gt;
&lt;li&gt;在插件函数的 prototype 上定义一个 apply 方法。&lt;/li&gt;
&lt;li&gt;指定一个绑定到 webpack 自身的事件钩子。&lt;/li&gt;
&lt;li&gt;处理 webpack 内部实例的特定数据。&lt;/li&gt;
&lt;li&gt;功能完成后调用 webpack 提供的回调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是官网的简单例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 一个 JavaScript 命名函数。
function MyExampleWebpackPlugin() {

};

// 在插件函数的 prototype 上定义一个 `apply` 方法。
MyExampleWebpackPlugin.prototype.apply = function(compiler) {
  // 指定一个挂载到 webpack 自身的事件钩子。
  compiler.plugin(&#39;webpacksEventHook&#39;, function(compilation /* 处理 webpack 内部实例的特定数据。*/, callback) {
    console.log(&amp;quot;This is an example plugin!!!&amp;quot;);

    // 功能完成后调用 webpack 提供的回调。
    callback();
  });
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在我们使用该plugin的时候，相关调用及配置代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const MyExampleWebpackPlugin = require(&#39;./MyExampleWebpackPlugin&#39;);
module.exports = {
  plugins: [
    new MyExampleWebpackPlugin(options)
  ]
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我开始说了一大堆tapable，其实就是为了说明白webpack插件的原理&lt;/p&gt;
&lt;p&gt;用代码说明吧，一个compiler.js，一个main.js&lt;br&gt;
compiler.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 需要做的事情如下：
// 1. 定义一个 Compiler 类，接收一个options对象参数，该参数是从main.js中的MyPlugin类的实列对象。该对象下有 apply函数。

// 2. 在该类中我们定义了run方法，我们在main.js 中执行该run函数就可以自动执行对应的插件了。

const { SyncHook, AsyncParallelHook } = require(&#39;tapable&#39;);

class Compiler {
  constructor(options) {
    this.hooks = {
      kzSyncHook: new SyncHook([&#39;name&#39;, &#39;age&#39;]),
      kzAsyncHook: new AsyncParallelHook([&#39;name&#39;, &#39;age&#39;])
    };
    let plugins = options.plugins;
    if (plugins &amp;amp;&amp;amp; plugins.length &amp;gt; 0) {
      plugins.forEach(plugin =&amp;gt; plugin.apply(this));
    }
  }
  run() {
    console.log(&#39;开始执行了---------&#39;);
    this.kzSyncHook(&#39;我是小明&#39;, 81);
    this.kzAsyncHook(&#39;我是小红&#39;, 91);
  }
  kzSyncHook(name, age) {
    this.hooks.kzSyncHook.call(name, age);
  }
  kzAsyncHook(name, age) {
    this.hooks.kzAsyncHook.callAsync(name, age);
  }
}

module.exports = Compiler;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;main.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 需要做的事情如下：
// 1. 引入 compiler.js 文件。
// 2. 定义一个自己的插件，比如叫 MyPlugin 类，该类下有 apply 函数。该函数有一个 compiler 参数，该参数就是我们的 compiler.js 中的实列对象。然后我们会使用 compiler 实列对象去调用 compiler.js 里面的函数。因此就可以自动执行了。
const Compiler = require(&#39;./compiler&#39;);

class MyPlugin {
  constructor() {
    
  }
  apply(compiler) {
    compiler.hooks.kzSyncHook.tap(&amp;quot;eventName1&amp;quot;, (name, age) =&amp;gt; {
      console.log(`同步事件eventName1： ${name} this year ${age} 周岁了, 可是还是单身`);
    });
    compiler.hooks.kzAsyncHook.tapAsync(&#39;eventName2&#39;, (name, age) =&amp;gt; {
      setTimeout(() =&amp;gt; {
        console.log(`异步事件eventName2： ${name} this year ${age}周岁了，可是还是单身`);
      }, 1000)
    });
  }
}

const myPlugin = new MyPlugin();

const options = {
  plugins: [myPlugin]
};

const compiler = new Compiler(options);
compiler.run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到没，这种使用方式是不是和官网的使用方式很相似～这回知道原理了吧～&lt;/p&gt;
&lt;p&gt;现在看官网的简单例子，webpack启动后，在读取配置的过程中会先执行 new MyExampleWebpackPlugin(options) 初始化MyExampleWebpackPlugin来获得一个实例。&lt;br&gt;
然后我们会把该实例当做参数传递给我们的Compiler对象，然后会实例化 Compiler类(这个逻辑可以结合看我们上面实现了一个简单的demo中 的main.js和compiler.js的代码结合起来理解)。在Compiler类中，我们会获取到options的这个参数，该参数是一个对象，该对象下有一个 plugins 这个属性。&lt;br&gt;
然后遍历该属性，然后依次执行 某项插件中的apply方法，即：myExampleWebpackPlugin.apply(compiler); 给插件传递compiler对象。插件实例获取该compiler对象后，就可以通过 compiler.plugin(&#39;事件名称&#39;, &#39;回调函数&#39;); 监听到webpack广播出来的事件.(这个地方我们可以看我们上面的main.js中的如下代码可以看到, 在我们的main.js代码中有这样代码：compiler.hooks.kzSyncHook.tap(&amp;quot;eventName1&amp;quot;, (name, age) =&amp;gt; {}));&lt;/p&gt;
&lt;p&gt;如上就是一个简单的Plugin的插件原理(切记：结合上面的demo中main.js和compiller.js来理解效果会更好)。&lt;/p&gt;
&lt;h3 id=&#34;2-compiler-和-compilation&#34;&gt;2、Compiler 和 Compilation&lt;/h3&gt;
&lt;p&gt;在开发Plugin时我们最常用的两个对象就是 Compiler 和 Compilation, 他们是Plugin和webpack之间的桥梁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;compiler对象&#34;&gt;Compiler对象&lt;/h4&gt;
&lt;p&gt;Compiler对象包含了Webpack环境所有的配置信息，包含options，loaders, plugins这些项，这个对象在webpack启动时候被实例化，它是全局唯一的。我们可以把它理解为webpack的实例。&lt;/p&gt;
&lt;p&gt;基本源码可以看如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// webpack/lib/webpack.js
const Compiler = require(&amp;quot;./Compiler&amp;quot;)

const webpack = (options, callback) =&amp;gt; {
  ...
  // 初始化 webpack 各配置参数
  options = new WebpackOptionsDefaulter().process(options);

  // 初始化 compiler 对象，这里 options.context 为 process.cwd()
  let compiler = new Compiler(options.context);

  compiler.options = options                               // 往 compiler 添加初始化参数

  new NodeEnvironmentPlugin().apply(compiler)              // 往 compiler 添加 Node 环境相关方法

  for (const plugin of options.plugins) {
    plugin.apply(compiler);
  }
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/webpack/webpack/blob/10282ea20648b465caec6448849f24fc34e1ba3e/lib/webpack.js#L30&#34;&gt;源码可以点击这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上我们可以看到，Compiler对象包含了所有的webpack可配置的内容。开发插件时，我们可以从 compiler 对象中拿到所有和 webpack 主环境相关的内容。&lt;/p&gt;
&lt;h4 id=&#34;compilation对象&#34;&gt;compilation对象&lt;/h4&gt;
&lt;p&gt;compilation 对象包含了当前的模块资源、编译生成资源、文件的变化等。当webpack在开发模式下运行时，每当检测到一个文件发生改变的时候，那么一次新的 Compilation将会被创建。从而生成一组新的编译资源。&lt;/p&gt;
&lt;p&gt;Compiler对象 与 Compilation 对象 的区别是：Compiler代表了是整个webpack从启动到关闭的生命周期。Compilation 对象只代表了一次新的编译。&lt;/p&gt;
&lt;p&gt;Compiler对象的事件钩子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;钩子               作用                     参数               类型
after-plugins     设置完一组初始化插件之后    compiler          sync
after-resolvers   设置完 resolvers 之后     compiler          sync
run               在读取记录之前             compiler          async
compile           在创建新 compilation之前  compilationParams  sync
compilation       compilation 创建完成      compilation        sync
emit              在生成资源并输出到目录之前  compilation        async
after-emit        在生成资源并输出到目录之后  compilation        async
done              完成编译                  stats              sync
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/webpack/webpack/blob/eca7bad8de54c39b9cb8b138793362b8a17ac11b/lib/Compiler.js#L32&#34;&gt;源码地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;理解webpack中的事件流&#34;&gt;理解webpack中的事件流&lt;/h4&gt;
&lt;p&gt;我们可以把webpack理解为一条生产线，需要经过一系列处理流程后才能将源文件转换成输出结果。&lt;br&gt;
这条生产线上的每个处理流程的职责都是单一的，多个流程之间会存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。&lt;/p&gt;
&lt;p&gt;我们的插件就像一个插入到生产线中的一个功能，在特定的时机对生产线上的资源会做处理。webpack它是通过 Tapable来组织这条复杂的生产线的。&lt;/p&gt;
&lt;p&gt;webpack在运行的过程中会广播事件，插件只需要关心监听它的事件，就能加入到这条生产线中。然后会执行相关的操作。&lt;br&gt;
webpack的事件流机制它能保证了插件的有序性，使整个系统的扩展性好。事件流机制使用了观察者模式来实现的。比如如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 广播事件
 * myPlugin-name 为事件名称
 * params 为附带的参数
*/

compiler.apply(&#39;myPlugin-name&#39;, params); // myPlugin-name随便写，就是一个名字

/*
 * 监听名称为 &#39;myPlugin-name&#39; 的事件，当 myPlugin-name 事件发生时，函数就会执行。
*/

compiler.hooks.myPlugin-name.tap(&#39;myPlugin-name&#39;, function(params) {
  
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;插件中常用的api&#34;&gt;插件中常用的API&lt;/h3&gt;
&lt;h4 id=&#34;compiler生命周期钩子&#34;&gt;compiler生命周期钩子&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.webpackjs.com/api/compiler-hooks/&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Compiler 支持可以监控文件系统的&lt;a href=&#34;https://www.webpackjs.com/api/node/#watching&#34;&gt;监听(watching)&lt;/a&gt;机制，并且在文件修改时重新编译。当处于监听模式(watch mode)时，compiler 会触发诸如 watchRun, watchClose 和 invalid 等额外的事件。通常用于开发环境中使用，也常常会在 webpack-dev-server 这些工具的底层之下调用，由此开发人员无须每次都使用手动方式重新编译。还可以通过 CLI 进入监听模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关钩子：&lt;br&gt;
以下生命周期钩子函数，是由 compiler 暴露，可以通过如下方式访问：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compiler.hooks.someHook.tap(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取决于不同的钩子类型，也可以在某些钩子上访问 tapAsync 和 tapPromise。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;生命周期&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;对应hooks&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;执行时机&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;参数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;entryOption&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncBailHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在 entry 配置项处理过之后，执行插件。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;afterPlugins&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;设置完初始插件之后，执行插件。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;afterResolvers&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;resolver 安装完成之后，执行插件。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;environment&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;environment 准备好之后，执行插件。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;afterEnvironment&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;environment 安装完成之后，执行插件。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;beforeRun&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AsyncSeriesHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compiler.run() 执行之前，添加一个钩子。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;run&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AsyncSeriesHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;开始读取 records 之前，钩入(hook into) compiler。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;watchRun&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AsyncSeriesHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;监听模式下，一个新的编译(compilation)触发之后，执行一个插件，但是是在实际编译开始之前。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compiler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;normalModuleFactory&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;NormalModuleFactory 创建之后，执行插件。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;normalModuleFactory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;contextModuleFactory&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;ContextModuleFactory 创建之后，执行插件。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;contextModuleFactory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;beforeCompile&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AsyncSeriesHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;编译(compilation)参数创建之后，执行插件。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compilationParams&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compile&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一个新的编译(compilation)创建之后，钩入(hook into) compiler。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compilationParams&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;thisCompilation&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;触发 compilation 事件之前执行（查看下面的 compilation）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compilation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compilation&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;编译(compilation)创建之后，执行插件&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compilation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;make&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AsyncParallelHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compilation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;afterCompile&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AsyncSeriesHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compilation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;shouldEmit&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncBailHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;此时返回 true/false。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compilation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;needAdditionalPass&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncBailHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;emit&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AsyncSeriesHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;生成资源到 output 目录之前。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compilation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;afterEmit&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;AsyncSeriesHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;生成资源到 output 目录之后。&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;compilation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;done&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;编译(compilation)完成&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;stats&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;failed&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;编译(compilation)失败&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;error&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;invalid&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;监听模式下，编译无效时&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fileName, changeTime&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;watchClose&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SyncHook&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;监听模式停止&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;读取输出资源-模块及依赖&#34;&gt;读取输出资源、模块及依赖&lt;/h4&gt;
&lt;p&gt;在我们的emit钩子事件发生时，表示的含义是：源文件的转换和组装已经完成了，在这里事件钩子里面我们可以读取到最终将输出的资源、代码块、模块及对应的依赖文件。并且我们还可以输出资源文件的内容。比如插件代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class MyPlugin {
  apply(compiler) {
    compiler.plugin(&#39;emit&#39;, function(compilation, callback) {
      // compilation.chunks 是存放了所有的代码块，是一个数组，我们需要遍历
      compilation.chunks.forEach(function(chunk) {
        /*
         * chunk 代表一个代码块，代码块它是由多个模块组成的。
         * 我们可以通过 chunk.forEachModule 能读取组成代码块的每个模块
        */
        chunk.forEachModule(function(module) {
          // module 代表一个模块。
          // module.fileDependencies 存放当前模块的所有依赖的文件路径，它是一个数组
          module.fileDependencies.forEach(function(filepath) {
            console.log(filepath);
          });
        });
        /*
         webpack 会根据chunk去生成输出的文件资源，每个chunk都对应一个及以上的输出文件。
         比如在 Chunk中包含了css 模块并且使用了 ExtractTextPlugin 时，
         那么该Chunk 就会生成 .js 和 .css 两个文件
        */
        chunk.files.forEach(function(filename) {
          // compilation.assets 是存放当前所有即将输出的资源。
          // 调用一个输出资源的 source() 方法能获取到输出资源的内容
          const source = compilation.assets[filename].source();
        });
      });
      /*
       该事件是异步事件，因此要调用 callback 来通知本次的 webpack事件监听结束。
       如果我们没有调用callback(); 那么webpack就会一直卡在这里不会往后执行。
      */
      callback();
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;监听文件变化&#34;&gt;监听文件变化&lt;/h4&gt;
&lt;p&gt;webpack读取文件的时候，它会从入口模块去读取，然后依次找出所有的依赖模块。当入口模块或依赖的模块发生改变的时候，那么就会触发一次新的 Compilation。&lt;/p&gt;
&lt;p&gt;在我们开发插件的时候，我们需要知道是那个文件发生改变，导致了新的Compilation, 我们可以添加如下代码进行监听。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 当依赖的文件发生改变的时候 会触发 watch-run 事件
class MyPlugin {
  apply(compiler) {
    compiler.plugin(&#39;watch-run&#39;, (watching, callback) =&amp;gt; {
      // 获取发生变换的文件列表
      const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes;
      // changedFiles 格式为键值对的形式，当键为发生变化的文件路径
      if (changedFiles[filePath] !== undefined) {
        // 对应的文件就发生了变化了
      }
      callback();
    });

    /*
     默认情况下Webpack只会监听入口文件或其依赖的模块是否发生变化，但是在有些情况下比如html文件发生改变的时候，那么webpack
     就会去监听html文件的变化。因此就不会重新触发新的 Compilation。因此为了监听html文件的变化，我们需要把html文件加入到
     依赖列表中。因此我们需要添加如下代码：
    */
    compiler.plugin(&#39;after-compile&#39;, (compilation, callback) =&amp;gt; {
      /*
       如下的参数filePath是html文件路径，我们把HTML文件添加到文件依赖表中，然后我们的webpack会去监听html模块文件，
       html模板文件发生改变的时候，会重新启动下重新编译一个新的 Compilation.
      */
      compilation.fileDependencies.push(filePath);
      callback();
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修改输出资源&#34;&gt;修改输出资源&lt;/h4&gt;
&lt;p&gt;我们在第一点说过：在我们的emit钩子事件发生时，表示的含义是：源文件的转换和组装已经完成了，在这里事件钩子里面我们可以读取到最终将输出的资源、代码块、模块及对应的依赖文件。因此如果我们现在要修改输出资源的内容的话，我们可以在emit事件中去做修改。那么所有输出的资源会存放在 compilation.assets中，compilation.assets是一个键值对，键为需要输出的文件名，值为文件对应的内容。如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class MyPlugin {
  apply(compiler) {
    compiler.plugin(&#39;emit&#39;, (compilation, callback) =&amp;gt; {
      // 设置名称为 fileName 的输出资源
      compilation.assets[fileName] = {
        // 返回文件内容
        source: () =&amp;gt; {
          // fileContent 即可以代表文本文件的字符串，也可以是代表二进制文件的buffer
          return fileContent;
        },
        // 返回文件大小
        size: () =&amp;gt; {
          return Buffer.byteLength(fileContent, &#39;utf8&#39;);
        }
      };
      callback();
    });
    // 读取 compilation.assets 代码如下：
    compiler.plugin(&#39;emit&#39;, (compilation, callback) =&amp;gt; {
      // 读取名称为 fileName 的输出资源
      const asset = compilation.assets[fileName];
      // 获取输出资源的内容
      asset.source();
      // 获取输出资源的文件大小
      asset.size();
      callback();
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;判断webpack使用了哪些插件&#34;&gt;判断webpack使用了哪些插件&lt;/h4&gt;
&lt;p&gt;在我们开发一个插件的时候，我们需要根据当前配置是否使用了其他某个插件，我们可以通过读取webpack某个插件配置的情况，比如来判断我们当前是否使用了 HtmlWebpackPlugin 插件。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/*
 判断当前配置使用了 HtmlWebpackPlugin 插件。
 compiler参数即为 webpack 在 apply(compiler) 中传入的参数
*/

function hasHtmlWebpackPlugin(compiler) {
  // 获取当前配置下所有的插件列表
  const plugins = compiler.options.plugins;
  // 去plugins中寻找有没有 HtmlWebpackPlugin 的实列
  return plugins.find(plugin =&amp;gt; plugin.__proto__.constructor === HtmlWebpackPlugin) !== null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实战&#34;&gt;实战&lt;/h3&gt;
&lt;h4 id=&#34;实现一个打印日志的logwebpackplugin插件&#34;&gt;实现一个打印日志的LogWebpackPlugin插件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 这个文件为了观看更直观，先放到webpack.config.js中，真正使用时可以将你的自定义webpack插件封装到你们的前端组件库中。
class LogWebpackPlugin {
  constructor(doneCallback, emitCallback) {
    this.emitCallback = emitCallback
    this.doneCallback = doneCallback
  }
  apply(compiler) {
    compiler.hooks.emit.tap(&#39;LogWebpackPlugin&#39;, () =&amp;gt; {
      // 在 emit 事件中回调 emitCallback
      this.emitCallback();
    });
    compiler.hooks.done.tap(&#39;LogWebpackPlugin&#39;, (err) =&amp;gt; {
      // 在 done 事件中回调 doneCallback
      this.doneCallback();
    });
    compiler.hooks.compilation.tap(&#39;LogWebpackPlugin&#39;, () =&amp;gt; {
      // compilation（&#39;编译器&#39;对&#39;编译ing&#39;这个事件的监听）
      console.log(&amp;quot;The compiler is starting a new compilation...&amp;quot;)
    });
    compiler.hooks.compile.tap(&#39;LogWebpackPlugin&#39;, () =&amp;gt; {
      // compile（&#39;编译器&#39;对&#39;开始编译&#39;这个事件的监听）
      console.log(&amp;quot;The compiler is starting to compile...&amp;quot;)
    });
  }
}


// 使用
module.exports = {
  plugins: [
    new LogWebpackPlugin(() =&amp;gt; {
      // Webpack 模块完成转换成功
      console.log(&#39;emit 事件发生啦，所有模块的转换和代码块对应的文件已经生成好~&#39;)
    } , () =&amp;gt; {
      // Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作
      console.log(&#39;done 事件发生啦，成功构建完成~&#39;)
    })
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;编写去除生成-bundlejs-中多余的注释的插件&#34;&gt;编写去除生成 bundle.js 中多余的注释的插件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class MyPlugin {
  constructor(options) {
    this.options = options;
    this.externalModules = {};
  }
  apply(compiler) {
    var reg = /(&amp;quot;([^\\\&amp;quot;]*(\\.)?)*&amp;quot;)|(&#39;([^\\\&#39;]*(\\.)?)*&#39;)|(\/{2,}.*?(\r|\n))|(\/\*(\n|.)*?\*\/)|(\/\*\*\*\*\*\*\/)/g;
    compiler.hooks.emit.tap(&#39;CodeBeautify&#39;, (compilation) =&amp;gt; {
      Object.keys(compilation.assets).forEach((data) =&amp;gt; {
        console.log(data);
        let content = compilation.assets[data].source(); // 获取处理的文本
        content = content.replace(reg, function (word) { // 去除注释后的文本
          return /^\/{2,}/.test(word) || /^\/\*!/.test(word) || /^\/\*{3,}\//.test(word) ? &amp;quot;&amp;quot; : word;
        });
        compilation.assets[data] = {
          source() {
            return content;
          },
          size() {
            return content.length;
          }
        }
      });
    });
  }
}
module.exports = MyPlugin;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个js代码的真正的含义才是我们今天要讲到的，这个插件最主要作用是 去除注释后的文本。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一步，我们使用 compiler.hooks.emit 钩子函数。在生成资源并输出到目录之前触发该函数，也就是说将编译好的代码发射到指定的stream中就会触发，然后我们从回调函数返回的 compilation 对象上可以拿到编译好的 stream.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问compilation对象，compilation内部会返回很多内部对象，这边先不打印了，因为打印的话直接会卡死掉，要等很长时间才会打印出来，你们自己可以试试；然后我们遍历 assets.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.keys(compilation.assets).forEach((data) =&amp;gt; {
  console.log(compilation.assets);
  console.log(8888)
  console.log(data);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1644922971138.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;assets 数组对象中的key是资源名。在如上代码，我们通过 Object.key()方法拿到了。如下所示：&lt;pre&gt;&lt;code&gt;main.css
bundle.js
index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;然后我们调用 compilation.assets[data].source(); 可以获取资源的内容。&lt;/li&gt;
&lt;li&gt;使用正则，去掉注释，如下代码：&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.keys(compilation.assets).forEach((data) =&amp;gt; {
  let content = compilation.assets[data].source(); // 获取处理的文本
  content = content.replace(reg, function (word) { // 去除注释后的文本
      return /^\/{2,}/.test(word) || /^\/\*!/.test(word) || /^\/\*{3,}\//.test(word) ? &amp;quot;&amp;quot; : word;
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;更新 compilation.assets[data] 对象，如下代码：&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;compilation.assets[data] = {
  source() {
      return content;
  },
  size() {
      return content.length;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;最后使用&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;module.exports = {
  plugins:[
      new MyPlugin(),
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;webpack40之后用compilerhooks注册之前用comlilerplugin注册但为了保险起见还是两种办法都写这样能应付服务器无webpack4版本详见这篇文章&#34;&gt;webpack4.0之后用compiler.hooks注册，之前用comliler.plugin注册，但为了保险起见，还是两种办法都写，这样能应付服务器无webpack4版本，详见：&lt;a href=&#34;https://www.cnblogs.com/dashnowords/p/9572749.html&#34;&gt;这篇文章&lt;/a&gt;&lt;/h4&gt;
&lt;h3 id=&#34;最后扩展简单看了几个插件之后是不是可以考虑做些其他的事情比如删除consolelog-或者构建完成时做一些文件上传cdn的操作马上动手吧~&#34;&gt;最后扩展：简单看了几个插件之后，是不是可以考虑做些其他的事情，比如删除console.log、或者构建完成时做一些文件上传cdn的操作，马上动手吧～&lt;/h3&gt;
">自定义一个WebPack的插件</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1644479995097.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">短信短链接唤起APP</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng"" data-c="
          &lt;h3 id=&#34;先说下为什么要获取-openid&#34;&gt;先说下为什么要获取 openid?&lt;/h3&gt;
&lt;p&gt;因为用户管理类接口可以通过openid可以获取用户的一些信息的.&lt;/p&gt;
&lt;h3 id=&#34;说到-openid-必须先说微信授权登录的过程&#34;&gt;说到 openid 必须先说微信授权登录的过程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1644479416142.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前端需要在进入路由的是beaforEach的时候，先去判断链接上有没有 openid&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有，就去跳转到服务端给的一个地址。如果有，就继续往下走（next())&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个时候服务端会往下面的链接（https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;amp;redirect_uri=REDIRECT_URI&amp;amp;response_type=code&amp;amp;scope=SCOPE&amp;amp;state=STATE#wechat_redirect来获取code）上跳转，去引导用户去点击授权，用户授权之后就会重定向到 redirect_uri（服务端的地址）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用 code 获取 openid 之后(服务端去做)，服务端会跳转到前端页面(带上openid)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面作为了解：&lt;/p&gt;
&lt;p&gt;微信授权使用的是 OAuth2.0授权方式。主要有以下简略的步骤：&lt;br&gt;
第一步：用户同意授权，获取 code&lt;br&gt;
　　第二步：通过 code获取网页授权access_token&lt;br&gt;
　　第三步：刷新access_token（如果需要）&lt;br&gt;
　　第四步：拉取用户信息(需scope为 snsapi_userinfo)&lt;/p&gt;
&lt;h3 id=&#34;下面来具体api表示下怎么获取的-code-和-openid-吧&#34;&gt;下面来具体api表示下怎么获取的 code 和 openid 吧&lt;/h3&gt;
&lt;h3 id=&#34;一获取code&#34;&gt;一：获取code:&lt;/h3&gt;
&lt;p&gt;通过https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;amp;redirect_uri=REDIRECT_URI&amp;amp;response_type=code&amp;amp;scope=SCOPE&amp;amp;state=STATE#wechat_redirect来获取code&lt;br&gt;
参数：&lt;br&gt;
APPID：应用唯一标识&lt;br&gt;
redirect_uri：授权后重定向的回调链接地址，用户同意后，code 会自动添加到后面。（请使用urlEncode对链接进行处理 （$url = urlencode(&#39;&#39;)） ）&lt;br&gt;
scope：是应用授权作用域 （一般有两种：一种是静默方式（snsapi_base); 一种是非静默方式（snsapi_userinfo），需要用户去手动同意才能获取用户信息）&lt;/p&gt;
&lt;p&gt;微信中尤其提醒：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问&lt;/p&gt;
&lt;p&gt;** code 是微信自动生成的。并且放在redirect_uri（重定向后的回调链接地址）后面,并且带上code和state参数&lt;/p&gt;
&lt;p&gt;上面提到了 code。那么 code又是什么呢？&lt;br&gt;
code:作为换取 access_token的票据，每次用户授权带上的 code 都不一样。5分钟未被使用自动过期（过期的这里下面有讲）&lt;/p&gt;
&lt;h3 id=&#34;二然后授权成功之后-得到-code-就用-code-去获取access_token&#34;&gt;二：然后授权成功之后。得到 code。就用 code 去获取access_token&lt;/h3&gt;
&lt;p&gt;https://api.weixin.qq.com/sns/oauth2/access_token?appid=wx41cb8dbd827a16e9&amp;amp;secret=d4624c36b6795d1d99dcf0547af5443d&amp;amp;code=00137323023ab55775be09d6d8e75ffA&amp;amp;grant_type=authorization_code&lt;br&gt;
参数说明：&lt;br&gt;
appid：应用唯一标识&lt;br&gt;
code：上一步已经获取到了&lt;br&gt;
secret：应用密钥AppSecret，在微信开放平台提交应用审核通过后获得&lt;/p&gt;
&lt;p&gt;正确的返回&lt;br&gt;
&amp;quot;access_token&amp;quot;:&amp;quot;ACCESS_TOKEN&amp;quot;, // 接口调用凭证 &amp;quot;expires_in&amp;quot;:7200, // access_token接口调用凭证超时时间 &amp;quot;refresh_token&amp;quot;:&amp;quot;REFRESH_TOKEN&amp;quot;, // 用户刷新access_token &amp;quot;openid&amp;quot;:&amp;quot;OPENID&amp;quot;, // 授权用户唯一标识 &amp;quot;scope&amp;quot;:&amp;quot;SCOPE&amp;quot;, // 作用域 等&lt;/p&gt;
&lt;h3 id=&#34;三通过access_token-openid获取用户信息&#34;&gt;三：通过access_token、openid获取用户信息&lt;/h3&gt;
&lt;p&gt;https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;amp;openid=OPENID&lt;br&gt;
就会得到用户的信息：&lt;br&gt;
得到参数：&lt;br&gt;
openid：用户的唯一标识&lt;br&gt;
nickname：用户昵称&lt;br&gt;
sex： 男女&lt;br&gt;
等。。。&lt;br&gt;
特别注意：&lt;br&gt;
1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）； 2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为； 3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。 建议将secret、用户数据（如access_token）放在App云端服务器，由云端中转接口调用请求。&lt;/p&gt;
&lt;h3 id=&#34;最后总结下详细的步骤&#34;&gt;最后总结下详细的步骤：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1．用户关注微信公众账号。&lt;/li&gt;
&lt;li&gt;2．微信公众账号提供用户请求授权页面URL。&lt;/li&gt;
&lt;li&gt;3．用户点击授权页面URL，将向服务器发起请求&lt;/li&gt;
&lt;li&gt;4．服务器询问用户是否同意授权给微信公众账号(scope为snsapi_base时无此步骤)&lt;/li&gt;
&lt;li&gt;5．用户同意(scope为snsapi_base时无此步骤)&lt;/li&gt;
&lt;li&gt;6．服务器将CODE通过回调传给微信公众账号&lt;/li&gt;
&lt;li&gt;7．微信公众账号获得CODE&lt;/li&gt;
&lt;li&gt;8．微信公众账号通过CODE向服务器请求Access Token&lt;/li&gt;
&lt;li&gt;9．服务器返回Access Token和OpenID给微信公众账号&lt;/li&gt;
&lt;li&gt;10．微信公众账号通过Access Token向服务器请求用户信息(scope为snsapi_base时无此步骤)&lt;/li&gt;
&lt;li&gt;11．服务器将用户信息回送给微信公众账号(scope为snsapi_base时无此步骤)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公众号链接(官网更权威)：&lt;br&gt;
https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html&lt;/p&gt;
&lt;p&gt;https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html&lt;/p&gt;
">微信公众号获取openid等一系列流程</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/ru-he-bi-jiao-react-hooks-shang-de-jiu-zhi-he-xin-zhi"" data-c="
          &lt;h3 id=&#34;自定义hooks&#34;&gt;自定义hooks&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function usePrevious(value) {
  const ref = useRef();
  useEffect(() =&amp;gt; {
    ref.current = value;
  });
  return ref.current;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const Component = (props) =&amp;gt; {
    const {valueA, valueB} = props
    
    const prevValue = usePrevious({valueA, valueB});
    useEffect(() =&amp;gt; {
        if(prevValue.valueA !== valueA) {
           ...
       }
        if(prevValue.valueB !== valueB) {
           ...
        }
    }, [valueA, valueB])
}
&lt;/code&gt;&lt;/pre&gt;
">如何比较 React Hooks 上的旧值和新值？</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/usecallback-he-usememo-de-qu-bie"" data-c="
          &lt;h3 id=&#34;区别概览&#34;&gt;区别概览&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;-&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;useCallBack&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;useMemo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;返回值&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一个缓存的回调函数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一个缓存的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;参数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要缓存的函数，依赖项&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;需要缓存的值(也可以是个计算然后再返回值的函数) ，依赖项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;使用场景&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;父组件更新时，通过props传递给子组件的函数也会重新创建，然后这个时候使用 useCallBack 就可以缓存函数不使它重新创建&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;组件更新时，一些计算量很大的值也有可能被重新计算，这个时候就可以使用 useMemo 直接使用上一次缓存的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;usecallback-具体示例&#34;&gt;useCallBack 具体示例&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://codesandbox.io/s/usecallback-1w9f1?file=/src/App.jsx&#34;&gt;codesanbox在线示例&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React, { useCallback, useEffect, useState } from &amp;quot;react&amp;quot;;
import &amp;quot;./styles.css&amp;quot;;

export default function App() {
  const [count, setCount] = useState(0);

  // 使用 useCallBack 缓存
  const handleCountAddByCallBack = useCallback(() =&amp;gt; {
    setCount((count) =&amp;gt; count + 1);
  }, []);

  // 不缓存，每次 count 更新时都会重新创建
  const handleCountAdd = () =&amp;gt; {
    setCount((count) =&amp;gt; count + 1);
  };

  return (
    &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
      &amp;lt;h3&amp;gt;CountAddByChild1: {count}&amp;lt;/h3&amp;gt;
      &amp;lt;Child1 addByCallBack={handleCountAddByCallBack} add={handleCountAdd} /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

const Child1 = React.memo(function (props) {
  const { add, addByCallBack } = props;
  
  // 没有缓存，由于每次都创建，memo 认为两次地址都不同，属于不同的函数，所以会触发 useEffect
  useEffect(() =&amp;gt; {
    console.log(&amp;quot;Child1----addFcUpdate&amp;quot;, props);
  }, [add]);

  // 有缓存，memo 判定两次地址都相同，所以不触发 useEffect
  useEffect(() =&amp;gt; {
    console.log(&amp;quot;Child1----addByCallBackFcUpdate&amp;quot;, props);
  }, [addByCallBack]);

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;button onClick={props.add}&amp;gt;+1&amp;lt;/button&amp;gt;
      &amp;lt;br /&amp;gt;
      &amp;lt;button onClick={props.addByCallBack}&amp;gt;+1(addByCallBack)&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;usememo-示例&#34;&gt;useMemo 示例&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://codesandbox.io/s/usememo-p9t7e?file=/src/App.jsx&#34;&gt;codesandbox 在线示例&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { useState, useMemo } from &amp;quot;react&amp;quot;;
import &amp;quot;./styles.css&amp;quot;;

export default function App() {
  const [count, setCount] = useState(0);
  const [total, setTotal] = useState(0);

  // 没有使用 useMemo，即使是更新 total, countToString 也会重新计算
  const countToString = (() =&amp;gt; {
    console.log(&amp;quot;countToString 被调用&amp;quot;);
    return count.toString();
  })();

  // 使用了 useMemo, 只有 total 改变，才会重新计算
  const totalToStringByMemo = useMemo(() =&amp;gt; {
    console.log(&amp;quot;totalToStringByMemo 被调用&amp;quot;);
    return total + &amp;quot;&amp;quot;;
  }, [total]);

  return (
    &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
      &amp;lt;h3&amp;gt;countToString: {countToString}&amp;lt;/h3&amp;gt;
      &amp;lt;h3&amp;gt;countToString: {totalToStringByMemo}&amp;lt;/h3&amp;gt;
      &amp;lt;button
        onClick={() =&amp;gt; {
          setCount((count) =&amp;gt; count + 1);
        }}
      &amp;gt;
        Add Count
      &amp;lt;/button&amp;gt;
      &amp;lt;br /&amp;gt;
      &amp;lt;button
        onClick={() =&amp;gt; {
          setTotal((total) =&amp;gt; total + 1);
        }}
      &amp;gt;
        Add Total
      &amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;共同作用：仅仅 依赖数据 发生变化, 才会重新计算结果，也就是起到缓存的作用&lt;/li&gt;
&lt;li&gt;区别
&lt;ul&gt;
&lt;li&gt;useCallBack 针对可能重新创建的函数进行优化，使得函数被缓存，React.memo 认定两次地址是相同就可以避免子组件冗余的更新。&lt;/li&gt;
&lt;li&gt;useMemo 针对不必要的计算进行优化，避免了当前组件中一些的冗余计算操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;转载自：https://www.jianshu.com/p/b8d27018ed22&lt;/p&gt;
">useCallback 和 useMemo 的区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/shi-yong-react-hooks-geng-xin-dui-xiang-huo-shu-zu-de-zhi"" data-c="
          &lt;h3 id=&#34;对象类型&#34;&gt;对象类型&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React, { useState } from &#39;react&#39;;

const Index = ()=&amp;gt; {
  const [obj, setObj] = useState({name:&amp;quot;zhangsan&amp;quot;});

  return (
    &amp;lt;&amp;gt;
      &amp;lt;h2&amp;gt;{obj.name}---{obj.age}&amp;lt;/h2&amp;gt;	  
      &amp;lt;button onClick={()=&amp;gt; (
		setObj({
		  ...obj,
		  age:18
		})
	  )}&amp;gt;change-obj&amp;lt;/button&amp;gt;
    &amp;lt;/&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数组类型&#34;&gt;数组类型&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import React, { useState } from &#39;react&#39;;

const Index = ()=&amp;gt; {
  const [arr, setArr] = useState([1,2,3]);

  return (
    &amp;lt;&amp;gt;

      &amp;lt;h2&amp;gt;{arr}&amp;lt;/h2&amp;gt;
      &amp;lt;button onClick={()=&amp;gt;(setArr(
		setarr(()=&amp;gt; {
		  arr.push(4);
		  return [...arr]
		})&amp;gt;change-arr&amp;lt;/button&amp;gt;

    &amp;lt;/&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
">使用React Hooks更新对象或数组的值</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/airbnb-css-sass-gui-fan-zhi-nan"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;用更合理的方式写 CSS 和 Sass&lt;/em&gt; 翻译自&lt;a href=&#34;https://github.com/airbnb/css&#34;&gt;Airbnb CSS / Sass Styleguide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;术语&#34;&gt;术语&lt;/h3&gt;
&lt;h4 id=&#34;规则声明&#34;&gt;规则声明&lt;/h4&gt;
&lt;p&gt;我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.listing {
  font-size: 18px;
  line-height: 1.2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;选择器&#34;&gt;选择器&lt;/h4&gt;
&lt;p&gt;在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.my-element-class {
  /* ... */
}

[aria-hidden] {
  /* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;属性&#34;&gt;属性&lt;/h4&gt;
&lt;p&gt;最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* some selector */ {
  background: #f1f1f1;
  color: #333;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;css格式&#34;&gt;CSS格式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用 2 个空格作为缩进。&lt;/li&gt;
&lt;li&gt;类名建议使用破折号代替驼峰法。如果你使用 BEM，也可以使用下划线（参见下面的 &lt;a href=&#34;#oocss-and-bem&#34;&gt;OOCSS 和 BEM&lt;/a&gt;）。&lt;/li&gt;
&lt;li&gt;不要使用 ID 选择器。&lt;/li&gt;
&lt;li&gt;在一个规则声明中应用了多个选择器时，每个选择器独占一行。&lt;/li&gt;
&lt;li&gt;在规则声明的左大括号 { 前加上一个空格。&lt;/li&gt;
&lt;li&gt;在属性的冒号 : 后面加上一个空格，前面不加空格。&lt;/li&gt;
&lt;li&gt;规则声明的右大括号 } 独占一行。&lt;/li&gt;
&lt;li&gt;规则声明之间用空行分隔开。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;bad&#34;&gt;Bad&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.avatar{
    border-radius:50%;
    border:2px solid white; }
.no, .nope, .not_good {
    // ...
}
#lol-no {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;good&#34;&gt;Good&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.avatar {
  border-radius: 50%;
  border: 2px solid white;
}

.one,
.selector,
.per-line {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注释&#34;&gt;注释&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;建议使用行注释 (在 Sass 中是 //) 代替块注释。&lt;/li&gt;
&lt;li&gt;建议注释独占一行。避免行末注释。&lt;/li&gt;
&lt;li&gt;给没有自注释的代码写上详细说明，比如：&lt;br&gt;
为什么用到了 z-index&lt;br&gt;
兼容性处理或者针对特定浏览器的 hack&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;id-选择器&#34;&gt;ID 选择器&lt;/h3&gt;
&lt;p&gt;在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高优先级，而且 ID 选择器是不可重用的。&lt;/p&gt;
&lt;p&gt;想要了解关于这个主题的更多内容，参见 &lt;a href=&#34;https://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/&#34;&gt;CSS Wizardry&lt;/a&gt; 的文章，文章中有关于如何处理优先级的内容。&lt;/p&gt;
&lt;h3 id=&#34;javascript-钩子&#34;&gt;JavaScript 钩子&lt;/h3&gt;
&lt;p&gt;避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。&lt;/p&gt;
&lt;p&gt;我们推荐在创建用于特定 JavaScript 的类名时，添加 .js- 前缀：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;button class=&amp;quot;btn btn-primary js-request-to-book&amp;quot;&amp;gt;Request to Book&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;边框&#34;&gt;边框&lt;/h3&gt;
&lt;p&gt;在定义无边框样式时，使用 0 代替 none。&lt;/p&gt;
&lt;h4 id=&#34;bad-2&#34;&gt;Bad&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.foo {
  border: none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;good-2&#34;&gt;Good&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.foo {
  border: 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;sass&#34;&gt;Sass&lt;/h3&gt;
&lt;p&gt;语法&lt;br&gt;
使用 .scss 的语法，不使用 .sass 原本的语法。&lt;br&gt;
CSS 和 @include 声明按照以下逻辑排序（参见下文）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;a name=&amp;quot;ordering-of-property-declarations&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;属性声明的排序&#34;&gt;属性声明的排序&lt;/h3&gt;
&lt;h4 id=&#34;属性声明&#34;&gt;属性声明&lt;/h4&gt;
&lt;p&gt;首先列出除去 @include 和嵌套选择器之外的所有属性声明。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.btn-green { background: green; font-weight: bold; // ... }&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;include-声明&#34;&gt;@include 声明&lt;/h4&gt;
&lt;p&gt;紧随后面的是 @include，这样可以使得整个选择器的可读性更高。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.btn-green { background: green; font-weight: bold; @include transition(background 0.5s ease); // ... }&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;嵌套选择器&#34;&gt;嵌套选择器&lt;/h4&gt;
&lt;p&gt;_如果有必要_用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。&lt;/p&gt;
&lt;p&gt;` .btn { background: green; font-weight: bold; @include transition(background 0.5s ease);&lt;/p&gt;
&lt;p&gt;.icon { margin-right: 10px; } } `&lt;/p&gt;
&lt;h3 id=&#34;变量&#34;&gt;变量&lt;/h3&gt;
&lt;p&gt;变量名应使用破折号（例如 $my-variable）代替 camelCased 和 snake_cased 风格。对于仅用在当前文件的变量，可以在变量名之前添加下划线前缀（例如 $_my-variable）。&lt;/p&gt;
&lt;h3 id=&#34;mixins&#34;&gt;Mixins&lt;/h3&gt;
&lt;p&gt;为了让代码遵循 DRY 原则（Don&#39;t Repeat Yourself）、增强清晰性或抽象化复杂性，应该使用 mixin，这与那些命名良好的函数的作用是异曲同工的。虽然 mixin 可以不接收参数，但要注意，假如你不压缩负载（比如通过 gzip），这样会导致最终的样式包含不必要的代码重复。&lt;/p&gt;
&lt;h3 id=&#34;扩展指令&#34;&gt;扩展指令&lt;/h3&gt;
&lt;p&gt;应避免使用 @extend 指令，因为它并不直观，而且具有潜在风险，特别是用在嵌套选择器的时候。即便是在顶层占位符选择器使用扩展，如果选择器的顺序最终会改变，也可能会导致问题。（比如，如果它们存在于其他文件，而加载顺序发生了变化）。其实，使用 @extend 所获得的大部分优化效果，gzip 压缩已经帮助你做到了，因此你只需要通过 mixin 让样式表更符合 DRY 原则就足够了。&lt;/p&gt;
&lt;h3 id=&#34;嵌套选择器-2&#34;&gt;嵌套选择器&lt;/h3&gt;
&lt;p&gt;请不要让嵌套选择器的深度超过 3 层！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sass&#34;&gt;.page-container {
  .content {
    .profile {
      // STOP!
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当遇到以上情况的时候，你也许是这样写 CSS 的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与 HTML 强耦合的（也是脆弱的）&lt;em&gt;—或者—&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;过于具体（强大）&lt;em&gt;—或者—&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;没有重用&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;再说一遍-永远不要嵌套-id-选择器-永远不要嵌套-id-选择器-永远不要嵌套-id-选择器&#34;&gt;再说一遍: 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！&lt;/h5&gt;
&lt;p&gt;如果你始终坚持要使用 ID 选择器（劝你三思），那也不应该嵌套它们。如果你正打算这么做，你需要先重新检查你的标签，或者指明原因。如果你想要写出风格良好的 HTML 和 CSS，你是不应该这样做的。&lt;/p&gt;
">Airbnb CSS / Sass 规范指南</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/qian-duan-chang-yong-de-ming-ming-gui-fan"" data-c="
          &lt;ul&gt;
&lt;li&gt;目录 全小写中划线&lt;/li&gt;
&lt;li&gt;文件 全小写中划线&lt;/li&gt;
&lt;li&gt;类名 大驼峰&lt;/li&gt;
&lt;li&gt;变量 小驼峰&lt;/li&gt;
&lt;li&gt;常量 全大写 下划线风格&lt;/li&gt;
&lt;li&gt;特殊变量&lt;/li&gt;
&lt;li&gt;css类名 小写中划线&lt;/li&gt;
&lt;li&gt;单词拼音不允许&lt;/li&gt;
&lt;li&gt;复杂函数和公用函数必须加注释&lt;/li&gt;
&lt;li&gt;函数的参数最多不能超过三个&lt;/li&gt;
&lt;li&gt;url 全小写 中划线&lt;/li&gt;
&lt;/ul&gt;
">前端常用的命名规范</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/pu-bu-liu-ji-suan-js-yuan-ma"" data-c="
          &lt;p&gt;遇到问题时的解决方法及使用注意事项：&lt;/p&gt;
&lt;p&gt;1、下拉刷新会导致瀑布流顺序错乱，重新new一下瀑布流即可。&lt;/p&gt;
&lt;p&gt;2、图片宽高必须要让服务端返，前端去获取数据太多会导致性能非常慢。&lt;/p&gt;
&lt;p&gt;3、dom加载时获取小程序的某个dom的宽度（列宽）为空，放在wx.nextTick中即可。还获取不到，就需要看自己要获取的dom是否已加载。&lt;/p&gt;
&lt;p&gt;4、此代码抗揍，如果出问题先从自身找问题，再仔细阅读一遍此代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Waterfall {
  constructor(options) {
    this.initWaterfall(options);
  }
    /**
   * 初始化瀑布流
   * @param {Object} options
   * @param {Array&amp;lt;Object&amp;gt;} options.columns {width} - 此参数主要定义每列的宽度
   */
  initWaterfall(options) {
    this.columns = options.columns;
    this.formatedData = [];
    for (let column of options.columns) {
      this.formatedData.push({
        width: column.width,
        height: 0
      });
    }
  }
  imageUrlFeild = &#39;imageUrl&#39;
 
  /**
   * 格式化从数据中获取图片url的方法
   * @param {Function | String | Number} fn - 若为函数，则需要返回瀑布流每项数据对应的图片字段
   */
 
  formatGetImageUrlMethod(fn) {
    this.imageUrlFeild = typeof fn === &#39;function&#39; ? fn() : fn
  }
 
  /**
   * 向瀑布流中填充数据
   * @param {Object}  resource - 单个瀑布流项的数据源
   */
  getResourceInfo(resource) {
    const _self = this
    return new Promise(resolve =&amp;gt; {
      if (resource[_self.imageUrlFeild]) {
        // getImageInfo方法在小程序中使用，h5中暂未测试，不过一般都是让服务端直接返回图片宽高，所以这个方法一般用不到，如果需要用到的话，必须加一层loading阻止用户操作
        wx.getImageInfo({
          src: resource[_self.imageUrlFeild],
          success(res) {
            resolve(res)
          },
          fail() {
            resolve()
          }
        })
      } else {
        resolve()
      }
    })
  }
 
  /**
   * 向瀑布流中补充数据
   * @param {Boolean} extraVal 瀑布流的卡片中图片之外的内容
   * @param {Array&amp;lt;resource&amp;gt;}  resources
   */
 
  async addResources(resources, extraVal) {
    // let promiseArray = []
    let newResourcesArray = Array.apply(null, Array(this.columns.length)).map(
      _ =&amp;gt; []
    )
    for (let resource of resources) {
      // promiseArray.push(this.getResourceInfo(resource))
      // let imageInfo
      // imageInfo = await this.getResourceInfo(resource)
      const width = Number(resource.width) || 100;
      const height = Number(resource.height) || 100;
      // 获取最短列的索引
      const index = this.getShortestColumn();
      // 卡片宽度
      const imageWidth = this.formatedData[index].width;
      // 附加的卡片高度在这里是写死的，每个项目会有不同高度
      const extraHeight = extraVal ? extraVal : 0;
      // 获取卡片高度
      const cardHeight = imageWidth / (width / height) + extraHeight;
      // 当前列总高度
      this.formatedData[index].height += cardHeight;
      // 返回卡片高度
      resource.cardHeight = cardHeight;
      // 返回图片高度
      resource.computedHeight = cardHeight - extraVal;
      // 返回当前列的数组
      newResourcesArray[index].push(resource);
    }
    return newResourcesArray
  }
 
  /**
   * 最重要的地方
   * 获取当前数据中填充最短的列
   * 返回最短列的索引
   */
  getShortestColumn() {
    let minHeight = Infinity
    let minHeightColumnIndex = 0
    for (let index = this.formatedData.length - 1; index &amp;gt; -1; index--) {
      //从后往前遍历，防止每列的高度相同的情况
      const height = this.formatedData[index].height
      if (height &amp;lt;= minHeight) {
        minHeightColumnIndex = index
        minHeight = height
      }
    }
    return minHeightColumnIndex
  }
}
 
export default Waterfall;
 
 
// 例：双列瀑布流
let newList = new Waterfall({
      columns: [
        {
          width: 列宽
        },
        {
          width: 列宽
        }
      ]
    });
newList.addResources(lists, 卡片内除图片的额外高度).then(res =&amp;gt; {});
&lt;/code&gt;&lt;/pre&gt;
">瀑布流计算js源码</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/taro-xiao-cheng-xu-zhi-bo-zu-jian-liveplayer-zhu-yi-shi-xiang"" data-c="
          &lt;h3 id=&#34;1-直播组件优先开通实时音频和视频管理后台申请对应的证书&#34;&gt;1、直播组件优先开通实时音频和视频（管理后台），申请对应的证书&lt;/h3&gt;
&lt;h3 id=&#34;2-直播组件需要做系统权限验证麦克风和相机引导用户打开权限不然部分手机加载失败-insertliveplayerfailaccess-denied-因为权限有三个状态undefined-denied-authorizedauthorized代表系统权限已开&#34;&gt;2、直播组件需要做【系统】权限验证，（麦克风和相机）,引导用户打开权限，不然部分手机加载失败（ insertLivePlayer:fail:access denied） 因为权限有三个状态(undefined、denied、authorized)，authorized代表系统权限已开&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;export const getSystemInfo = (keys: Tkey[], content = &#39;&#39;) =&amp;gt; {
  return new Promise((resolve) =&amp;gt; {
    const systemInfo = wx.getAppAuthorizeSetting();
    console.log(&#39;system&#39;, systemInfo);
    if (!systemInfo) {
      return resolve({ code: -1, msg: &#39;获取系统权限失败~&#39; });
    }
    keys.forEach((item) =&amp;gt; {
      if (systemInfo[item] !== &#39;authorized&#39;) {
        Taro.showModal({
          content,
          success: (res) =&amp;gt; {
            if (res.confirm) {
              wx.openAppAuthorizeSetting({
                success: () =&amp;gt; {
                  return resolve({ code: 100, msg: &#39;打开系统授权页成功~&#39; });
                },
                fail: () =&amp;gt; {
                  return resolve({ code: 101, msg: &#39;打开系统授权页失败~&#39; });
                }
              });
            } else {
              return resolve({ code: 403, msg: &#39;用户点击取消~&#39; });
            }
          }
        });
        return resolve({ code: 401, msg: &#39;权限没打开~&#39; });
      }
    });
    return resolve({ code: 0, msg: &#39;用户已开通对应权限~&#39; });
  });
};
 
// 获取系统权限
      const res: any = await getSystemInfo(
        [&#39;cameraAuthorized&#39;, &#39;microphoneAuthorized&#39;],
        &#39;检测到您没有打开麦克风和相机权限，部分功能将没法使用~&#39;
      );
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-直播组件同层渲染在全屏下失效需要单独处理全屏做coverviewcoverimage做原生覆盖能力处理不是全屏就同层渲染全屏处理时候顶层容器和直接子节点需要设置-visiblityvisiblepositionrelativez-index99999-必须得处理不然android-的coverview覆盖不了原生直播组件&#34;&gt;3、直播组件同层渲染在全屏下失效，需要单独处理，全屏做CoverView\CoverImage做原生覆盖能力处理，不是全屏就同层渲染，全屏处理时候顶层容器和直接子节点需要设置 visiblity:visible;position:relative;z-index:99999; 必须得处理，不然android 的CoverView覆盖不了原生直播组件。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;.cover-main{
    position: absolute;
    visibility: visible;
    z-index: 999999;
}
 
&amp;lt;CoverView className={style[&#39;cover-main&#39;]}&amp;gt;
                &amp;lt;CoverView className={style[&#39;cover-main&#39;]}&amp;gt;
                  &amp;lt;CoverView className={style[&#39;live-control&#39;]} onClick={showTips}&amp;gt;&amp;lt;/CoverView&amp;gt;
 
        {fullScreenFlag &amp;amp;&amp;amp; (
        &amp;lt;&amp;gt;
            {/*广告*/}
            &amp;lt;Curtain /&amp;gt;

            {/* 封面*/}
            {startStatus === false ? (
            &amp;lt;CoverView className={style.cannot_see}&amp;gt;
                &amp;lt;CoverImage className={style.cannot_see_img} src={readyImg}&amp;gt;&amp;lt;/CoverImage&amp;gt;
            &amp;lt;/CoverView&amp;gt;
            ) : teachStatus === false ? (
            &amp;lt;CoverView className={style.cannot_see}&amp;gt;
                &amp;lt;CoverImage className={style.cannot_see_img} src={outImg}&amp;gt;&amp;lt;/CoverImage&amp;gt;
            &amp;lt;/CoverView&amp;gt;
            ) : null}

            {/* 倒计时*/}
            {time &amp;gt;= 1800 ? &amp;lt;CountDown time={time} /&amp;gt; : null}
        &amp;lt;/&amp;gt;
        )}

        {/*控制*/}
        &amp;lt;CoverView
        className={`${style.control} ${tips ? style[&#39;up-ani&#39;] : style[&#39;down-ani&#39;]}`}
        &amp;gt;
        &amp;lt;CoverView className={style.info}&amp;gt;
            &amp;lt;CoverView&amp;gt;直播&amp;lt;/CoverView&amp;gt;
        &amp;lt;/CoverView&amp;gt;
        &amp;lt;CoverView className={style[&#39;full-screen&#39;]} onClick={handleFullScreen}&amp;gt;
            &amp;lt;CoverImage
            className={style.icon}
            src={fullScreenFlag ? tuichuquanping : quanping}
            &amp;gt;&amp;lt;/CoverImage&amp;gt;
            &amp;lt;CoverView&amp;gt;{fullScreenFlag ? &#39;小屏播放&#39; : &#39;全屏播放&#39;}&amp;lt;/CoverView&amp;gt;
        &amp;lt;/CoverView&amp;gt;
        &amp;lt;/CoverView&amp;gt;
    &amp;lt;/CoverView&amp;gt;
    &amp;lt;/CoverView&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">Taro 小程序直播组件 LivePlayer 注意事项</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1644219568486.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上面是一个使用脚手架来初始化项目的典型例子。&lt;br&gt;
随着前端工程化的理念不断深入，越来越多的人选择使用脚手架来从零到一搭建自己的项目。其中大家最熟悉的就是create-react-app和vue-cli，它们可以帮助我们初始化配置、生成项目结构、自动安装依赖，最后我们一行指令即可运行项目开始开发，或者进行项目构建（build）。&lt;br&gt;
这些脚手架提供的都是普遍意义上的最佳实践，但是我在开发中发现，随着业务的不断发展，必然会出现需要针对业务开发的实际情况来进行调整。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;项目架构的配置&lt;br&gt;
a. webpack/gulp的配置&lt;br&gt;
ⅰ. style/less/sass的选择和处理配置。&lt;br&gt;
ⅱ. Typescript和JavaScript的loader和babel的配置，比如babel-loader和tsc。&lt;br&gt;
ⅲ. 图片的配置，比如需要file-loader或者url-loader。&lt;br&gt;
ⅳ. 静态资源的配置。&lt;br&gt;
ⅴ. 企业内部，真对于某些特定功能的webpack-loader/webpack-plugin，比如打包完图片上传。&lt;br&gt;
b. 是否内置一些第三方框架供上手使用，比如Element-UI，Antd等。&lt;br&gt;
c. 项目的路由的设计和配置。&lt;br&gt;
d. 项目目录结构的设计和配置。&lt;br&gt;
e. 项目通用功能的有关代码，比如登陆和欢迎页等。&lt;br&gt;
f.通过调整插件与配置实现 Webpack 打包性能优化&lt;br&gt;
g.针对生产环境做的单独处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目开发中的配置&lt;br&gt;
a. eslint。&lt;br&gt;
b. style-lint。&lt;br&gt;
c. prettier。&lt;br&gt;
d. 单元测试jest或者其他单元测试框架。&lt;br&gt;
e. 项目文档的自动生成，比如docz。&lt;br&gt;
f. git相关的，比如git提交的校验，生成changelog&lt;br&gt;
g. npm相关，除非是开发npm包，否则npm相关的不是那么重要&lt;br&gt;
h. 与开发有关的工具，比如打包构建结果的包分析、比如相似代码自动生成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目上线脚本，这个应该是可选项？更优的方法应该是使用内部的例如发布平台之类的工具完成，或者通过jekins或者gitlab-ci进行自动化发布，回滚等操作。上线发布回滚的动作可以完全交给非开发人员完成。&lt;br&gt;
a. 比如由nodejs编写的上线脚本，或者是用于上线的shell脚本。&lt;br&gt;
b. gitlab-ci的配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;……&lt;br&gt;
总而言之，随着业务发展，我们往往会沉淀出一套更“个性化”的业务方案。这时候我们最直接的做法就是开发出一个该方案的脚手架来，以便今后能复用这些最佳实践与方案。&lt;br&gt;
那么就需要使用一个工具来帮我们做这些处理，我们使用的就是yoman。&lt;a href=&#34;https://yeoman.io/&#34;&gt;官网地址&lt;/a&gt;&lt;br&gt;
我们可以使用yeoman和yeoman的generator来更加便捷实现我们的脚手架，可以说基本是零成本。&lt;br&gt;
先说说Yeoman是什么，它想做什么？&lt;br&gt;
Yeamon帮助你快速的开展一个项目工程，提供最佳实践和工具，来让你保持高效率编码。&lt;/p&gt;
&lt;p&gt;他们自己提供了一个构建生态系统，主要通过‘yo’这个命令来构建一个完整的项目或者项目的一部分。&lt;/p&gt;
&lt;p&gt;通过官方的生成器，他们建立了一个Yeoman的工作流，这个流是由一个强大的,固定的客户端组建，包含工具和框架帮助开发者快速建立牛逼的web应用。他们尽量提供了开发者所需的东西。比如先下载对应模版项目，然后下载模版项目中的package.json中的包&lt;/p&gt;
&lt;p&gt;作为良好文档和深入思考构建过程的思想者，Yeoman包含了检测（静态检测）、测试以及压缩等等一系列工具，让开发者能够更加专注于思考解决方案。&lt;/p&gt;
&lt;h3 id=&#34;如何使用&#34;&gt;如何使用：&lt;/h3&gt;
&lt;p&gt;1、npm install -g yo //权限不够，请加上 sudo，一般来说mac都需要。&lt;br&gt;
安装完成之后，你就拥有了1个命令 -- yo 可以选择自定义的，也可以搜索你想要的现成的，这里我们选择自己的。 官网提供的地址：http://yeoman.io/generators/&lt;br&gt;
那我们开始编写一个自己的generators。&lt;br&gt;
2、开发自己的generator&lt;br&gt;
创建项目&lt;br&gt;
全局安装generator-generator，然后使用创建项目，根据提示输出我们的generator项目的名字，yeoman规定项目名字必须以generator开头，所以我们可以选择generator-xxx作为我们的项目名&lt;br&gt;
npm i -g generator-generator&lt;br&gt;
yo generator&lt;br&gt;
创建好项目之后，我们可以发现已经自动为我们配置好了eslint，jest，husky&lt;/p&gt;
&lt;p&gt;我们主要需要修改的代码位于generators/app内&lt;br&gt;
● index.js定义了我们使用此generator时的一些操作配置项&lt;br&gt;
● templates内存放的是要生成的项目的项目模板，项目模板也可以放在git上，然后通过download-git-repo下载到本地&lt;br&gt;
验证我们创建的项目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在当前项目执行npm link使其被链接到全局&lt;/li&gt;
&lt;li&gt;然后找一个目录，终端执行yo，此时便可以发现我们的generator已经出现在了选择列表中。然后选择我们的generator运行即可。等待完成，会发现成功的创建了一个叫做dummyfile.txt的文件夹。&lt;br&gt;
generators/app/index.js&lt;br&gt;
初始化的文件如下。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;use strict&amp;quot;;
const Generator = require(&amp;quot;yeoman-generator&amp;quot;);
const chalk = require(&amp;quot;chalk&amp;quot;);
const yosay = require(&amp;quot;yosay&amp;quot;);

module.exports = class extends Generator {
  prompting() {
    // Have Yeoman greet the user.
    this.log(
      yosay(
        `Welcome to the fantastic ${chalk.red(&amp;quot;generator-rc-op&amp;quot;)} generator!`
      )
    );

    const prompts = [
      {
        type: &amp;quot;confirm&amp;quot;,
        name: &amp;quot;someAnswer&amp;quot;,
        message: &amp;quot;Would you like to enable this option?&amp;quot;,
        default: true
      }
    ];

    return this.prompt(prompts).then(props =&amp;gt; {
      // To access props later use this.props.someAnswer;
      this.props = props;
    });
  }

  writing() {
    this.fs.copy(
      this.templatePath(&amp;quot;dummyfile.txt&amp;quot;),
      this.destinationPath(&amp;quot;dummyfile.txt&amp;quot;)
    );
  }

  install() {
    this.installDependencies();
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从文件的内容可以看出主要操作是暴露出一个继承自Generator的类，在类的内部定义了部分生命周期方法，供yoeman在适当的时候调用。我们只需要完善这些方法就可以了。&lt;/p&gt;
&lt;h3 id=&#34;yeoman提供的生命周期如下&#34;&gt;yeoman提供的生命周期如下：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;initializing：初始化必要的依赖，或者比如检测新版本&lt;/li&gt;
&lt;li&gt;prompting：用来处理终端的交互&lt;/li&gt;
&lt;li&gt;default：这里指的是自己自定义的方法，而不是名为default的方法，自己定义的方法如果不想被调用，那么需要确保方法名以_为开头。&lt;/li&gt;
&lt;li&gt;writing：将经过ejs模板渲染后的内容写入文件系统。&lt;/li&gt;
&lt;li&gt;conflicts：勇于解决将文件内容写入文件系统时可能造成的冲突&lt;/li&gt;
&lt;li&gt;install：安装项目的依赖，比如npm install 或者 bower install&lt;/li&gt;
&lt;li&gt;end：做一些收尾的工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些生命周期方法均支持返回Promise来进行异步操作。&lt;/p&gt;
&lt;h3 id=&#34;内置常用工具&#34;&gt;内置常用工具&lt;/h3&gt;
&lt;p&gt;终端交互：内置了Inquirer提供终端交互&lt;br&gt;
模板填充：内置了ejs模板&lt;br&gt;
文件操作&lt;br&gt;
● this.fs.copyTpl：用于拷贝并且根据数据使用ejs模板渲染文件。此函数接受三个参数，源文件路径，目标文件路径，传给ejs用于渲染目标问价的数据。&lt;br&gt;
● this.fs.copy：将文件丛源路径复制到目标路径。&lt;br&gt;
● this.destinationPath() ：此函数返回最终生成项目的路径&lt;br&gt;
其他&lt;br&gt;
● this.npmInstall：实现npm isntall&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 部分代码，完整代码见最下方链接
writing() {
    const done = this.async();
    this.log(&amp;quot;⚙  Finish basic configuration.&amp;quot;, chalk.green(&amp;quot;✔&amp;quot;));
    this.log(&amp;quot;📂 Generate the project template and configuration...&amp;quot;);
    let spinner = ora({
      text: `Download the template from ${GIT_BASE}${TPL_REPOSITORY}...`,
      spinner: ORA_SPINNER
    }).start();
    this._downloadTemplate(TPL_REPOSITORY)
      .then(() =&amp;gt; {
        spinner.stopAndPersist({
          symbol: chalk.green(&amp;quot;   ✔&amp;quot;),
          text: `Finish downloading the template from ${GIT_BASE}${TPL_REPOSITORY}`
        });
        spinner = ora({
          text: `Copy files into the project folder...`,
          spinner: ORA_SPINNER
        }).start();
        const templateRoot = this.destinationPath(this.dirName, &amp;quot;.tmp&amp;quot;);
        this.log(`\n${templateRoot}`, &amp;quot;templateRoot&amp;quot;);
        const resoPath = path.resolve(templateRoot, &amp;quot;../&amp;quot;);
        this.log(resoPath, &amp;quot;resoPath&amp;quot;);
        spinner.stopAndPersist({
          symbol: chalk.green(&amp;quot;   ✔&amp;quot;),
          text: `Finish copying files into the project folder`
        });
        execSync(`cp -R ${resoPath}/.tmp/* ${resoPath}`, { stdio: &amp;quot;inherit&amp;quot; });
        spinner = ora({
          text: `Clean tmp files and folders...`,
          spinner: ORA_SPINNER
        }).start();
        fs.removeSync(templateRoot);
        spinner.stopAndPersist({
          symbol: chalk.green(&amp;quot;   ✔&amp;quot;),
          text: `Finish cleaning tmp files and folders`
        });
        // ExecSync(`rm -R ${resoPath}/.tmp`, { stdio: &amp;quot;inherit&amp;quot; });
        // 将新生成的项目的title换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/public/index.html`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&amp;gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/public/index.html`, str);
          }
        );
        // 将新生成的项目的package.json的name换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/package.json`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&amp;gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/package.json`, str);
          }
        );
        done();
      })
      .catch(err =&amp;gt; this.env.error(err));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;其他可能用到的工具&#34;&gt;其他可能用到的工具&lt;/h3&gt;
&lt;p&gt;● ora：用于创建Spinner，即比如下载模板文件时需要展示的laoding效果。&lt;br&gt;
● chalk：用于打印彩色的信息&lt;br&gt;
● update-notifier&lt;br&gt;
● beeper&lt;br&gt;
● boxen&lt;br&gt;
调试&lt;br&gt;
由于yeoman是通过npm包的形式进行使用的，所以我们可以在我们开发的generator项目的跟目录下，执行npm link 将我们开发的generator链接到全局，这样我们直接使用yo命令查看可以使用的generator，就可以看到我们所开发的generator了，并且是实时生效的&lt;/p&gt;
&lt;h3 id=&#34;我的代码是在本地的用的npm-link没有上传到github或npm此处贴出其他大佬的项目代码-快动手试一下吧~&#34;&gt;我的代码是在本地的，用的npm link，没有上传到github或npm，此处贴出其他大佬的项目代码。快动手试一下吧～&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/alienzhou/webpack-kickoff-template&#34;&gt;模版完整代码&lt;/a&gt;   注意要给ejs写入的空位&lt;br&gt;
&lt;a href=&#34;https://github.com/alienzhou/generator-webpack-kickoff&#34;&gt;脚手架完整代码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;参考文章&#34;&gt;参考文章：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.yuque.com/kongdepeng/rgpm60/qrluup&#34;&gt;前端自动化工具 - yeoman&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/66190308&#34;&gt;如何快速开发一个自己的项目脚手架？&lt;/a&gt;&lt;/p&gt;
">用yeoman开发一个自己的项目脚手架</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie"" data-c="
          &lt;p&gt;开发C端时遇到的一些问题与解决方法，都记录下来，希望对你也有帮助。&lt;/p&gt;
&lt;h3 id=&#34;1部分机型拍照上传图片旋转问题&#34;&gt;1.部分机型拍照上传图片旋转问题：&lt;/h3&gt;
&lt;p&gt;直接从图片后面加参数‘?x-oss-process=image/auto-orient,1/resize,m_fixed’（加上参数之后会自动旋转回来，其他参数可参考阿里OSS官方文档https://help.aliyun.com/document_detail/44691.html?spm=a2c4g.11186623.6.1390.750ac1f6HTe92Q）&lt;/p&gt;
&lt;h3 id=&#34;2swiper3d两边留白效果&#34;&gt;2.swiper3D两边留白效果：&lt;/h3&gt;
&lt;p&gt;（小程序h5均适用），代码如下，需要注意的是必须给swiper父级元素加overflow-x:hidden&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.swiper-container {
  height: 100%;
  width: 600px;
  perspective: 1600px;
  overflow: visible;
  img {
    width: 100%;
    height: 720px;
    border-radius: 20px;
  }
}
.swiper-slide {
  padding: 0 24px;
  box-sizing: border-box;
  text-align: center;
  transition: transform 0.5s;
  transform-origin: 50% 50%;
  transform: scale(0.9);
  &amp;amp;.swiper-slide-active {
    transform: scale(1);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3小程序的跳转十层限制不要一直用navigateto这样属于一直前进如果需要跳转回首页或者其他可以使用relaunch逻辑复杂时可自己写顶部导航栏包括返回按钮&#34;&gt;3.小程序的跳转十层限制，不要一直用navigateTo，这样属于一直前进，如果需要跳转回首页或者其他可以使用reLaunch，逻辑复杂时可自己写顶部导航栏包括返回按钮。&lt;/h3&gt;
&lt;h3 id=&#34;4保存海报到本地推荐一波生成小程序海报的插件非常简单方便&#34;&gt;4.保存海报到本地：推荐一波生成小程序海报的插件，非常简单方便&lt;/h3&gt;
&lt;p&gt;taro-plugin-canvas (Taro环境使用)与wxa-plugin-canvas（普通小程序使用）&lt;br&gt;
tip:如果遇到非常规的情况，需要手写canvas并且宽高尺寸乘2保证清晰度。&lt;/p&gt;
&lt;h3 id=&#34;5input光标永远停留在最后&#34;&gt;5.input光标永远停留在最后：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var el = document.getElementById(&amp;quot;IPTname&amp;quot;);
var range = document.createRange();
range.selectNodeContents(el);
range.collapse(false);
var sel = window.getSelection();
sel.removeAllRanges();
sel.addRange(range);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6小程序获取用户授权用户信息用户定位用户相册访问权限等时需要处理拒绝时的情况-生成海报到自己相册的时候如果用户在授权的时候点击了拒绝如果不兼容拒绝授权则直接生成失败&#34;&gt;6.小程序获取用户授权（用户信息/用户定位/用户相册访问权限等）时需要处理拒绝时的情况。生成海报到自己相册的时候如果用户在授权的时候点击了拒绝，如果不兼容拒绝授权则直接生成失败。&lt;/h3&gt;
&lt;h3 id=&#34;7监听移动端键盘弹出和收起事件&#34;&gt;7.监听移动端键盘弹出和收起事件。&lt;/h3&gt;
&lt;p&gt;在ios设备上,操作表单输入时,键盘弹出时会把页面顶起来,键盘收起时并不会把页面恢复成原来的样子,造成页面样式错乱,利用focusout和focusin事件,可以间接地监听到键盘的收起和弹出事件,然后操作页面滚动到想要的位置.&lt;/p&gt;
&lt;p&gt;focusout触发时机:  当元素即将失去焦点时，focusout 事件被触发。focusout 事件和 blur 事件之间的主要区别在于后者不会冒泡。&lt;/p&gt;
&lt;p&gt;focusin触发时机:    当元素即将接收 focus 事件时，focusin 事件被触发。 这个事件和 focus 事件的主要区别在于后者不会冒泡。&lt;/p&gt;
&lt;p&gt;监听方式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let scrollTop = 0
//键盘收起
document.body.addEventListener(&#39;focusout&#39;,()=&amp;gt;{
   document.body.scrollTop=document.documentElement.scrollTop=scrollTop
})
//键盘弹出
document.body.addEventListener(&#39;focusin&#39;,()=&amp;gt;{
   scrollTop = document.body.scrollTop || document.documentElement.scrollTop
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;8移动端代码返回上一页windowlocationback失效&#34;&gt;8.移动端代码返回上一页（window.location.back()失效）&lt;/h3&gt;
&lt;p&gt;尼玛。。移动端返回上一页有时候用window.location.back()不好使，无解。可以使用window.location.href = document.referrer。&lt;/p&gt;
&lt;h3 id=&#34;9单页面应用跳转路由之后再次使用echarts时不展示&#34;&gt;9.单页面应用跳转路由之后再次使用echarts时不展示&lt;/h3&gt;
&lt;p&gt;首次使用不展示，可以延迟加载，但是当路由跳转回来之后延迟都不管用，那么需要在init Echarts之前动态设置容器宽高，并且清空父元素，因为再次回来的时候之前的echarts实例已经是存在的了，可在调试中查看详情。&lt;/p&gt;
&lt;h3 id=&#34;10-视频黑边问题&#34;&gt;10. 视频黑边问题&lt;/h3&gt;
&lt;p&gt;给video标签（原生video标签）加一个object-fit:fill属性即可解决。要强调的是，千万不要使用Taro的Video标签，很坑，解决了黑边，全屏时又会导致视频变形，不用object:fill的话也能解决黑边，但是全屏时视频的退出全屏样式又会被覆盖。&lt;/p&gt;
&lt;h3 id=&#34;11-手机锁屏时倒计时停止&#34;&gt;11. 手机锁屏时倒计时停止&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;window.addEventListener(&#39;visibilitychange&#39;,() =&amp;gt; {
   if (
     //hidden为锁屏时或页面不展示时，可重新获取时间开始倒计时。
      document.visibilityState ==&#39;hidden&#39;
   ) 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12移动端实现省-市-区-街道四级联动&#34;&gt;12.移动端实现省-市-区-街道四级联动&lt;/h3&gt;
&lt;p&gt;需求是要实现地区四级联动，但是vant的插件只支持三级地区联动，就很尴尬，只能自己写，但是自己写的话UI与交互体验会很差，所以就想办法去和后端对接。其实很简单，写出来只是提醒大家可以这么实现，减少思考与踩坑的时间。三级联动选择完之后会返回地区编码，eg:Array&amp;lt;{code:&#39;110101&#39;,name:&#39;东城区&#39;}&amp;gt;,然后去请求后端的接口将地区编码传过去，就能得到其街道的相关信息，然后简单过滤一下，放在Picker选择器中就可以实现。接下来就可以写业务逻辑了。&lt;/p&gt;
&lt;h3 id=&#34;13ios内webview中vue项目会出现大块白色遮罩&#34;&gt;13.ios内webview中vue项目会出现大块白色遮罩&lt;/h3&gt;
&lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;A页面——&amp;gt;B页面——&amp;gt;ios自带的返回——&amp;gt;白屏出现(像个魔鬼)——&amp;gt;点击或滑动页面——&amp;gt;问题解决&lt;/p&gt;
&lt;p&gt;原因是，经过排查，发现在ios 机器上使用webview 开发Vue项目时候，go history (-1)，无法将body 的高度拉掉，使得遮住，触发轻点击，方可消除该遮罩&lt;/p&gt;
&lt;p&gt;解决的理论：用于最重要的html 容器是container，然而因为设置html、body高度是100%，从而造成了 container 撑开父级，但浏览器默认滚动的scroll 并不是 container，而是body，某些因素，造成返回history 后，无法复原（ios 的锅），为此，将 container(app.vue中包裹的div，也可以是#app) 进行了绝对定位，并让它重新成为 scroll 的对象，从而解决问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;html, body {

 width: 100%;

 height: 100%;
 min-height: 100vh;

 margin: 0;

 padding: 0;

 position: relative;

}

.container {

 width: 100%;

height: 100vh;
 min-height: 100vh;

 background: #fff;

 overflow: scroll;

 -webkit-overflow-scrolling: touch;

 position: absolute;

 left:0;

 top:0;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14在ios上a页面分享朋友圈之后跳转到-b-页面或进行别的操作&#34;&gt;14.在ios上A页面分享朋友圈之后，跳转到 B 页面（或进行别的操作）&lt;/h3&gt;
&lt;p&gt;注：离开 app的 A 页面去微信，再次回到 app 的时候跳转到 B 页面&lt;/p&gt;
&lt;p&gt;visibilitychange：当用户最小化窗口或者切换选项卡的时候，api 就会发送visibilitychange事件，让开发者知道页面状态已更改。你可以检测事件并执行某些操作或行为。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//这个方法在分享被触发的时候执行
initVisibilityChange() {
      if (typeof document.visibilityState != &amp;quot;undefined&amp;quot;) {
        this.visibleChange = &amp;quot;visibilitychange&amp;quot;;
        this.vibibleState = &amp;quot;visibilityState&amp;quot;;
      } else if (
        typeof (document as any).webkitVisibilityState != &amp;quot;undefined&amp;quot;
      ) {
        this.visibleChange = &amp;quot;webkitvisibilitychange&amp;quot;;
        this.vibibleState = &amp;quot;webkitVisibilityState&amp;quot;;
      }
      if (this.visibleChange) {
        document.addEventListener(
          this.visibleChange,
          this.onVisibilityChanged,
          false
        );
      }
    },
      /**
     * 从微信返回app可以在这里面处理事情
     */
    onVisibilityChanged(event: any) {
      var hidden = event.target.webkitHidden;
      if ((document as any)[this.vibibleState] == &amp;quot;visible&amp;quot;) {
          this.goRun(); // 做自己需要的逻辑处理
          this.removeVisibilityChange();
      }
    },
     // 移除app后台监听事件
    removeVisibilityChange() {
      document.removeEventListener(
        this.visibleChange,
        this.onVisibilityChanged,
        false
      );
    },
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;15-从vue页面跳转到非vue页面点击返回ios设备上页面数据不刷新&#34;&gt;15. 从vue页面跳转到非vue页面，点击返回，ios设备上页面数据不刷新。&lt;/h3&gt;
&lt;p&gt;比如A页面定义了一个变量为true，点击跳转到非vue项目页面（php），点击返回，查看这个变量，在安卓上依然为ture，但是在ios上就变成了false。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.onpageshow=function(e){
　　if(e.persisted) {
　　　　window.location.reload()
　　}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;16-app点击自带返回按钮关闭页面以及禁用返回的踩坑记录&#34;&gt;16. app点击自带返回按钮关闭页面以及禁用返回的踩坑记录&lt;/h3&gt;
&lt;p&gt;http://note.youdao.com/s/4qUINhV0 （比较多，有道云链接发出来，希望对大家有帮助）&lt;/p&gt;
&lt;h3 id=&#34;17-wxchooseimage方法在安卓与ios上取到的base64格式不一样安卓没有dataimagejpgbase64前缀需要单独处理&#34;&gt;17. wx.chooseImage方法在安卓与ios上取到的base64格式不一样，安卓没有data:image/jpg;base64前缀，需要单独处理&lt;/h3&gt;
&lt;h3 id=&#34;18-手机内h5点击input无法唤起自带键盘可以给input添加click事件手动触发focus事件&#34;&gt;18. 手机内h5点击input无法唤起自带键盘：可以给input添加click事件手动触发focus事件。&lt;/h3&gt;
&lt;h3 id=&#34;19-canvas绘制圆角矩形方法&#34;&gt;19. canvas绘制圆角矩形方法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// x、y、w、h与canvas的rect方法参数相同
//r代表圆角大小，1、2、3、4分别代表上左、上右、下右、下左
function drawRoundRect(ctx, x, y, w, h, r1, r2, r3, r4) {
  ctx.beginPath()
  ctx.moveTo(x + r1, y)
  ctx.arcTo(x + w, y, x + w, y + h, r2)
  ctx.arcTo(x + w, y + h, x, y + h, r3)
  ctx.arcTo(x, y + h, x, y, r4)
  ctx.arcTo(x, y, x + w, y, r1)
  ctx.closePath()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;20-post导出文件处理&#34;&gt;20. POST导出文件处理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;fetch请求方法中，增加类型处理，预设请求传入字段控制，返回为：response.blob()；&lt;/li&gt;
&lt;li&gt;返回值处理：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;const blob = new Blob([data], {type: &amp;quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&amp;quot;})
    const a = document.createElement(&amp;quot;a&amp;quot;);
    const filename ={
      exportDetail: &#39;推广人员用户明细&#39;,
      exportRecord: &#39;推广人员跟进记录明细&#39;
    }
    a.href = URL.createObjectURL(data)
    a.download = filename[type] // 这里填保存成的文件名
    a.click()
    URL.revokeObjectURL(a.href)
　　 a.remove();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;21-解决css瀑布流只能竖向展示问题非排名或排序时可用&#34;&gt;21. 解决css瀑布流只能竖向展示问题(非排名或排序时可用)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;// 父元素
column-count: 2;
width: 100%;
// 子元素
break-inside: avoid;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const oldList = lists;
const newList = [].concat(
  ...Array.from(
    oldList.reduce(
      (total, cur, index) =&amp;gt; {
        total[index % 2].push(cur);
        return total;
      },
      { 0: [], 1: [], length: 2 }
    )
  )
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-mpvue的坑&#34;&gt;22. mpvue的坑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一定要遵循mpvue官方文档建议，不要将v-for用在组件上面，或者在v-for内嵌套组件，这样成倍增加wx.setData的数据量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在开发上拉加载更多的需求时不要使用小程序原生的scroll-view，直接使用page的onReachBottom事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用swiper时，不要嵌套过多swiper-item，不要在swiper-item中放入太多元素，有瀑布流等无限加载列表需求时，禁止使用swiper，会导致小程序卡死闪退&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;slot只能使用匿名，具名slot及scoped slot不能使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在定义组件data时，不要将与view无关的数据定义到data中，直接定义到外部，特别时监听scroll事件的时候&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx对象的方法全部都挂在mpvue对象下，不需要直接调用wx的方法，特别是在兼容h5的时候&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;button open-type是获取用户手机号等需要绑定事件的类型时，不要使用click.stop或catch:tap，这样会导致不会触发获取用户手机号的回调方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有组件的created生命周期只在小程序加载的时候统一执行，即使使用了v-if也不能在每次加载组件的时候触发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果要自定义tabbar最好自己实现一个，不要使用原生的custom定义，原生custom限制太多且不能使用mpvue实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-taro-hooks子组件条件渲染&#34;&gt;23. Taro hooks子组件条件渲染&lt;/h3&gt;
&lt;p&gt;若是希望子组件props未被重新赋值的情况下不渲染，使用memo包裹，它实现了class中PureComponent的效果，浅比较了一次。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
import Taro, { memo } from &amp;quot;@tarojs/taro&amp;quot;;
import { View } from &amp;quot;@tarojs/components&amp;quot;;
 
const Index = ({ data }) =&amp;gt; {
  return (
    &amp;lt;View&amp;gt;
      {console.log(&amp;quot;Test -- rander2&amp;quot;, data)}
      {data.map((item, index) =&amp;gt; {
        return &amp;lt;View key={index}&amp;gt;{item}&amp;lt;/View&amp;gt;;
      })}
    &amp;lt;/View&amp;gt;
  );
};
 
export default memo(Index);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若是希望在某些特定的prop改变的时候更新子组件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// utils
import Taro from &amp;quot;@tarojs/taro&amp;quot;;
 
/**
  * 子组件条件渲染
  * @param {Function} render - 要渲染的组件函数
  * @param {Array}  observe - 渲染依据，从props接收的数据key，
  */
export const compareRender = (render, observe=[]) =&amp;gt; {
  const compare = (prevProps, nextProps) =&amp;gt; {
    let keep = true;
    for (let i = 0; i &amp;lt; observe.length; i++) {
      if (prevProps[observe[i]] !== nextProps[observe[i]]) {
        keep = false;
        break;
      }
    }
    return keep;
  };
  return Taro.memo(render, compare);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;// 子组件
import Taro from &amp;quot;@tarojs/taro&amp;quot;;
import { View } from &amp;quot;@tarojs/components&amp;quot;;
 
import { compareRender } from &amp;quot;@utils&amp;quot;;
 
const Index = ({ data }) =&amp;gt; {
  return (
    &amp;lt;View&amp;gt;
      {console.log(&amp;quot;Test -- rander&amp;quot;, data)}
      {data.map((item, index) =&amp;gt; {
        return &amp;lt;View key={index}&amp;gt;{item}&amp;lt;/View&amp;gt;;
      })}
    &amp;lt;/View&amp;gt;
  );
};
 
export default compareRender(Index, [&amp;quot;data&amp;quot;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;24-关于在dva副作用中多个请求同步执行的优化&#34;&gt;24. 关于在dva副作用中多个请求同步执行的优化&lt;/h3&gt;
&lt;p&gt;经测试：&lt;br&gt;
const res1 = yield call(req1); const res2 = yield call (req2); const res3 = yield call (req3);  三个请求同步执行，平均耗时大约为120ms，页面加载、数据等待时间较长。&lt;br&gt;
优化：&lt;br&gt;
const [ res1, res2, res3] =  yield [ call(req1), call(req2), call(req3) ],  并发请求，平均耗时大约为20ms&lt;/p&gt;
">C端H5或小程序常见问题总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&#34;&gt;MDN new&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;一-new的介绍&#34;&gt;一、new的介绍&lt;/h3&gt;
&lt;p&gt;new是干什么的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用new可以少做四件事情：&lt;/p&gt;
&lt;p&gt;不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；&lt;br&gt;
不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；&lt;br&gt;
不用 return 临时对象，因为 new 会帮你做；&lt;br&gt;
不要给原型想名字了，因为 new 指定名字为 prototype。&lt;/p&gt;
&lt;p&gt;new 关键字会进行如下的操作：&lt;/p&gt;
&lt;p&gt;创建一个空的简单JavaScript对象（即{}）；&lt;br&gt;
为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；&lt;br&gt;
将步骤1新创建的对象作为this的上下文 ；&lt;br&gt;
如果该函数没有返回对象，则返回this。&lt;br&gt;
（译注：关于对象的 constructor，参见 Object.prototype.constructor）&lt;/p&gt;
&lt;p&gt;创建一个用户自定义的对象需要两步：&lt;/p&gt;
&lt;p&gt;通过编写函数来定义对象类型。&lt;br&gt;
通过 new 来创建对象实例。&lt;br&gt;
创建一个对象类型，需要创建一个指定其名称和属性的函数；对象的属性可以指向其他对象，看下面的例子：&lt;/p&gt;
&lt;p&gt;当代码 new Foo(...) 执行时，会发生以下事情：&lt;/p&gt;
&lt;p&gt;一个继承自 Foo.prototype 的新对象被创建。&lt;br&gt;
使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。&lt;br&gt;
由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）&lt;br&gt;
你始终可以对已定义的对象添加新的属性。例如，car1.color = &amp;quot;black&amp;quot; 语句给 car1 添加了一个新的属性 color，并给这个属性赋值 &amp;quot;black&amp;quot;。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，你必须将该属性添加到 Car 对象类型的定义中。&lt;/p&gt;
&lt;p&gt;你可以使用 Function.prototype 属性将共享属性添加到以前定义的对象类型。这定义了一个由该函数创建的所有对象共享的属性，而不仅仅是对象类型的其中一个实例。下面的代码将一个值为 null 的 color 属性添加到 car 类型的所有对象，然后仅在实例对象 car1 中用字符串 &amp;quot;black&amp;quot; 覆盖该值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function Car() {}
car1 = new Car();
car2 = new Car();

console.log(car1.color);    // undefined

Car.prototype.color = &amp;quot;original color&amp;quot;;
console.log(car1.color);    // original color

car1.color = &#39;black&#39;;
console.log(car1.color);   // black

console.log(car1.__proto__.color) //original color
console.log(car2.__proto__.color) //original color
console.log(car1.color)  // black
console.log(car2.color) // original color
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你没有使用 new 运算符， 构造函数会像其他的常规函数一样被调用， 并不会创建一个对象。在这种情况下， this 的指向也是不一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;二-自定义一个new&#34;&gt;二、自定义一个new&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  // 构造器函数
  let Parent = function (name, age) {
    this.name = name;
    this.age = age;
  };
  Parent.prototype.sayName = function () {
    console.log(this.name);
  };
  //自己定义的new方法
  let newMethod = function (Parent, ...rest) {
    // 1.以构造器的prototype属性为原型，创建新对象；
    let child = Object.create(Parent.prototype);
    // 2.将this和调用参数传给构造器执行
    Parent.apply(child, rest);
    // 3.返回第一步的对象
    return child;
  };
  //创建实例，将构造函数Parent与形参作为参数传入
  const child = newMethod(Parent, &#39;echo&#39;, 26);
  child.sayName() //&#39;echo&#39;;

  //最后检验，与使用new的效果相同
  child instanceof Parent//true
  child.hasOwnProperty(&#39;name&#39;)//true
  child.hasOwnProperty(&#39;age&#39;)//true
  child.hasOwnProperty(&#39;sayName&#39;)//false
&lt;/code&gt;&lt;/pre&gt;
">自定义一个new方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang"" data-c="
          &lt;h3 id=&#34;首先得介绍一下深拷贝和浅拷贝&#34;&gt;首先得介绍一下深拷贝和浅拷贝&lt;/h3&gt;
&lt;p&gt;简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。&lt;/p&gt;
&lt;p&gt;我们来举个浅拷贝例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let a=[0,1,2,3,4],
    b=a;
console.log(a===b);
a[0]=1;
console.log(a,b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1645179982030.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。&lt;br&gt;
那么这里，就得引入基本数据类型与引用数据类型的概念了。&lt;br&gt;
面试常问，基本数据类型有哪些，number，string，boolean，null，undefined，symbol以及未来ES10新增的BigInt(任意精度整数)七类。&lt;/p&gt;
&lt;p&gt;引用数据类型(Object类)有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等。&lt;/p&gt;
&lt;p&gt;而这两类数据存储分别是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本类型--名值存储在栈内存中，例如let a=1;&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1645180053377.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当你b=a复制时，栈内存会新开辟一个内存，例如这样：&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1645180068077.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用数据类型--名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1645180120847.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1645180132383.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1645180430014.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1645180475298.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实现简单的深拷贝&#34;&gt;实现简单的深拷贝&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function deepClone(obj){
    let objClone = Array.isArray(obj)?[]:{};
    if(obj &amp;amp;&amp;amp; typeof obj===&amp;quot;object&amp;quot;){
        for(key in obj){
            if(obj.hasOwnProperty(key)){
                //判断ojb子元素是否为对象，如果是，递归复制
                if(obj[key]&amp;amp;&amp;amp;typeof obj[key] ===&amp;quot;object&amp;quot;){
                    objClone[key] = deepClone(obj[key]);
                }else{
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}    
let a=[1,2,3,4],
    b=deepClone(a);
a[0]=2;
console.log(a,b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1645180524777.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。&lt;/p&gt;
&lt;h4 id=&#34;这里再次强调深拷贝是拷贝对象各个层级的属性&#34;&gt;这里再次强调，深拷贝，是拷贝对象各个层级的属性。&lt;/h4&gt;
&lt;p&gt;那是不是说slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let a=[0,1,[2,3],4],
        b=a.slice();
a[0]=1;
a[2][0]=1;
console.log(a,b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1645180593582.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。&lt;br&gt;
第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。&lt;/p&gt;
&lt;p&gt;同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。&lt;/p&gt;
&lt;h3 id=&#34;除了递归我们还可以借用json对象的parse和stringify&#34;&gt;除了递归，我们还可以借用JSON对象的parse和stringify&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function deepClone(obj){
    let _obj = JSON.stringify(obj),
        objClone = JSON.parse(_obj);
    return objClone
}    
let a=[0,1,[2,3],4],
    b=deepClone(a);
a[0]=1;
a[2][0]=1;
console.log(a,b);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1645180680861.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。&lt;/p&gt;
&lt;h3 id=&#34;问下大家objectassign属于浅拷贝还是深拷贝&#34;&gt;问下大家object.assign属于浅拷贝还是深拷贝&lt;/h3&gt;
&lt;p&gt;Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型，所以属于浅拷贝&lt;/p&gt;
&lt;h3 id=&#34;objectgetownpropertydescriptors方法配合-objectcreate-方法可以实现浅拷贝&#34;&gt;Object.getOwnPropertyDescriptors方法配合 Object.create() 方法可以实现浅拷贝。&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文参考：https://www.cnblogs.com/echolun/p/7889848.html&lt;/p&gt;
">如何用Object.create浅拷贝一个对象</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/js-huo-qu-wen-jian-da-xiao"" data-c="
          &lt;p&gt;背景：今天 每周例行技术分享 的时候，有位同事说 js 获取不到文件大小：浏览器默认不允许js 执行IO操作。 举了个例子，比如想获取一个图片地址的文件大小，因为之前做过图片上传功能所以比较敏感，感觉应该是可以的，虽然他说网上找过很多资料但是都不行，但是这种东西 只有自己试试才安心嘛~~&lt;/p&gt;
&lt;h3 id=&#34;失败方案-canvastoblob&#34;&gt;失败方案 canvas.toBlob&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function loadImg(url){
    return new Promise((res, rej) =&amp;gt; {
        const img = new Image()
        img.crossOrigin = &#39;&#39;   // 防止img 画在canvas上时报跨域错误
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej()
        }
        img.src = url
    })
}

async function getImgSize(url) {
    const urlArr = url.split(&#39;.&#39;)
    const mime = &amp;quot;image/&amp;quot; + urlArr[urlArr.length-1]
    const img = await loadImg(url)
    const {width,height} = img
    const canvas = document.createElement(&#39;canvas&#39;)
    const ctx = canvas.getContext(&#39;2d&#39;);
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img,0,0,width,height)
    canvas.toBlob(
        blob =&amp;gt; {
            console.log(url,blob,(blob.size / 1000)+&#39;KB&#39;)
        },
        mime
    );
}

getImgSize(&#39;https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看日志输出&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1644227403808.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
看着成了，但实际.... 与 本地 和 Network 差 十万八千里&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1644227440435.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1644227452558.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我尝试了几个图片,每个图片都比之前要大，而且增大程度不一定,这块估计是canvas画了一遍的原因。。。&lt;/p&gt;
&lt;h3 id=&#34;失败方法-canvastodataurl-dataurltoblob&#34;&gt;失败方法 canvas.toDataURL + dataURLtoBlob&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function loadImg(url){
    return new Promise((res, rej) =&amp;gt; {
        const img = new Image()
        img.crossOrigin = &#39;&#39;   // 防止img 画在canvas上时报跨域错误
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej()
        }
        img.src = url
    })
}

async function getImgSize(url) {
    const urlArr = url.split(&#39;.&#39;)
    const mime = &amp;quot;image/&amp;quot; + urlArr[urlArr.length-1]
    const img = await loadImg(url)
    const {width,height} = img
    const canvas = document.createElement(&#39;canvas&#39;)
    const ctx = canvas.getContext(&#39;2d&#39;);
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img,0,0,width,height);
    const blob =  dataURLtoBlob(canvas.toDataURL(mime));
    console.log(url,blob,(blob.size / 1000)+&#39;KB&#39;)
}
function dataURLtoBlob(dataurl) {
    var arr = dataurl.split(&#39;,&#39;);
    var _arr = arr[1].substring(0,arr[1].length-2);
    var mime = arr[0].match(/:(.*?);/)[1],
        bstr =atob(_arr),
        n = bstr.length,
        u8arr = new Uint8Array(n);
    while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], {
        type: mime
    });
}

getImgSize(&#39;https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看结果⬇️&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1644227621781.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
。。。看来不能走canvas这条路了&lt;/p&gt;
&lt;h3 id=&#34;成功方案-performance&#34;&gt;成功方案 performance&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1644227695711.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
难道真的没有办法了嘛？我盯着 浏览器Network 陷入沉思, 突然 Network 资源加载 的size在我眼里 越来越抢眼，貌似有个api可以获取到资源加载~~~~~ 走起&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getImgSize(url){
    return new Promise((res, rej) =&amp;gt; {
        var performance = window.performance || 
            window.msPerformance || 
            window.webkitPerformance;
        if (performance) {
            const img = new Image()
            img.crossOrigin = &#39;&#39;
            img.onload = function() {
                let [imgEntries] = performance.getEntriesByName(url)
                res(imgEntries)
            }
            img.onerror = function() {
                rej(&#39;图片加载失败&#39;)
            }
            img.src = url
        }else{
            rej(&#39;浏览器不持支持performance&#39;)
        }
    })
}
let url = &#39;https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg&#39;
getImgSize(url).then(v=&amp;gt;{
    console.log(v)
    console.log(v.decodedBodySize)
    console.log((v.decodedBodySize / 1000),&#39;KB&#39;)
    // transferSize  判断是否缓存
})
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这块使用 decodedBodySize，因为 css js等资源 decodedBodySize 与本地大小一致&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1644227863370.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/decodedBodySize&#34;&gt;decodedBodySize-MDN文档&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/encodedBodySize&#34;&gt;encodedBodySize-MDN 文档&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/getEntriesByName&#34;&gt;performance.getEntriesByName-MDN文档&lt;/a&gt;&lt;br&gt;
哈哈哈哈，成了～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;多组数据验证&#34;&gt;多组数据验证&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;图片地址&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;本地size&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;canvas.toBlob&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;canvas.toDataURL + dataURLtoBlob&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;performance&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20519&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;36345&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;36343&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20519&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;https://images.daojia.com/dop/custom/dda52b42212b6bdea3e12d03ac97ffbe.png&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;65511&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;164303&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;164302&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;65511&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;https://images.daojia.com/dop/custom/f8f0528c61e243699c309f5f25eab513.png&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;14638&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;36394&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;36391&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;14638&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;没有看错-performance-与本地的完全一样&#34;&gt;没有看错 performance 与本地的完全一样&lt;/h4&gt;
&lt;h3 id=&#34;不限制于图片&#34;&gt;不限制于图片&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;function loadJSFile(source) {
    return new Promise((res, rej) =&amp;gt; {
        const node = document.createElement(&#39;script&#39;)
        node.async = false
        node.src = source

        const supportOnload = &#39;onload&#39; in node
        if (supportOnload) {
            node.onload = function(){
                res(this)
            }
            node.onerror = () =&amp;gt; {
                rej(`${source}加载失败`)
            }
        } else {
            node.onreadystatechange = function(){
                if (/loaded|complete/i.test(node.readyState)) {
                    res(this)
                }
            }
        }
        document.getElementsByTagName(&#39;head&#39;)[0].appendChild(node)
    })
}
function loadImgFile(url){
    return new Promise((res, rej) =&amp;gt; {
        const img = new Image()
        img.crossOrigin = &#39;&#39;
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej(&#39;图片加载失败&#39;)
        }
        img.src = url
    })
}

function loadCSSFile(source) {
    return new Promise((res, rej) =&amp;gt; {
        var head = document.getElementsByTagName(&#39;head&#39;)[0];
        var link = document.createElement(&#39;link&#39;);
        link.type = &#39;text/css&#39;;
        link.rel = &#39;stylesheet&#39;;
        link.href = source;
        const supportOnload = &#39;onload&#39; in link
        if (supportOnload) {
            link.onload = function(){
                res(this)
            }
            link.onerror = () =&amp;gt; {
                rej(`${source}加载失败`)
            }
        } else {
            link.onreadystatechange = function(){
                if (/loaded|complete/i.test(link.readyState)) {
                    res(this)
                }
            }
        }
        head.appendChild(link);
    })
}
function getFileSize(url){
    return new Promise((res, rej) =&amp;gt; {
    var performance = window.performance || 
        window.msPerformance || 
        window.webkitPerformance;
    if (performance) {
        let [imgEntries] = performance.getEntriesByName(url)
        if(imgEntries){
            console.log(imgEntries)
            console.log(imgEntries.decodedBodySize)
            console.log((imgEntries.decodedBodySize / 1000),&#39;KB&#39;)
            res(imgEntries)
        }else{
            rej(&#39;资源加载有问题&#39;)
        }
    }else{
        rej(&#39;浏览器不持支持performance&#39;)
    }
})
}
(async function (){
    const css = &#39;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css&#39;;
    await loadCSSFile(css)
    await getFileSize(css)

    const js = &#39;https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js&#39;;
    await loadJSFile(js)
    await getFileSize(js)

    const img = &#39;https://images.daojia.com/dop/custom/f8f0528c61e243699c309f5f25eab513.png&#39;;
    await loadImgFile(img)
    await getFileSize(img)
})()
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1644228526757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;兼容性&#34;&gt;兼容性&lt;/h3&gt;
&lt;p&gt;最后记得使用&lt;a href=&#34;https://caniuse.com/?search=encodedBodySize&#34;&gt;caniuse - performance&lt;/a&gt;查看一下兼容性&lt;/p&gt;
">js获取文件大小 window.performance</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/docker-attach-ming-ling"" data-c="
          &lt;p&gt;docker attach :连接到正在运行中的容器。&lt;br&gt;
要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。&lt;/p&gt;
&lt;p&gt;官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了😨&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上--sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。&lt;br&gt;
runoob@runoob:~$ docker attach --sig-proxy=false mynginx&lt;/p&gt;
">Docker attach 命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/sequelize"" data-c="
          &lt;p&gt;官网介绍：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。&lt;br&gt;
&lt;a href=&#34;https://nacos.io/zh-cn/docs/what-is-nacos.html&#34;&gt;Nacos中文文档&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;概览&lt;br&gt;
欢迎来到 Nacos 的世界！&lt;br&gt;
Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。&lt;br&gt;
Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个东西主要用于微服务，但我作为一个前端，只用了它的配置管理功能，虽然有点大材小用，但确实方便,而且还可以通过网页去直接查看数据结构。&lt;/p&gt;
&lt;p&gt;假设前端要搞一个平台，但是并没有后端支持，那么权限管理以及一些必要的数据获取该怎么做呢，我们想到的肯定是node起服务，然后写接口，然后连接数据库。从而实现数据的增删改查。&lt;/p&gt;
&lt;p&gt;但有一种更简单的方式，就是在服务器的docker中下载一个nacos,把数据放到nacos中管理，这样数据依然在我们的服务器上，并且不需要我们自己去写接口，nacos提供了openApi，我们直接调用接口就可以，是不是很方便呢。下面开始安装：&lt;/p&gt;
&lt;h3 id=&#34;nacos-docker-快速开始&#34;&gt;Nacos Docker 快速开始&lt;/h3&gt;
&lt;p&gt;操作步骤&lt;br&gt;
Clone 项目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/nacos-group/nacos-docker.git
cd nacos-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单机模式 Derby&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-derby.yaml up
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单机模式 MySQL&lt;/p&gt;
&lt;p&gt;如果希望使用MySQL5.7&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-mysql-5.7.yaml up
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果希望使用MySQL8&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-mysql-8.yaml up
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;集群模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-compose -f example/cluster-hostname.yaml up 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服务注册&lt;/p&gt;
&lt;p&gt;curl -X POST &#39;http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;amp;ip=20.18.7.10&amp;amp;port=8080&#39;&lt;br&gt;
服务发现&lt;/p&gt;
&lt;p&gt;curl -X GET &#39;http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName&#39;&lt;br&gt;
发布配置&lt;/p&gt;
&lt;p&gt;curl -X POST &amp;quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;amp;group=test&amp;amp;content=helloWorld&amp;quot;&lt;br&gt;
获取配置&lt;/p&gt;
&lt;p&gt;curl -X GET &amp;quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;amp;group=test&amp;quot;&lt;br&gt;
Nacos 控制台&lt;/p&gt;
&lt;p&gt;link：http://127.0.0.1:8848/nacos/（因为是在服务器上，所以可以直接使用对应的域名或者ip来访问）&lt;/p&gt;
&lt;h3 id=&#34;注意这里要用openapi提供的字段信息多了tenant字段-有哪里不明白的可以看下开头的官方文档哈&#34;&gt;注意，这里要用openApi提供的字段信息，多了tenant字段。有哪里不明白的可以看下开头的官方文档哈。&lt;/h3&gt;
">前端使用Nacos</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/koa-zhong-jian-jian-yu-zhi-xing-shun-xu"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.itying.com/koa/article-index-id-90.html&#34;&gt;koa2中文文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;一-什么是koa的中间件&#34;&gt;一、什么是Koa的中间件&lt;/h3&gt;
&lt;p&gt;通俗的讲：中间件就是匹配路由之前或者匹配路由完成做的一系列的操作，我们就可以把它叫做中间件。&lt;/p&gt;
&lt;p&gt;在express中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处理请求-响应循环流程中的中间件，一般被命名为 next 的变量。在Koa中中间件和express有点类似。&lt;/p&gt;
&lt;p&gt;中间件的功能包括：&lt;/p&gt;
&lt;p&gt;执行任何代码。&lt;br&gt;
修改请求和响应对象。&lt;br&gt;
终结请求-响应循环。&lt;br&gt;
调用堆栈中的下一个中间件。&lt;/p&gt;
&lt;p&gt;如果我的get、post回调函数中，没有next参数，那么就匹配上第一个路由，就不会往下匹配了。如果想往下匹配的话，那么需要写next()&lt;/p&gt;
&lt;h3 id=&#34;二-koa应用可使用如下几种中间件&#34;&gt;二、Koa应用可使用如下几种中间件：&lt;/h3&gt;
&lt;p&gt;应用级中间件&lt;br&gt;
路由级中间件&lt;br&gt;
错误处理中间件&lt;br&gt;
第三方中间件&lt;/p&gt;
&lt;h3 id=&#34;三-使用&#34;&gt;三、使用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;async和await&lt;br&gt;
在koa中使用关键词 async 标记的函数是异步函数，&lt;br&gt;
在异步函数中使用 await next(); 处理下一个异步函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;app.use(async func())&lt;br&gt;
koa的使用方法很简单，将一系列要处理的操作封装到一个个异步函数中，然后用Koa的实例app通过 app.use(async func()) 的形式调用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个koa应用程序如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:
const Koa = require(&#39;koa&#39;);
const app = new Koa(); // 创建一个Koa对象表示web app本身:

// 对于任何请求，app将调用该异步函数处理请求：
app.use(async (ctx, next) =&amp;gt; {
    await next();
    ctx.response.type = &#39;text/html&#39;;
    ctx.response.body = &#39;&amp;lt;h1&amp;gt;Hello, koa2!&amp;lt;/h1&amp;gt;&#39;;
});

// 在端口3000监听:
app.listen(3000);
console.log(&#39;app started at port 3000...&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到 app.use() 括号里面的参数是一个函数。函数用了异步修饰符 async ，在这个函数内部，又通过关键字 await next() 调用下一个app.use的异步函数。如果这个函数是最后一个需要执行的函数，则内部不需要再写await next（）。&lt;/p&gt;
&lt;h3 id=&#34;四-koa中间件的执行顺序&#34;&gt;四、koa中间件的执行顺序&lt;/h3&gt;
&lt;p&gt;Express的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应。&lt;br&gt;
Koa是从第一个中间件开始执行,遇到 await next() 就进入下一个中间件，一直到执行到最后一个中间件。然后再逆序执行上一个中间件 await next() 后面的代码，一直到第一个中间件 await next() 后面的代码执行完毕才发出响应。&lt;/p&gt;
&lt;p&gt;koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app.use(async (ctx, next) =&amp;gt; {
    console.log(&#39;1&#39;); 
    await next(); // 调用下一个middleware
    console.log(&#39;5&#39;)
});

app.use(async (ctx, next) =&amp;gt; {
    console.log(&#39;2&#39;);
    await next(); // 调用下一个middleware
    console.log(&#39;4&#39;);
});

app.use(async (ctx, next) =&amp;gt; {
    console.log(&#39;3&#39;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果： 12345&lt;/p&gt;
">KOA中间件与执行顺序</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/koa-jie-kou-can-shu-xiao-yan-yu-fan-hui-zhi-tong-yi-chu-li"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://github.com/node-modules/parameter&#34;&gt;parameter地址&lt;/a&gt;&lt;br&gt;
// Koa接口参数校验与返回值统一处理  将参数校验变成一个路由中间件，正确的话继续执行，错误的话抛出错误异常。&lt;br&gt;
// 在第一个中间件中自定义返回格式这里叫ctx.DATA（ctx上自定义一个对象，对象包含code默认200,msg默认‘成功’,data默认空对象）&lt;br&gt;
// 这里对错误异常做了处理，抛出的是带code码以及与code码对应的msg和错误原因data的对象，此时我们将错误信息赋值给ctx.DATA.data。app中先写一个捕获错误的中间件，这样抛出的错误我们能够捕获到，然后从这里我们给body赋值，这样错误时返回的就是code码和message都有的返回值&lt;br&gt;
// 当成功查找到数据库中的数据时，我们只需要将数据给ctx.DATA.data，那么返回值就是code码为200，msg为成功，data为正确数据的对象了。万一出现了登陆失败，我们也可以改变ctx.DATA.message为登陆失败，改变code码等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 数据校验
 * wiki：https://github.com/node-modules/parameter/blob/master/example.js
 * @type {Parameter}
 */
// const { HttpError } = require(&#39;../../utils/tool/error&#39;)
const util = require(&#39;util&#39;)
// const ERROR_MSG = require(&#39;./errorMsg&#39;)
const ERROR_MSG = Object.freeze({
  // en
  // 0: &#39;fail&#39;,
  // 1: &#39;validation error&#39;,
  // 200: &#39;ok&#39;,
  // 400: &#39;invalid param&#39;,
  // 401: &#39;unauthorized&#39;,
  // 403: &#39;forbidden&#39;,
  // 404: &#39;not found&#39;,
  // 500: &#39;internal server error&#39;,
  // 503: &#39;service busy&#39;,

  // zh-cn
  0: &#39;失败&#39;,
  1: &#39;验证码错误&#39;,
  200: &#39;成功&#39;,
  400: &#39;请求出错&#39;,
  401: &#39;未授权的请求&#39;,
  403: &#39;禁止：禁止执行访问&#39;,
  404: &#39;找不到：请检查URL以确保路径正确&#39;,
  500: &#39;服务器的内部错误&#39;,
  503: &#39;服务不可用&#39;
})

function CustomError(code, msg) {
  Error.call(this, &#39;&#39;)

  this.code = code
  this.msg = msg || ERROR_MSG[code] || &#39;unknown error&#39;

  this.getCodeMsg = function() {
    return {
      code: this.code,
      msg: this.msg
    }
  }
}

util.inherits(CustomError, Error)

function HttpError(code, msg) {
  if ([0, 1, 200, 400, 401, 403, 404, 500, 503].indexOf(code) &amp;lt; 0) {
    throw Error(&#39;not an invalid http code&#39;)
  }

  CustomError.call(this, code, msg)
}

util.inherits(HttpError, CustomError)

const Parameter = require(&#39;parameter&#39;)
const parm = new Parameter()

// 自定义校验
parm.addRule(&#39;name&#39;, function(e, v) {
  let sta = /^[a-z]$/.test(v)
  return sta || &#39;只能输入一个字母&#39;
})

// 路由校验列表
const ruleList = {
  // 登录
  &#39;post/api/login&#39;: {
    mobile: { type: &#39;string&#39;, required: true },
    password: { type: &#39;string&#39;, required: true }
  },
  // 获取配置
  &#39;get/api/setting&#39;: {
    id: { type: &#39;string&#39;, required: true }
  },
  // 保存配置
  &#39;post/api/setting&#39;: {
    id: { type: &#39;number&#39;, required: true },
    title: { type: &#39;string&#39;, required: false },
    report_fix_id: { type: &#39;string&#39;, required: false },
    fix_url: { type: &#39;string&#39;, required: false },
    env: { type: &#39;string&#39;, required: false },
    report: { type: &#39;number&#39;, required: false },
    report_interval: { type: &#39;number&#39;, required: false }
  },
  // CICD
  &#39;post/api/deploy&#39;: {
    name: { type: &#39;string&#39;, required: true },
    branch: { type: &#39;string&#39;, required: false },
    env: { type: &#39;string&#39;, required: false }
  },
  // 用户详情
  &#39;get/api/user-details&#39;: {
    user_id: { type: &#39;string&#39;, required: true }
  }
}

/**
 * 校验方法
 * @param ctx
 * @param next
 * @returns {Promise&amp;lt;void&amp;gt;}
 */
const parameter = async (ctx, next) =&amp;gt; {
  let errors, data
  let method = &#39;get&#39;
  if (ctx.request.method === &#39;GET&#39;) {
    data = ctx.query
  } else {
    method = &#39;post&#39;
    data = ctx.request.body
  }
  console.log(method, data)
  try {
    let name = ctx.req._parsedUrl.pathname
    errors = parm.validate(ruleList[method + name], data)
  } catch (e) {
    throw new HttpError(0, e.toString())
  }
  if (errors &amp;amp;&amp;amp; errors.length) {
    ctx.DATA.data = errors
    throw new HttpError(0, &#39;数据校验未通过&#39;)
  }
  await next()
}
module.exports = parameter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;router.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 数据校验
const router = require(&#39;koa-router&#39;)()
const parameter = require(&#39;../utils/parameter&#39;)
// project
router.get(&#39;/api/user-details&#39;, parameter, userDetail)
router.get(&#39;/api/setting&#39;, parameter, getSetting)
router.post(&#39;/api/setting&#39;, parameter, setSetting)
// common
router.post(&#39;/api/login&#39;, parameter, login)
// devops
router.post(&#39;/api/deploy&#39;, parameter, checkToken, deploy)
// swagger
router.get(&#39;/api/swagger.json&#39;, async function (ctx) {
  ctx.set(&#39;Content-Type&#39;, &#39;application/json&#39;)
  ctx.body = openapiSpecification
})
// index
router.get(&#39;/&#39;, index)

module.exports = router
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;app.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const Koa = require(&#39;koa&#39;)
const app = new Koa()
const views = require(&#39;koa-views&#39;)
const json = require(&#39;koa-json&#39;)
const favicon = require(&#39;koa-favicon&#39;)
const koaBody = require(&#39;koa-body&#39;)
const logger = require(&#39;koa-logger&#39;)
const colors = require(&#39;colors&#39;)
const { resolve } = require(&#39;path&#39;)
const { koaSwagger } = require(&#39;koa2-swagger-ui&#39;)
const mysql = require(&#39;mysql2&#39;)

const conf = require(&#39;./config&#39;)
const index = require(&#39;./routes&#39;)

// 允许上传文件
app.use(
  koaBody({
    multipart: true,
    formidable: {
      maxFileSize: 1000 * 1024 * 1024 // 设置上传文件大小最大限制
    }
  })
)

// 网站图标
app.use(favicon(resolve(__dirname, &#39;./public&#39;, &#39;favicon.ico&#39;)))

// 返回美化json
app.use(json())

// koa-logger
app.use(logger())

// 资源文件
app.use(require(&#39;koa-static&#39;)(resolve(__dirname, &#39;./public&#39;)))

// 模板引擎
app.use(views(resolve(__dirname, &#39;./views&#39;), { map: { html: &#39;nunjucks&#39; } }))

// sql特殊字符处理
const toEscapeString = val =&amp;gt; {
  return mysql.escape(val)
}
const toEscapeObject = dat =&amp;gt; {
  for (let key in dat) {
    typeof dat[key] === &#39;string&#39; &amp;amp;&amp;amp; (dat[key] = toEscapeString(dat[key]))
    typeof dat[key] === &#39;object&#39; &amp;amp;&amp;amp; toEscapeObject(dat[key])
  }
  return dat
}

// 加入cookie.get、set及自定义返回格式
app.use(async (ctx, next) =&amp;gt; {
  ctx.cookie = {
    set: (k, v, opt) =&amp;gt; {
      opt = Object.assign({}, conf.cookieOptions, opt)
      return ctx.cookies.set(k, v, opt)
    },
    get: (k, opt) =&amp;gt; {
      opt = Object.assign({}, conf.cookieOptions, opt)
      return ctx.cookies.get(k, opt)
    }
  }

  let msg = {
    0: &#39;失败&#39;,
    1: &#39;验证码错误&#39;,
    200: &#39;成功&#39;,
    400: &#39;请求出错&#39;,
    401: &#39;未授权的请求&#39;,
    403: &#39;禁止：禁止执行访问&#39;,
    404: &#39;找不到：请检查URL以确保路径正确&#39;,
    500: &#39;服务器的内部错误&#39;,
    503: &#39;服务不可用&#39;
  }
  ctx.json = dat =&amp;gt; {
    !dat.message &amp;amp;&amp;amp; (dat.message = msg[dat.code])
    return dat
  }

  // 自定义返回格式
  ctx.DATA = {
    data: {},
    message: &#39;&#39;,
    code: 200
  }

  // 状态统一判断
  ctx.state = res =&amp;gt; {
    return !(res &amp;amp;&amp;amp; res.length ? res[0] : res)
  }
  await next()
})

// swagger
app.use(
  koaSwagger({
    routePrefix: &#39;/swagger&#39;, // host at /swagger instead of default /docs
    swaggerOptions: {
      url: &#39;/api/swagger.json&#39; // example path to json 其实就是之后swagger-jsdoc生成的文档地址
    }
  })
)
// 错误捕获
app.use((ctx, next) =&amp;gt; {
  return next().catch(err =&amp;gt; {
    console.log(err)
    let msg = err ? err.msg || err.toString() : &#39;unknown error&#39;
    let code = err ? (err.code &amp;gt;= 0 ? err.code : 500) : 500
    ctx.DATA.code = code
    ctx.DATA.message = msg
    ctx.body = ctx.DATA
    ctx.status =
      [200, 400, 401, 403, 404, 500, 503].indexOf(code) &amp;gt;= 0 ? code : 200
  })
})
// routes
app.use(index.routes(), index.allowedMethods())

app.proxy = true

// koa error-handling 服务端、http错误
app.on(&#39;error&#39;, (err, ctx) =&amp;gt; {
  console.error(&#39;server error&#39;, err, ctx)
})

module.exports = app
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;controller层的接口文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const resData = {
    os_type_data,
    ip_data,
    browser_data,
    channel_group_data,
    client_id_group_data,
    sortArrFormat,
    userActions
  }
  // 正常返回写法，一个个的定义很麻烦
  // const successData = {
  //   code: 0,
  //   data: resData,
  //   status: &#39;请求成功&#39;
  // }
  // ctx.body = successData
  
  // 直接把结果赋值，code码和message不用管
  ctx.DATA.data = resData
  ctx.body = ctx.json(ctx.DATA)
&lt;/code&gt;&lt;/pre&gt;
">Koa接口参数校验与返回值统一处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/node-jie-kou-sheng-cheng-jie-kou-wen-dang"" data-c="
          &lt;p&gt;先看下效果&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1642391805862.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里我用的是koa2+swagger&lt;/p&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// koa2-swagger-ui UI视图组件  swagger-jsdoc 识别写的 /***/ 转 json
npm install koa2-swagger-ui swagger-jsdoc --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://www.npmjs.com/package/koa2-swagger-ui&#34;&gt;koa2-swagger-ui npm地址&lt;/a&gt; （创建接口文档）&lt;br&gt;
&lt;a href=&#34;https://www.npmjs.com/package/swagger-jsdoc&#34;&gt;swagger-jsdoc npm地址&lt;/a&gt; （这个库读取带有jsdoc注释的源代码，并生成OpenAPI (Swagger)规范。）&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/5365ef83252a&#34;&gt;OpenAPI 规范摘要&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;p&gt;router.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const router = require(&#39;koa-router&#39;)() //引入路由函数
const swaggerJSDoc = require(&#39;swagger-jsdoc&#39;)
const path = require(&#39;path&#39;)
const swaggerDefinition = {
  openapi: &#39;3.0.1&#39;,
    info: {
        title: &#39;blog项目访问地址&#39;,
        version: &#39;1.0.0&#39;,
        description: &#39;API&#39;,
    },
    basePath: &#39;/&#39;, // Base path (optional)
    tags: [
      {
        name: &#39;manage&#39;,
        description: &#39;管理系统&#39;
      },
      {
        name: &#39;client&#39;,
        description: &#39;日志上报&#39;
      }
    ],
    schemes: [&#39;http&#39;, &#39;https&#39;],
    securityDefinitions: {
    server_auth: {
      type: &#39;oauth2&#39;,
      description: &#39;登录账号密码鉴权&#39;,
      tokenUrl: &#39;&#39;,
      flow: &#39;password&#39;,
      scopes: {
        token: &#39;modify pets in your account&#39;
      }
    },
    token: {
      type: &#39;apiKey&#39;,
      name: &#39;token&#39;,
      in: &#39;header&#39;
    }
  }
};
const options = {
    swaggerDefinition,
    apis: [path.join(__dirname, &#39;./controllers/*.js&#39;)], // 包含上述注释的文件（）
};
const swaggerSpec = swaggerJSDoc(options)
// 通过路由获取生成的注解文件
router.get(&#39;/swagger.json&#39;, async function (ctx) {
    ctx.set(&#39;Content-Type&#39;, &#39;application/json&#39;);
    ctx.body = swaggerSpec;
})
module.exports = router
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;app.js 入口文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const swagger = require(&#39;./router&#39;)  // router中做了swagger配置
const { koaSwagger } = require(&#39;koa2-swagger-ui&#39;)

// 接口文档配置
app.use(swagger.routes(), swagger.allowedMethods())
app.use(koaSwagger({
  routePrefix: &#39;/swagger&#39;, // 接口文档访问地址
  swaggerOptions: {
    url: &#39;/swagger.json&#39;, // example path to json 其实就是之后swagger-jsdoc生成的文档地址
  }
}))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动项目，访问项目接口地址 + swagger ，我的地址是 http://localhost:4002/swagger&lt;/p&gt;
&lt;h3 id=&#34;注释生成文档&#34;&gt;注释生成文档&lt;/h3&gt;
&lt;p&gt;在controller层文件每个接口上写注释，注释是以@swagger开头的，swagger-jsdoc 会识别@swagger，然后解析下面的注释，解析完给koa2-swagger-ui显示成页面，总的流程就是这样。&lt;br&gt;
get方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取博客列表
/**
 * @swagger
 * /api/blog/list:
 *   get:
 *     summary: 获取博客列表
 *     description: 获取博客列表
 *     tags:
 *       - blogs
 *     parameters:
 *       - name: author
 *         in: query
 *         required: false
 *         description: 作者
 *         type: string
 *       - name: keyword
 *         in: query
 *         required: false
 *         description: 搜索关键字
 *         type: string
 *     responses:
 *       200:
 *         description: 成功获取
 */
router.get(&#39;/list&#39;, async (ctx, next) =&amp;gt; {
  const query = ctx.query
  let author = query.author || &#39;&#39;
  const keyword = query.keyword || &#39;&#39;

  const listData = await getList(author, keyword)
  ctx.body = new SuccessModel(listData)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;post方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @swagger
 * definitions:
 *  loginparam:
 *    properties:
 *      username:
 *        type: &amp;quot;string&amp;quot;
 *        default: &amp;quot;shangsan&amp;quot;
 *        description: 用户名
 *      password:
 *        type: &amp;quot;string&amp;quot;
 *        default: &amp;quot;123&amp;quot;
 *        description: 密码
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     ProjectDetail:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *           format: int64
 *         petId:
 *           type: integer
 *           format: int64
 *         quantity:
 *           type: integer
 *           format: int32
 *         shipDate:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /api/user/login:
 *   post:
 *     summary: 登录
 *     description: 登录
 *     tags:
 *       - user
 *     consumes:
 *      - application/json
 *      - application/xml
 *     produces:
 *      - application/json
 *      - application/xml
 *     parameters:
 *       - name: body
 *         in: body
 *         schema:
 *          $ref: &#39;#/definitions/loginparam&#39; （请求参数这里单独抽出，在上面定义）
 *     responses:
 *       200:
 *         description: 发布成功
 *          content:
 *           application/json:
 *             schema:
 *               $ref: &#39;#/components/schemas/ProjectDetail&#39;（返回参数也是单独抽出定义，这里是随便举个例子）
 *       402:
 *          description: 信息填写不全
 *       403:
 *          description: 参数类型错误
 */

router.post(&#39;/login&#39;, async (ctx, next) =&amp;gt; {
    // 业务逻辑
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回示例&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1642412213197.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
基本的接口文档就生成啦，快试一下吧～&lt;/p&gt;
">node接口生成接口文档</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/cao-zuo-fu"" data-c="
          &lt;h3 id=&#34;可选链操作符&#34;&gt;可选链操作符（?.）&lt;/h3&gt;
&lt;p&gt;以前写代码做判断一般这样写或者三目运算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let nestedProp = obj.first &amp;amp;&amp;amp; obj.first.second;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在只需要这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const adventurer = {
  name: &#39;Alice&#39;,
  cat: {
    name: &#39;Dinah&#39;
  }
};

const dogName = adventurer.dog?.name;
console.log(dogName);
// expected output: undefined

console.log(adventurer.someNonExistentMethod?.());
// expected output: undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;空值合并操作符&#34;&gt;空值合并操作符（??）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;只有当左侧为null和undefined时，才会返回右侧的数&lt;br&gt;
空值合并操作符（??）是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。&lt;br&gt;
与逻辑或操作符（||）不同，逻辑或操作符会在左侧操作数为假值时返回右侧操作数。也就是说，如果使用 ?? 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，&#39;&#39; 或 0）时。见下面的例子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const foo = null ?? &#39;default string&#39;;
console.log(foo);
// expected output: &amp;quot;default string&amp;quot;

const baz = 0 ?? 42;
console.log(baz);
// expected output: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const nullValue = null;
const emptyText = &amp;quot;&amp;quot;; // 空字符串，是一个假值，Boolean(&amp;quot;&amp;quot;) === false
const someNumber = 42;

const valA = nullValue ?? &amp;quot;valA 的默认值&amp;quot;;
const valB = emptyText ?? &amp;quot;valB 的默认值&amp;quot;;
const valC = someNumber ?? 0;

console.log(valA); // &amp;quot;valA 的默认值&amp;quot;
console.log(valB); // &amp;quot;&amp;quot;（空字符串虽然是假值，但不是 null 或者 undefined）
console.log(valC); // 42
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;与结合使用&#34;&gt;?.与??结合使用&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 空值合并操作符可以在使用可选链时设置一个默认值：

let customer = {
name: &amp;quot;Carl&amp;quot;,
details: { age: 82 }
};

let customerCity = customer?.city ?? &amp;quot;暗之城&amp;quot;;
console.log(customerCity);  // “暗之城”
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;工程中怎样使用&#34;&gt;工程中怎样使用&lt;/h4&gt;
&lt;p&gt;babel7以上版本支持，可以添加以下2个devDependencies依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@babel/plugin-proposal-optional-chaining // 可选链
@babel/plugin-proposal-nullish-coalescing-operator // 双问号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在.babelrc或者babel.config.js中这加入2个插件(plugins属性放在JSON顶层)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;plugins&amp;quot;: [
      &amp;quot;@babel/plugin-proposal-nullish-coalescing-operator&amp;quot;,
      &amp;quot;@babel/plugin-proposal-optional-chaining&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运算&#34;&gt;!!运算&lt;/h3&gt;
&lt;p&gt;两个叹号表示把目标值转化为布尔值，相当于使用Boolean()方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;!!&amp;quot;123&amp;quot;  相当于是   Boolean(&amp;quot;123&amp;quot;)    //结果为true
!!{a:1}  相当于是    Boolean({a:1})    //结果为true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在if语句中,表达式的结果将被强制为布尔值，通过双重否定（!!）或强制转换为布尔值Boolean是不必要的。&lt;/p&gt;
&lt;h3 id=&#34;~~运算&#34;&gt;~~运算&lt;/h3&gt;
&lt;p&gt;~~ 会把后面的表达式强行变成int&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var n = ~~5; // 5
var m = ~~-8; // -8
var j = ~~true; // 将true转换为int，也就是1，然后再计算。结果为1
&lt;/code&gt;&lt;/pre&gt;
">js中的一些操作符 ?./??/!!/~~</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/mysql-cha-xun-yu-ju"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.mysqlzh.com/doc/124.html&#34;&gt;mysql中文文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;1查询记录&#34;&gt;1.查询记录&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select*from 表名 [where 条件];

eg:select*from students;//查询 students 表中所有记录，所有字段的值都显示出来

select field1,field2,...fieldn... from 表名 [where 条件];

eg:select id,name,age from students;//查询 students 表中所有记录, 只显示出 id，name，age三个字段的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.“*”表示将所有的字段都显示出来&lt;/p&gt;
&lt;p&gt;2.用逗号分割，列出需要显示的字段&lt;/p&gt;
&lt;h3 id=&#34;2查询不重复的记录&#34;&gt;2.查询不重复的记录&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select distinct 字段 from 表名;

eg: select distinct name from students;//查询名字不相同的学生;
　　select distinct name,age from students;//查询名字和年龄同时不同的学生
　　
　　1.distinct必须放在最开头
　　2.distinct只能使用需要去重的字段进行操作。  ----也就是说我sidtinct了name,age两个字段，我后面想根据id进行排序，是不可以的，因为只能name,age两个字段进行操作.
　　3.distinct去重多个字段时，含义是：几个字段 同时重复 时才会被 过滤。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3条件查询&#34;&gt;3.条件查询&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select 字段 from 表名 where 条件;

eg:select * from student where sex=&#39;男&#39; and age&amp;gt;20; //查询性别是男，并且年龄大于20岁的人。

where后面的条件可以用&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、!=等多种比较运算符，多个条件之间可以用or、and等逻辑运算符
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4排序和限制&#34;&gt;4.排序和限制&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;排序
select * from 表名 [where 条件] [ order by  field1 [desc/asc],field2 [desc/asc]... ];

eg:select *from student order by age desc;//查询学生表并按年龄降序排列。

1.desc 降序排列，asc 升序排列
2.order by 后面可以跟多个不同的排序字段，每个排序字段都可以有不同的排序顺序。
3.如果排序字段的值一样，则相同的字段按照第二个排序字段进行排序。
4.如果只有一个排序字段，则字段相同的记录将会无序排列。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;限制
select ... [limit 起始偏移量,行数];

eg:select * from student order by mark desc limit 5;//取出成绩前五名的学生(省略了起始偏移量，此时默认为0)

1.默认情况下，起始偏移量为0，只写记录行数就可以。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5聚合&#34;&gt;5.聚合&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;select 字段 fun_name from 表名 [where 条件] [group by field1,field2...] [with rollup] [having 条件];

eg:

1.fun_name 表示要做的聚合操作，也就是说聚合函数，常用的有 : sum(求和)、count(*)(记录数)、max(最大值)、min(最小值)。
2.group by关键字 表示要进行分类聚合的字段。比如要按照部门分类统计员工数量，部门就应该写在group by 后面。
3.with rollup 是可选语法，表明是否对分类聚合后的结果进行再汇总
4.having 关键字表示对分类后的结果再进行条件过滤。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;公司员工表A如下 (编号，姓，名，薪水) ：&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143111386.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;统计总人数
select count(1) from A;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143169839.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;统计各个姓的人数
select xing,count(1) from A group by xing;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143194061.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;既要统计各个姓的人数，又统计总人数
select xing,count(1) from A group by xing with rollup;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143250933.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;统计人数大4的姓
select xing,count(1) from A group by xing having count(1)&amp;gt;4;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143298558.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;统计薪水总额，最低薪资，最高薪资
select count(1),min(salary),max(salary) from A;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://weidadeda.github.io/post-images/1642143319528.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;6为表和字段取别名&#34;&gt;6.为表和字段取别名&lt;/h3&gt;
&lt;p&gt;在查询数据时，可以为表和字段取别名，这个别名可以代替指定的表和字段。如果表名很长，用起来不方便，则可以用一个别名来代替，语法如下：(as关键字可省略)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from 表名 [as] 别名  （为表取别名）
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SELECT 字段名 [AS] 别名[,字段名 [AS] 别名,……] FROM 表名; (为字段取别名)
&lt;/code&gt;&lt;/pre&gt;
">mysql查询语句</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/docker-de-an-zhuang-yu-shi-yong"" data-c="
          &lt;p&gt;&lt;a href=&#34;http://www.dockerinfo.net/document&#34;&gt;docker中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近Docker突然火得不得了，到处都是谈论Docker的声音，相信大家和小编一样的心情，看这个东西有点高大上，但尝试去阅读Docker文章时又发现概念很模糊、不接地气、难以理解、无从下手…于是三天打鱼两天晒网，最终不了了之，反正公司也没要求用这玩意儿，不费劲了… 这不，当前几天项目要求快速上线并且部署多台服务器环境时，小编一台一台服务器的yum install、vim、restart…想屎的心都有，那时小编心里想要是有一个这么一个U盘，能把整个环境一台一台的Ctrl+V过去，那该多好啊。那时脑子一下子闪过一个念头：Docker不就是我想拥有的那个U盘吗。&lt;/p&gt;
&lt;p&gt;怀着这样的一个念头，小编花了一些时间去查阅Docker相关的书籍、看视频、逛论坛，刚开始学习时非常难受，搞不懂什么是容器什么是镜像什么是鲸鱼船…而涉及到一些原理底层的知识，书籍里的那些概念比代码都能懂，小编硬啃了一段时间并且实操了几次之后，再回过头来，才豁然开朗。念及许多想要学Docker却苦于难以入门的开发者们，正在学习却很挣扎的初学者们，故而把小编这段时间的学习成果，以一个初学者的角度，遵循循序渐进的原则，编成一份通俗易懂的文章，希望能以此引导入门，早日成Docker大神。&lt;/p&gt;
&lt;p&gt;文章提纲：&lt;/p&gt;
&lt;p&gt;1、什么是Docker&lt;/p&gt;
&lt;p&gt;2、Docker对我们有什么用处&lt;/p&gt;
&lt;p&gt;3、Docker安装和使用&lt;/p&gt;
&lt;p&gt;4、彩蛋&lt;/p&gt;
&lt;p&gt;1、什么是Docker&lt;br&gt;
什么是docker？恐怕90%的人脑子一闪而过的都是那张图：一条鲸鱼背上扛着一堆箱子，图片下方是大大的“docker”。&lt;/p&gt;
&lt;p&gt;docker是什么？&lt;/p&gt;
&lt;p&gt;是鲸鱼？&lt;/p&gt;
&lt;p&gt;还是一堆箱子？&lt;/p&gt;
&lt;p&gt;或者说是载着箱子的鲸鱼？&lt;br&gt;
这里小编不做解释，先引用一下官方的解释：&lt;/p&gt;
&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;
&lt;p&gt;顾名思义，docker是一个容器引擎，容器且不说，什么是引擎？&lt;/p&gt;
&lt;p&gt;我们知道：&lt;/p&gt;
&lt;p&gt;汽车的引擎是发动机，有了发动起，汽车才能跑起来&lt;/p&gt;
&lt;p&gt;游戏需要游戏引擎（如Unity3D..），基于引擎的开发，能让游戏动起来。&lt;/p&gt;
&lt;p&gt;如官言，docker也是一种引擎，基于这个引擎，开发者能让他们开发的应用处于一个有隔离性的、可移植性的容器中，以便于发布于各种机器中而无需考虑兼容性问题。&lt;/p&gt;
&lt;p&gt;因此就不难解释，为什么docker的logo是一条装着一堆箱子的鲸鱼.&lt;/p&gt;
&lt;p&gt;这是因为：docker扮演的是图中鲸鱼的角色，而鲸鱼之上的集装箱就是一个个容器，容器中是我们开发的应用程序（不仅限于web应用），每个容器都有自己独立的环境（环境设置、网络、文件系统…），互不干扰。而每个箱子，又可以打包成一个新的镜像，放到其它服务器的docker环境中直接运行，不再需要重复安装程序运行环境。&lt;/p&gt;
&lt;p&gt;上面的解释插入了两个生疏的概念：&lt;/p&gt;
&lt;p&gt;1、镜像&lt;/p&gt;
&lt;p&gt;2、容器&lt;/p&gt;
&lt;p&gt;我们先讲容器&lt;/p&gt;
&lt;p&gt;容器，顾名思义：就是装东西的器皿，在docker中，容器就是装载我们的应用程序的器皿，在docker的logo中，容器就是一个个箱子。我们知道，运行JavaWeb应用程序需要有Tomcat，那么我们就需要创建一个Tomcat的容器，才能把我们的程序放进去运行。&lt;/p&gt;
&lt;p&gt;那么，容器哪里来的呢&lt;/p&gt;
&lt;p&gt;我们知道，给电脑安装Windows系统需要有Windows镜像，因此给docker安装容器也是需要镜像的，所以，通俗一点，镜像就类似于我们日常中的安装软件，甚至说是操作系统镜像更为形象点。&lt;/p&gt;
&lt;p&gt;那容器和镜像有什么关系？&lt;/p&gt;
&lt;p&gt;网上说是类和对象的关系，没错，但是这样的比喻没什么实际卵用。&lt;/p&gt;
&lt;p&gt;我们知道:要运行一个web程序，需要有个Tomcat环境，需要Tomcat环境，那就下载一个Tomcat解压出来，然后把web程序放入Tomcat的webapps中启动即可，&lt;/p&gt;
&lt;p&gt;那么在docker中要运行一个web程序，就需要有Tomcat容器，需要Tomcat容器，就得去下载Tomcat镜像（也可以自己构建），把镜像pull下来之后，运行起来，就是一个Tomcat容器，此时把web程序至于Tomcat挂载的数据目录webapps中既可以运行。&lt;/p&gt;
&lt;p&gt;所以docker中，容器和镜像的关系更像是一种动静的关系，也就是说，存于仓库中的镜像是一个死的软件，而运行起来的容器则像是一个正在运行的程序（进程）。&lt;/p&gt;
&lt;p&gt;2、Docker有什么用&lt;br&gt;
对docker有了清晰的了解之后，我们心里可能在想： 这玩儿对我有什么用？ 我在哪里能用得上？ 怎么用才对？&lt;/p&gt;
&lt;p&gt;这里引用几个案例来让大家体会体会。&lt;/p&gt;
&lt;p&gt;1、案例一 前几天，公司一批服务器就要到期了，由于服务器是15年购买的，硬件的性能远比现在新出的云主机低，因此决定把所有服务器都换成新一代服务器，但是小编整准备动手迁移服务器时，内心一阵阵崩溃感涌上心头，仔细一算，每台服务器都要做同样的事情：&lt;/p&gt;
&lt;p&gt;1、安装jdk、Tomcat、nginx 2、配置jdk环境变量和系统变量 3、配置Tomcat 4、配置nginx 5、安装项目所需的视频解码组件 6、导入项目所需的一些特殊字体&lt;/p&gt;
&lt;p&gt;后来决定用docker部署的办法，在每台服务器都把docker安装之后，只需要在其中一台服务器中把Tomcat镜像从镜像仓库拉取下来，把这些配置都设置好，做成一个自己的镜像上传到镜像仓库中，之后在其他几台服务器都下载自己做的镜像，运行于docker中，把代码上传，就万事大吉了。&lt;/p&gt;
&lt;p&gt;2、案例二&lt;/p&gt;
&lt;p&gt;前不久的圣诞活动中，公司临时的活动方案在程序员的加班加点中终于上线，但是一上线之后发现推广海报中的中文名字乱码，领导问责测试人员怎么没做好测试，测试很委屈的说我已经测试无数遍并且测试报告都提交了，解决了所有问题才上线的；没办法只能让服务器同事查看正式服务器中的tomcat配置，发现原来 tomcat用了默认编码方式：iso8859-1，而测试环境中是UTF-8。针对这个问题，项目组决定把开发环境迁移到docker中，在测试环境中测试无误后，把镜像打包发布到正式环境中，解决了环境不同导致的问题。&lt;/p&gt;
&lt;p&gt;3、docker的安装&lt;br&gt;
感知到docker对我们开发者的好处之后，相信大家也跃跃欲试了吧，下面 就Linux centOS（版本大于等于7.0）系统进行演示docker的安装步骤：&lt;/p&gt;
&lt;p&gt;1、删除可能存在的旧版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 sudo yum remove docker
2 docker-client
3 docker-client-latest
4 docker-common
5 docker-latest
6 docker-latest-logrotate
7 docker-logrotate
8 docker-selinux
9 docker-engine-selinux
10 docker-engine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;2、安装一些必备工具：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install -y yum-utils device-mapper-persistent-data lvm2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、添加Docker源：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum-config-manager
--add-repo
https://download.docker.com/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、更新yum缓存&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum makecache fast
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install docker-ce
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、创建docker用户&lt;/p&gt;
&lt;p&gt;温馨提示：以下操作不是必备，但是为了养成一个Linux用户的使用的良好习惯，小编不建议直接使用root操作，因此创建一个用户用来操作docker。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useradd docker_manager
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;docker_manager是用户名，可以根据喜好起名，创建完用户之后，设置密码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;passwd docker_manager
docker_manager_wsdt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会提示输入密码和确认密码,按照提示操作即可&lt;/p&gt;
&lt;p&gt;7、配置docker用户的权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;visudo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;visudo是配置用户权限的文件，在命令行中输入visudo回车之后，会进入文件操作，找到“# %wheel ALL=(ALL) NOPASSWD: ALL”这一行，把前面的“#”去掉，保存文件&lt;/p&gt;
&lt;p&gt;8、授权&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;usermod -aG wheel,docker docker_manager
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;9、启动 Docker CE&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; sudo systemctl enable docker
 sudo systemctl start docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时在命令行中输入“docker info”之后，能够展示docker相关信息，就表示docker安装成功。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker info
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10、镜像加速：&lt;/p&gt;
&lt;p&gt;编辑daemon.json文件（首次安装daemon.json是个新文件，不要惊讶）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/docker/daemon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    {
        &amp;quot;registry-mirrors&amp;quot;: [
            &amp;quot;https://registry.docker-cn.com&amp;quot;
        ]
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存，sudo systemctl restart docker重启即可。&lt;/p&gt;
&lt;p&gt;4、总结&lt;br&gt;
上面针对docker使用了一种比较通俗诙谐的语言来讲述，也是为了方便读者能容易的解读和理解，理解并且成功安装docker之后，你们就会想方设法的要把自己的web项目部署到docker了，这我没说错吧，大家可以网上查找一些资料去学习这一块。&lt;/p&gt;
&lt;p&gt;学习转载：https://www.cnblogs.com/myprogramer/p/10288634.html&lt;/p&gt;
">docker的安装与使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/nodejs-chang-yong-gong-ju-utilinherits"" data-c="
          &lt;p&gt;util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。&lt;/p&gt;
&lt;p&gt;util.inherits&lt;br&gt;
util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。&lt;/p&gt;
&lt;p&gt;JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。&lt;/p&gt;
&lt;p&gt;在这里我们只介绍util.inherits 的用法，示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var util = require(&#39;util&#39;); 
function Base() { 
    this.name = &#39;base&#39;; 
    this.base = 1991; 
    this.sayHello = function() { 
    console.log(&#39;Hello &#39; + this.name); 
    }; 
} 
Base.prototype.showName = function() { 
    console.log(this.name);
}; 
function Sub() { 
    this.name = &#39;sub&#39;; 
} 
util.inherits(Sub, Base); 
var objBase = new Base(); 
objBase.showName(); 
objBase.sayHello(); 
console.log(objBase); 
var objSub = new Sub(); 
objSub.showName(); 
//objSub.sayHello(); 
console.log(objSub);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;base 
Hello base 
{ name: &#39;base&#39;, base: 1991, sayHello: [Function] } 
sub 
{ name: &#39;sub&#39; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。&lt;/p&gt;
&lt;p&gt;同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node.js:201 
throw e; // process.nextTick error, or &#39;error&#39; event on first tick 
^ 
TypeError: Object #&amp;lt;Sub&amp;gt; has no method &#39;sayHello&#39; 
at Object.&amp;lt;anonymous&amp;gt; (/home/byvoid/utilinherits.js:29:8) 
at Module._compile (module.js:441:26) 
at Object..js (module.js:459:10) 
at Module.load (module.js:348:31) 
at Function._load (module.js:308:12) 
at Array.0 (module.js:479:10) 
at EventEmitter._tickCallback (node.js:192:40)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转载自https://www.cnblogs.com/yuwenjing0727/p/8135608.html&lt;/p&gt;
">Node.js 常用工具 （util.inherits）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/nuxt-fu-wu-duan-xuan-ran-he-yu-xuan-ran-de-qu-bie"" data-c="
          &lt;p&gt;nuxt分spa和非spa，预渲染直接nuxt generate打好的静态页面放在服务器就能访问(也是服务端渲染)， 服务端渲染需要先build完，把打出来的项目放到服务器，然后允许start，还要配置nginx转发&lt;br&gt;
使用nuxt的服务端渲染插件在node中可以直接返回&lt;br&gt;
预渲染不像服务器渲染那样即时编译 HTML，它只在构建时为了特定的路由生成特定的几个静态页面，等于我们可以通过 Webpack 插件将一些特定页面组件 build 时就编译为 html 文件，直接以静态资源的形式输出给搜索引擎。预渲染不执行js的，只适应于纯静态页面&lt;br&gt;
先说结论，都必然会优化SEO，原因如下：&lt;/p&gt;
&lt;p&gt;1、seo的本质是爬虫动态抓取根html里面的关键标签关键字；&lt;br&gt;
2、现代主流前端开发框架基本都是html拉回来之后，异步执行js动态挂载dom，根html在渲染之前里面提供给爬虫的信息极少；&lt;/p&gt;
&lt;p&gt;综上，如果不做服务器渲染或预渲染，seo只能抓到手动配置的顶级标签的关键字，效率与效果非常差&lt;br&gt;
不论是服务器渲染还是预渲染，它们都能“加速浏览器显示页面的速度”和seo优化。首先客户端程序只有js。现代网页出现以后这些js程度越来越复杂，于是必须有一些类似react、angular这样的东西。但这些东西全都有一个问题：第一次渲染结束前，页面是白的。于是有了服务端渲染：如果服务器恰好是nodejs，那么可以让服务器提前运行“第一次渲染”。浏览器只需要显示就好了，如果需要，再进行以后的渲染。&lt;/p&gt;
">nuxt 服务端渲染和预渲染的区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://www.sequelize.com.cn/&#34;&gt;Sequelize 中文文档&lt;/a&gt;&lt;br&gt;
可以先看文档，文档很全，它的语句帮我们做了很多处理，而且很精简，让我们不用死记硬背sql语句，也不用去库里建表。&lt;/p&gt;
&lt;h3 id=&#34;连接数据库&#34;&gt;连接数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;连接到数据库
要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将连接参数分别传递到 Sequelize 构造函数或通过传递一个连接 URI 来完成：

const { Sequelize } = require(&#39;sequelize&#39;);

// 方法 1: 传递一个连接 URI
const sequelize = new Sequelize(&#39;sqlite::memory:&#39;) // Sqlite 示例
const sequelize = new Sequelize(&#39;postgres://user:pass@example.com:5432/dbname&#39;) // Postgres 示例

// 方法 2: 分别传递参数 (sqlite)
const sequelize = new Sequelize({
  dialect: &#39;sqlite&#39;,
  storage: &#39;path/to/database.sqlite&#39;
});

// 方法 3: 分别传递参数 (其它数据库)
const sequelize = new Sequelize(&#39;database&#39;, &#39;username&#39;, &#39;password&#39;, {
  host: &#39;localhost&#39;,
  dialect: /* 选择 &#39;mysql&#39; | &#39;mariadb&#39; | &#39;postgres&#39; | &#39;mssql&#39; 其一 */
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;定义模型-定义表结构&#34;&gt;定义模型 （定义表结构）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;module.exports = function(sequelize, DataTypes) {
  return sequelize.define(
    &#39;project&#39;,
    {
      id: {
        type: DataTypes.INTEGER(11),
        allowNull: false,
        primaryKey: true,
        autoIncrement: true
      },
      name: { type: DataTypes.STRING(255), allowNull: true },
      title: { type: DataTypes.STRING(255), allowNull: true },
      report_fix_id: { type: DataTypes.STRING(1000), allowNull: true },
      fix_url: { type: DataTypes.STRING(2000), allowNull: true },
      ignore_key: {
        type: DataTypes.STRING(2000),
        allowNull: true,
        comment: &#39;简化打印对象中比较大的对象&#39;
      },
      env: {
        type: DataTypes.STRING(255),
        allowNull: true,
        comment: &#39;哪些环境能上报日志&#39;
      },
      report_interval: {
        type: DataTypes.INTEGER(11),
        allowNull: true,
        comment: &#39;上报时间间隔&#39;
      },
      ctime: {
        type: DataTypes.INTEGER(10),
        allowNull: true,
        get() {
          return moment
            .unix(this.getDataValue(&#39;ctime&#39;))
            .format(&#39;YYYY/MM/DD HH:mm:ss&#39;)
        }
      },
      del: { type: DataTypes.INTEGER(1), allowNull: true, defaultValue: &#39;0&#39; }
    },
    {
      tableName: &#39;project&#39;
    }
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;模型同步-真正从数据库创建&#34;&gt;模型同步 （真正从数据库创建）&lt;/h3&gt;
&lt;p&gt;定义模型时,你要告诉 Sequelize 有关数据库中表的一些信息. 但是,如果该表实际上不存在于数据库中怎么办？ 如果存在,但具有不同的列,较少的列或任何其他差异,该怎么办？&lt;/p&gt;
&lt;p&gt;这就是模型同步的来源.可以通过调用一个异步函数(返回一个Promise)model.sync(options). 通过此调用,Sequelize 将自动对数据库执行 SQL 查询. 请注意,这仅更改数据库中的表,而不更改 JavaScript 端的模型.&lt;/p&gt;
&lt;p&gt;User.sync() - 如果表不存在,则创建该表(如果已经存在,则不执行任何操作)&lt;/p&gt;
&lt;h4 id=&#34;usersync-force-true-将创建表如果表已经存在则将其首先删除-这个不要用也最好别试&#34;&gt;User.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除 （这个不要用，也最好别试）&lt;/h4&gt;
&lt;p&gt;User.sync({ alter: true }) - 这将检查数据库中表的当前状态(它具有哪些列,它们的数据类型等),然后在表中进行必要的更改以使其与模型匹配.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sequelize
  .authenticate()
  .then(() =&amp;gt; {
    console.log(&#39;数据库连接成功&#39;.green)
    // sequelize.sync({ alter: true })
  })
  .catch(err =&amp;gt; {
    console.log(&#39;数据库连接失败&#39;.red)
  })
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建实例修改内容insert&#34;&gt;创建实例（修改内容INSERT）&lt;/h3&gt;
&lt;p&gt;尽管模型是一个类,但是你不应直接使用 new 运算符来创建实例. 相反,应该使用 build 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const jane = User.build({ name: &amp;quot;Jane&amp;quot; });
console.log(jane instanceof User); // true
console.log(jane.name); // &amp;quot;Jane&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是,以上代码根本无法与数据库通信(请注意,它甚至不是异步的)！ 这是因为 build 方法仅创建一个对象,该对象 表示 可以 映射到数据库的数据. 为了将这个实例真正保存(即持久保存)在数据库中,应使用 save 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;await jane.save();
console.log(&#39;Jane 已保存到数据库!&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意,从上面代码段中的 await 用法来看,save 是一种异步方法. 实际上,几乎每个 Sequelize 方法都是异步的. build 是极少数例外之一.&lt;/p&gt;
&lt;p&gt;非常有用的捷径: create 方法&lt;br&gt;
Sequelize提供了 create 方法,该方法将上述的 build 方法和 save 方法合并为一个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const jane = await User.create({ name: &amp;quot;Jane&amp;quot; });
// Jane 现在存在于数据库中！
console.log(jane instanceof User); // true
console.log(jane.name); // &amp;quot;Jane&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;简单-select-查询&#34;&gt;简单 SELECT 查询&lt;/h3&gt;
&lt;p&gt;你可以使用 findAll 方法从数据库中读取整个表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 查询所有用户
const users = await User.findAll();
console.log(users.every(user =&amp;gt; user instanceof User)); // true
console.log(&amp;quot;All users:&amp;quot;, JSON.stringify(users, null, 2));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相当于sql语句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嗯，写一些建表与查询的流程，照着官网抄也没什么意思。使用这个我们可以很轻松的操作数据库，使我们写node接口的时候效率翻倍～&lt;/p&gt;
">Sequelize node连接数据库的ORM</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/shell-dollar-huo-qu-han-shu-fan-hui-zhi-huo-zhe-shang-yi-ge-ming-ling-de-tui-chu-zhuang-tai"" data-c="
          &lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;?&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;否&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;标&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;志&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;如&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;果&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;则&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;? 是上一个程序执行是否成功的标志，如果执行成功则&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;程&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;序&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;执&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;否&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;成&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;功&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;标&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;志&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;如&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;果&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;执&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;成&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;功&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;? 为0，否则 不为0。&lt;br&gt;
比如判断一个node服务是该启动还是该重启，则可以执行pm2 info ***&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1644843836198.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">shell $? 获取函数返回值或者上一个命令的退出状态</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/docker-zhong-shi-yong-redis"" data-c="
          &lt;p&gt;项目中频繁使用Redis，为了不用每次打开Redis目录去启动Redis想到了Docker可以作为Redis的容器 直接下载使用就行 把Docker使用Redis的过程分享下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;拉取redis    （如果想直接运行也可以直接执行第二步省略第一步）
   docker pull redis

   拉取完成后可使用 docker images 查看镜像列表检查
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;后台运行redis server
   
   docker run --name redis-test -p 6379:6379 -d redis
   或者 docker run --name redis-test -p 6379:6379  --rm -d redis

   -d表示后台运行 
   -p表示本机端口映射到运行的容积端口  第一个是本机端口 第二个是容器端口
   --rm表示用完自动删除 容器停止运行后自动删除  一般不用
   --name表示指定名称 之后会用到
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 客户端连接redis 
   
   docker run -it --rm  redis redis-cli -h 192.168.1.99
   或者 完整 docker run -it --rm redis redis-cli -h 192.168.1.99 -p 6379 -a 123123
   
   -it表示运行后进入容器内部命令模式
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;启动已关闭的redis服务
   步骤二指定了redis的名称为redis-test 执行命令 redis start redis-test 启动redis服务
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;不小心关掉了正在连接的客户端界面redis-cli 
  - 查找当前运行的容器 docker ps  
  - 直接进入容器中 docker attach 容器标识
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;删除容器
   - docker rm [containerName||ID] 或者强制删除加-f参数
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐一个好用的redis可视化软件，免费的，“Another Redis Desktop Manager” 地址：https://github.com/qishibo/AnotherRedisDesktopManager/&lt;/p&gt;
&lt;!-- more --&gt;
">docker中使用redis</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/wo-shi-ce-shi"" data-c="
          &lt;p&gt;作用：时间戳转化个格式&lt;/p&gt;
&lt;p&gt;原因：数据库中为了快速查询，一般保持日期是int(1415873634479),但是这样查询的时候很难知道确切的日期&lt;/p&gt;
&lt;p&gt;格式：select from_unixtime(1459338786);2016-03-30 19:53:06&lt;/p&gt;
&lt;p&gt;select from_unixtime(1459338786, &#39;%Y-%m-%d %H:%i:%s&#39;);2016-03-30 19:53:06&lt;/p&gt;
&lt;p&gt;SELECT id ,FROM_UNIXTIME(&#39;last_update_time&#39;) FROM current_inventory WHERE seat_code = &#39;hk2-i0302c03&#39; //字段要加引号&lt;/p&gt;
&lt;p&gt;备注：默认转化格式是%Y-%m-%d %H:%i:%s&lt;/p&gt;
&lt;p&gt;格式说明：&lt;/p&gt;
&lt;p&gt;%M 月名字(January～December)&lt;br&gt;
%W 星期名字(Sunday～Saturday)&lt;br&gt;
%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）&lt;br&gt;
%Y 年, 数字, 4 位&lt;br&gt;
%y 年, 数字, 2 位&lt;br&gt;
%a 缩写的星期名字(Sun～Sat)&lt;br&gt;
%d 月份中的天数, 数字(00～31)&lt;br&gt;
%e 月份中的天数, 数字(0～31)&lt;br&gt;
%m 月, 数字(01～12)&lt;br&gt;
%c 月, 数字(1～12)&lt;br&gt;
%b 缩写的月份名字(Jan～Dec)&lt;br&gt;
%j 一年中的天数(001～366)&lt;br&gt;
%H 小时(00～23)&lt;br&gt;
%k 小时(0～23)&lt;br&gt;
%h 小时(01～12)&lt;br&gt;
%I 小时(01～12)&lt;br&gt;
%l 小时(1～12)&lt;br&gt;
%i 分钟, 数字(00～59)&lt;br&gt;
%r 时间,12 小时(hh:mm:ss [AP]M)&lt;br&gt;
%T 时间,24 小时(hh:mm:ss)&lt;br&gt;
%S 秒(00～59)&lt;br&gt;
%s 秒(00～59)&lt;br&gt;
%p AM或PM&lt;br&gt;
%w 一个星期中的天数(0=Sunday ～6=Saturday ）&lt;br&gt;
%U 星期(0～52), 这里星期天是星期的第一天&lt;br&gt;
%u 星期(0～52), 这里星期一是星期的第一天&lt;br&gt;
%% 一个文字%&lt;/p&gt;
&lt;p&gt;原文链接：https://blog.csdn.net/yangliu4683/article/details/78340939&lt;/p&gt;
">mysql 时间戳格式化函数from_unixtime</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/nginx-dai-cookie-yun-xu-kua-yu-pei-zhi"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-nginx&#34;&gt;server {
  listen 9003;
  server_name *****.com;
  index index.html index.htm;
  location / {
    proxy_pass http://127.0.0.1:4001;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-for $remote_addr;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Port $server_port;
    proxy_connect_timeout 300;

    # 指定允许跨域的方法，*代表所有
    add_header Access-Control-Allow-Methods *;

    # 预检命令的缓存，如果不缓存每次会发送两次请求
    add_header Access-Control-Max-Age 3600;

    # 带cookie请求需要加上这个字段，并设置为true
    add_header Access-Control-Allow-Credentials true;

    # 表示允许这个域跨域调用（客户端发送请求的域名和端口）
    # $http_origin动态获取请求客户端请求的域   不用*的原因是带cookie的请求不支持*号
    add_header Access-Control-Allow-Origin $http_origin;

    # 表示请求头的字段 动态获取
    add_header Access-Control-Allow-Headers $http_access_control_request_headers;

    # OPTIONS预检命令，预检命令通过时才发送请求
    # 检查请求的类型是不是预检命令
    if ($request_method = OPTIONS){
      return 200;
    }

  }
&lt;/code&gt;&lt;/pre&gt;
">nginx带cookie允许跨域配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/hello-gridea"" data-c="
          &lt;p&gt;强制commit规范常用的有两种，一种是在package项目中的gitHooks选项下的&amp;quot;commit-msg&amp;quot;设置自己的commit规则脚本。比如我要强制commit内容为feat:加空格xxx或者fix:加空格xxx，如果不符合给出相应提示，则我应该这么写：&lt;br&gt;
&lt;img src=&#34;https://note.youdao.com/yws/public/resource/d60e09a825bba46e1719f2dc06a2f7e3/xmlnote/302F691AA217499EA4DC783EA5E361B8/3538&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
verify-commit-msg.js中代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const chalk = require(&amp;quot;chalk&amp;quot;);
const msgPath = process.env.GIT_PARAMS;
const msg = require(&amp;quot;fs&amp;quot;)
  .readFileSync(msgPath, &amp;quot;utf-8&amp;quot;)
  .trim();

const commitRE = /^(revert: )?(feat|fix|polish|docs|style|refactor|perf|test|workflow|ci|chore|types|build|Merge)(\(.+\))?: .{1,50}|Merge /;

if (!commitRE.test(msg)) {
  console.error(
    `  ${chalk.bgRed.white(&amp;quot; ERROR &amp;quot;)} ${chalk.red(
      `invalid commit message format.`
    )}\n\n` +
      chalk.red(
        `  Proper commit message format is required for automated changelog generation. Examples:\n\n`
      ) +
      `    ${chalk.green(`feat: add &#39;comments&#39; option`)}\n` +
      `    ${chalk.green(`fix: handle events on blur (close #28)`)}\n\n` +
      chalk.red(
        `  You can also use ${chalk.cyan(
          `yarn commit`
        )} to interactively generate a commit message.\n`
      )
  );
  process.exit(1);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种是也可以使用&lt;a href=&#34;https://www.npmjs.com/package/git-cz/v/4.2.0&#34;&gt;git-cz&lt;/a&gt; 通过交互的方式生成更专业的commit，效果如下&lt;br&gt;
&lt;img src=&#34;https://weidadeda.github.io/post-images/1642390440510.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">如何自定义commit规范</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/js-dui-xiang-ji-cheng"" data-c="
          &lt;p&gt;一个对象没有某些属性和方法，另一个对象有，拿过来使用，就是继承&lt;/p&gt;
&lt;h3 id=&#34;继承的实现方式&#34;&gt;继承的实现方式&lt;/h3&gt;
&lt;h4 id=&#34;混入式继承&#34;&gt;混入式继承&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var obj = {};
var obj1 = {
    money : 10000000,
    car : 100,
    brand: &amp;quot;布加迪威航&amp;quot;,
    huaqian: function(){
        console.log(&amp;quot;不差钱，随便花&amp;quot;);
    }
};
console.log(obj);
for(var k in obj1){
    //money
    //car
    //brand
    //huaqian
    obj[k] = obj1[k];
}

console.log(obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;原型继承的方式&#34;&gt;原型继承的方式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;通过修改原型实现的继承 就是原型继承&lt;/li&gt;
&lt;li&gt;通过构造函数创建出来的对象继承自构造函数的原型对象&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//Person.prototype
var human = {
    gender:&amp;quot;female&amp;quot;,
    height: 170,
    weight: 50
}
function Person(){
}
Person.prototype.name = &amp;quot;王莉莉&amp;quot;;

for(var k in human){
    Person.prototype[k] = human[k];
}
var p = new Person();
console.log(p.name,p.gender,p.height,p.weight);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;修改原型对象&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Person.prototype.maimeng = function (){
    console.log(&amp;quot;感觉自己萌萌哒&amp;quot;);
}

p.maimeng();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;替换原型对象&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Person.prototype = human;
var p = new Person();
console.log(p.gender);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;经典继承&#34;&gt;经典继承&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;调用一个方法，就能实现继承&lt;/li&gt;
&lt;li&gt;var obj1 = Object.create(obj)&lt;/li&gt;
&lt;li&gt;创建出来一个新的继承自参数 obj 的对象 obj1&lt;/li&gt;
&lt;li&gt;其实内部使用的就是原型继承&lt;/li&gt;
&lt;li&gt;ES5才支持的这个方法 需要考虑兼容性问题&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var human = {
    name: &amp;quot;王莉莉&amp;quot;,
    gender: &amp;quot;female&amp;quot;,
    dance :function(){
        console.log(&amp;quot;二人转，转转转&amp;quot;)
    }
}
var obj = Object.create(human);

console.log(obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;处理经典继承的兼容性问题&#34;&gt;处理经典继承的兼容性问题&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;if(Object.create){
    var obj = Object.create({name:&amp;quot;李狗二&amp;quot;,age:18});
}else{
    Object.create = function(obj){
		//在这个函数中要实现的功能
		//就是，创建一个对象，将obj设置为该对象的原型

		//要设置原型，只能通过两种方式，
		// 一种是 对象.__proto__  另外一种是 构造函数.prototype
		//由于__proto__这个属性有兼容性问题，所以不使用
		//就只能使用 构造函数.prototype 去替换原型对象了

        function F(){}
        F.prototype = obj;
        var result = new F();
        return result;
    }
}

//不推荐直接修改内置对象，因为在多人开发的时候，会产生冲突

Object.creat = function () {
    console.log(&amp;quot;我是李二狗，我的create方法就是用来输出这句话的，哈哈哈&amp;quot;);
}

function hanyingxinCreate(obj){
    if(Object.create){
        return Object.creat(obj);
    }else{
        function F(){}
        F.prototype = obj;
        var result = new F();
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内容转载自：https://blog.ihoey.com/posts/javascript/2016-06-15-javascript-inherit.html&lt;/p&gt;
">js对象继承</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/guanxi"" data-c="
          &lt;h3 id=&#34;prototype显示原型是类的原型指向该方法的原型对象-proto隐式原型是对象的原型指向该对象的构造函数的原型对象&#34;&gt;prototype（显示原型）是“类”的原型，指向该方法的原型对象。&lt;strong&gt;proto&lt;/strong&gt;（隐式原型）是对象的原型，指向该对象的构造函数的原型对象。&lt;/h3&gt;
&lt;p&gt;JS当然没有“类”，只有constructor。&lt;br&gt;
constructor就是当你new fn()时的那个“fn”。&lt;br&gt;
fn的时候，产生的实例的__proto__指向fn.prototype，两者是同一个东西。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Foo(){}
var foo = new Foo()
Foo.prototype.__proto__ === Object.prototype //true
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;prototype：每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;proto&lt;/strong&gt;：JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过__proto__来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf().&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Note: Object.prototype 这个对象是个例外，它的__proto__值为null&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;隐式原型指向创建这个对象的函数constructor的prototype&#34;&gt;隐式原型指向创建这个对象的函数(constructor)的prototype&lt;/h4&gt;
&lt;p&gt;__proto__的指向到底如何判断呢？根据ECMA定义 &#39;to the value of its constructor’s &amp;quot;prototype&amp;quot; &#39; ----指向创建这个对象的函数（也就是构造函数）的显式原型。所以关键的点在于找到创建这个对象的构造函数，接下来就来看一下JS中对象被创建的方式，一眼看过去似乎有三种方式：（1）对象字面量的方式 （2）new 的方式 （3）ES5中的Object.create() 但是我认为本质上只有一种方式，也就是通过new来创建。为什么这么说呢，首先字面量的方式是一种为了开发人员更方便创建对象的一个语法糖，本质就是 var o = new Object(); o.xx = xx;o.yy=yy; 再来看看Object.create(),这是ES5中新增的方法，在这之前这被称为原型式继承。&lt;/p&gt;
&lt;p&gt;下面看几个例子练习一下：&lt;/p&gt;
&lt;p&gt;内建对象(built-in object)：比如Array()，Array.prototype.__proto__指向什么？Array.prototype也是一个对象，对象就是由 Object() 这个构造函数创建的，因此Array.prototype.&lt;strong&gt;proto&lt;/strong&gt; === Object.prototype //true，或者也可以这么理解，所有的内建对象都是由Object()创建而来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义对象&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Foo(){}
var foo = new Foo()
Foo.prototype.__proto__ === Object.prototype //true 理由同上
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//这时我们想让Foo继承Bar
function Bar(){}
Foo.prototype = new Bar()
 Foo.prototype.__proto__ === Bar.prototype //true
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//我们不想让Foo继承谁，但是我们要自己重新定义Foo.prototype
Foo.prototype = {
  a:10,
  b:-10
}
//这种方式就是用了对象字面量的方式来创建一个对象，根据前文所述 
Foo.prototype.__proto__ === Object.prototype
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上情况都等于完全重写了Foo.prototype，所以Foo.prototype.constructor也跟着改变了，于是乎constructor这个属性和原来的构造函数Foo（）也就切断了联系。&lt;/p&gt;
&lt;h4 id=&#34;此外&#34;&gt;此外：&lt;/h4&gt;
&lt;p&gt;构造函数Foo()除了是方法，也是对象啊，它也有__proto__属性，指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。其实除了Foo()，Function(), Object()也是一样的道理。原型对象也是对象啊，它的__proto__属性，又指向谁呢？同理，指向它的构造函数的原型对象呗。这里是Object.prototype.最后，Object.prototype的__proto__属性指向null。&lt;/p&gt;
&lt;h4 id=&#34;构造函数的隐式原型&#34;&gt;构造函数的隐式原型&lt;/h4&gt;
&lt;p&gt;既然是构造函数那么它就是Function（）的实例，因此也就指向Function.prototype,比如 Object.&lt;strong&gt;proto&lt;/strong&gt; === Function.prototype&lt;/p&gt;
&lt;h3 id=&#34;instanceof&#34;&gt;instanceof&lt;/h3&gt;
&lt;p&gt;instanceof 操作符的内部实现机制和隐式原型、显式原型有直接的关系。instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。它的内部实现原理是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//设 L instanceof R 
//通过判断
 L.__proto__.__proto__ ..... === R.prototype ？
//最终返回true or false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是沿着L的__proto__一直寻找到原型链末端，直到等于R.prototype为止。知道了这个也就知道为什么以下这些奇怪的表达式为什么会得到相应的值了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Function instanceof Object // true 
 Object instanceof Function // true 
 Function instanceof Function //true
 Object instanceof Object // true
 Number instanceof Number //false
&lt;/code&gt;&lt;/pre&gt;
">__proto__和prototype的区别和关系？</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://weidadeda.github.io/post/about"" data-c="
          &lt;p&gt;欢迎来到我的小站呀，很高兴遇见你嘿嘿！🤝&lt;/p&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;关于这个站呢,就是记录下平时记不太住的还有一些自己感兴趣喜欢的一些东西
顺便也分享给大家吧!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;关于我&#34;&gt;👨‍💻 关于我&lt;/h2&gt;
&lt;p&gt;一名前端开发，95后，现居北京，养了两只猫，喜欢健身💪喜欢研究历史📒&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;邮箱：18310536322@163.com&lt;/li&gt;
&lt;li&gt;微信：18310536322&lt;/li&gt;
&lt;/ul&gt;
">关于</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;暂时性死区(TDZ)是针对&#39;const&#39;,&#39;let&#39;这两个关键字而产生的概念。&lt;br&gt;\n首先变量提升这个js的基本概念无法撼动，&#39;const&#39;和&#39;let&#39;作为块级作用域也不能避免。&lt;br&gt;\n和&#39;var&#39;不同，这两个关键字将作用域限制在了‘块’中，且规定了在该块中，由这两个关键字定义的变量已经被分配内存。&lt;br&gt;\n即其实已经&#39;存在&#39;了，但程序未执行到声明处时，访问该变量都会报引用错误。&lt;br&gt;\n这个时候，对于该变量来说就是&#39;暂时性死区&#39;，通俗来说就是该变量存在，但并未完全存在&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;if (true) {\n  // TDZ开始\n  tmp = &#39;abc&#39;; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;var tmp = 123;\nif (true) {\n  tmp = &#39;abc&#39;; // ReferenceError\n  let tmp;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。&lt;/p&gt;\n&lt;p&gt;ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 不报错\nvar x = x;\n// 报错\nlet x = x;\n// ReferenceError: x is not defined\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“&lt;/p&gt;\n&lt;p&gt;本文转载自https://blog.csdn.net/zzzzz111333/article/details/122562000&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;js-zan-shi-xing-si-qu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;js暂时性死区&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-04-15 11:10:36&#34;,&#34;dateFormat&#34;:&#34;2022-04-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/js-zan-shi-xing-si-qu&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:105000,&#34;words&#34;:465,&#34;minutes&#34;:2},&#34;description&#34;:&#34;\n暂时性死区(TDZ)是针对&#39;const&#39;,&#39;let&#39;这两个关键字而产生的概念。\n首先变量提升这个js的基本概念无法撼动，&#39;const&#39;和&#39;let&#39;作为块级作用域也不能避免。\n和&#39;var&#39;不同，这两个关键字将作用域限制在了‘块’中，且规定了...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;pre&gt;&lt;code&gt;最近在搞视频直播，其中有一个功能是视频镜像，那么有两种实现方式。\n- 一种是老师端点击镜像，通过css把自己的video标签镜像，然后发送信令给学生端，学生端收到消息之后也通过css去实现镜像\n- 第二种就是老师端对视频流做一个镜像处理，学生端无需操作，很显然第二种方法比较好\n\n怎么实现对视频流的镜像呢，首先要知道的就是视频是由一帧帧的图片组合而成，我们要对视频流镜像，首先要对图片进行镜像。\n\n对图片镜像的话，就要对ImageData做处理\n首先了解一下什么是ImageData：\n&amp;gt; ImageData 接口描述 canvas 元素的一个隐含像素数据的区域。使用 ImageData() 构造函数创建或者使用和 canvas 在一起的 CanvasRenderingContext2D 对象的创建方法： createImageData() 和 getImageData()。也可以使用 putImageData() 设置 canvas 的一部分。\n\n## 我们先以旋转图片为例子做个说明\n### 基本原理1——像素矩阵变换\nImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：\n\n- width  图片宽度，单位是像素\n- height  图片高度，单位是像素\n- data  [Uint8ClampedArray](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray)类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。\ndata属性返回一个 Uint8ClampedArray，它可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是&amp;quot;RGBA&amp;quot;格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。\n\n具体请看[像素操作](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas)\n\n我们通过ImageData可以对图片的每个像素点做操作。比如我们现在要将图片向右旋转90度\n\n一个 4 × 3 像素的原始图片，可以看作如下形式的像素矩阵 A：\n![](https://weidadeda.github.io/post-images/1647858122464.png)\n图片向右旋转 90°，实质就是设法将 A 变为 A’ ——\n![](https://weidadeda.github.io/post-images/1647858132107.png)\n这可以通过原矩阵一次 转置、与多次初等 列 变换（逆序排列各列）得到：\n![](https://weidadeda.github.io/post-images/1647858162556.png)\n同理，图片向左旋转 90°，实际上就是得到矩阵 A’&#39; ：\n![](https://weidadeda.github.io/post-images/1647858170777.png)\n这可以通过原矩阵一次 转置、与多次初等 行 变换（逆序排列各行）得到——\n![](https://weidadeda.github.io/post-images/1647858177575.png)\n### 基本原理2——像素数组与矩阵的对应关系\n由于 ImageData.data 对应一个数组，对于 4 × 3 的图片而言，ImageData.data 就是一个具有 48 个元素的数组 D，不妨每个元素的值就是其下标值，则：\n```js\nD=[0,1,2,3,4,5,6,7...44,45,46,47]\n```\n\n其中：\n元组 (0, 1, 2, 3) 表示第 1(= 0 / 4 + 1) 个像素的颜色为 rgba(0, 1, 2, 3/255)；\n元组 (4, 5, 6, 7) 表示第 2(= 4 / 4 + 1) 个像素的颜色为 rgba(4, 5, 6, 7/255)；\n元组 (8, 9, 10, 11) 表示第 3(= 8 / 4 + 1) 个像素的颜色为 rgba(8, 9, 10, 11/255)；\n…\n\n元组 (i, i+1, i+2, i+3) 表示第 (i / 4 + 1) 个像素的颜色为 rgba(i, i+1, i+2, (i+3)/255)；\n…\n元组 (44, 45, 46, 47) 表示第 12(= 44 / 4 + 1) 个像素的颜色为 rgba(44, 45, 46, 47/255)。\n\n可见从 0 开始遍历 D 数组，每次递增 4 个单位，即可依次得到各个像素的红色值 R，再依次加1、加2、加3，即得到对应的绿色值 G、蓝色值 B、等效 α 通道值 A。\n\n反之，如果知道图片的像素尺寸为 4 × 3，则可以通过下图找到数组 D 的各个元素：\n![](https://weidadeda.github.io/post-images/1647858189293.png)\n\n可见各像素点是按照 从左至右、从上至下 的顺序排列的。设图片总宽度像素为 W，总高度像素为 H，任一像素点 P 的坐标为 (x, y)，P 的红色值在数组 D 的下标为 R(x, y)，则：\n```js\nR(x,y)=(x+W*y)×4\n```\n验证：（x 与 y 均从 0 开始计数）\n\nR(2, 1) = (2 + 1 × 4) × 4 = 24\nR(1, 2) = (1 + 2 × 4) × 4 = 36\nR(3, 1) = (3 + 1 × 4) × 4 = 28\n\n拿到了 R(x, y)，不难求出该像素的纵向中心对称像素 Rh(x, y)、横向中心对称像素 Rw(x, y)、以及主对角线对称像素 Rd(x, y)：\n```js\nRh(x,y)=[x+W*(H−1−y)]*4 // 初等行变换\nRw(x,y)=[(W−1−x)+W*y]*4 // 初等列变换\nRd(x,y)=(y+H*x)*4\n```\n\n### 具体实现\n\n基本思路：\n\n- 通过 canvas 获取目标图片的 ImageData 对象；\n- 转置原图片数组，得到数组 AT；\n- 对 AT 执行一组初等行变换，使各行逆序排列，得到左旋 90° 效果；\n- 对 AT 执行一组初等列变换，使各列逆序排列，得到右旋 90° 效果；\n- 将新的像素数组写回图片源标签。\n\nHTML：\n```html\n&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;\n&amp;lt;head&amp;gt;\n    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;\n    &amp;lt;title&amp;gt;Rotate by ImageData&amp;lt;/title&amp;gt;\n    &amp;lt;style&amp;gt;\n        .image{ margin-top: 5px; }\n    &amp;lt;/style&amp;gt;\n&amp;lt;/head&amp;gt;\n&amp;lt;body&amp;gt;\n    &amp;lt;div class=&amp;quot;btns&amp;quot;&amp;gt;\n        &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;左转 90°&amp;quot; id=&amp;quot;turnLeft&amp;quot; /&amp;gt;\n        &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;右转 90°&amp;quot; id=&amp;quot;turnRight&amp;quot; /&amp;gt;\n    &amp;lt;/div&amp;gt;\n    &amp;lt;div class=&amp;quot;image&amp;quot;&amp;gt;\n        &amp;lt;img id=&amp;quot;fruit&amp;quot; src=&amp;quot;fruit.jpg&amp;quot; class=&amp;quot;image&amp;quot; alt=&amp;quot;fruit&amp;quot; title=&amp;quot;fruit&amp;quot; /&amp;gt;\n    &amp;lt;/div&amp;gt;\n    &amp;lt;script src=&amp;quot;imageRotate.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;\n&amp;lt;/body&amp;gt;\n\n&amp;lt;/html&amp;gt;\n```\nimageRotate.js：\n```js\ndocument.querySelector(&#39;#turnLeft&#39; ).addEventListener(&#39;click&#39;, e =&amp;gt; rotateImage(&#39;l&#39;))\ndocument.querySelector(&#39;#turnRight&#39;).addEventListener(&#39;click&#39;, e =&amp;gt; rotateImage(&#39;r&#39;))\n\nfunction rotateImage(direction = &#39;l&#39;) {\n    // 1. Prepare ImageData\n    let img = document.querySelector(&#39;#fruit&#39;)\n    const { width: W, height: H } = img\n    let cvs = document.createElement(&#39;canvas&#39;)\n    cvs.width = W\n    cvs.height = H\n    let ctx = cvs.getContext(&#39;2d&#39;)\n    ctx.drawImage(img, 0, 0)\n    let imgDt0 = ctx.getImageData(0, 0, W, H)\n    let imgDt1 = new ImageData(H, W)\n    let imgDt2 = new ImageData(H, W)\n    let dt0 = imgDt0.data\n    let dt1 = imgDt1.data\n    let dt2 = imgDt2.data\n\n    // 2. Transpose\n    let r = r1 = 0  // index of red pixel in old and new ImageData, respectively\n    for (let y = 0, lenH = H; y &amp;lt; lenH; y++) {\n        for (let x = 0, lenW = W; x &amp;lt; lenW; x++) {\n            r  = (x + lenW * y) * 4\n            r1 = (y + lenH * x) * 4\n            dt1[r1 + 0] = dt0[r + 0]\n            dt1[r1 + 1] = dt0[r + 1]\n            dt1[r1 + 2] = dt0[r + 2]\n            dt1[r1 + 3] = dt0[r + 3]\n        }\n    }\n    \n    // 3. Reverse width / height\n    for (let y = 0, lenH = W; y &amp;lt; lenH; y++) {\n        for (let x = 0, lenW = H; x &amp;lt; lenW; x++) {\n            r  = (x + lenW * y) * 4\n            r1 = direction === &#39;l&#39;\n                ? (x + lenW * (lenH - 1 - y)) * 4\n                : ((lenW - 1 - x) + lenW * y) * 4\n            dt2[r1 + 0] = dt1[r + 0]\n            dt2[r1 + 1] = dt1[r + 1]\n            dt2[r1 + 2] = dt1[r + 2]\n            dt2[r1 + 3] = dt1[r + 3]\n        }\n    }\n    \n    // 4. Redraw image\n    cvs.width = H\n    cvs.height = W\n    ctx.clearRect(0, 0, W, H)\n    ctx.putImageData(imgDt2, 0, 0, 0, 0, H, W)\n    img.src = cvs.toDataURL(&#39;image/jpeg&#39;, 1)\n}\n```\n\n运行结果：\n原始图片\n![](https://weidadeda.github.io/post-images/1647858200595.png)\n左转90度\n![](https://weidadeda.github.io/post-images/1647858207477.png)\n右转90度\n![](https://weidadeda.github.io/post-images/1647858214763.png)\n\n好了，现在实现了图片旋转，那么我们接着套用公式实现图片镜像和视频镜像\n\nhtml\n```html\n&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;\n&amp;lt;head&amp;gt;\n    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt;\n    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot; /&amp;gt;\n    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot; /&amp;gt;\n    &amp;lt;title&amp;gt;js通过浏览器调用摄像头&amp;lt;/title&amp;gt;\n    &amp;lt;style&amp;gt;\n    #video {\n        /* transform: rotate3d(1, 1, 1, 45deg); */\n    }\n    &amp;lt;/style&amp;gt;\n&amp;lt;/head&amp;gt;\n&amp;lt;body&amp;gt;\n    &amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;\n    &amp;lt;video id=&amp;quot;video&amp;quot; width=&amp;quot;500px&amp;quot; height=&amp;quot;500px&amp;quot; autoplay=&amp;quot;autoplay&amp;quot; /&amp;gt;\n    &amp;lt;/div&amp;gt;\n    &amp;lt;canvas width=&amp;quot;500&amp;quot; height=&amp;quot;500&amp;quot; id=&amp;quot;canvas&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;\n    &amp;lt;video\n    id=&amp;quot;video2&amp;quot;\n    width=&amp;quot;500px&amp;quot;\n    height=&amp;quot;500px&amp;quot;\n    autoplay=&amp;quot;autoplay&amp;quot;\n    controls=&amp;quot;controls&amp;quot;\n    /&amp;gt;\n&amp;lt;/body&amp;gt;\n&amp;lt;!-- &amp;lt;script src=&amp;quot;./test.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;\n&amp;lt;script&amp;gt;\n    function getMedia() {\n    let video = document.getElementById(&amp;quot;video&amp;quot;);\n    let constraints = {\n        video: { width: 500, height: 500 },\n        audio: false,\n    };\n    navigator.getUserMedia =\n        navigator.getUserMedia ||\n        navigator.webkitGetUserMedia ||\n        navigator.mozGetUserMedia ||\n        navigator.msGetUserMedia;\n    let promise = navigator.mediaDevices.getUserMedia(\n        constraints,\n        function (stream) {\n        video.src = stream;\n        video.play();\n        },\n        function (error) {\n        console.log(error);\n        }\n    );\n    promise.then(function (MediaStream) {\n        video.srcObject = MediaStream;\n        video.play();\n    });\n    }\n\n    getMedia();\n    window.onload = () =&amp;gt; {\n    const data = [];\n    var recorder;\n    // 获取视频流之后，用canvas对视频进行反转，然后使用captureStream获取视频流，此时可以通过声网自定义流获取视频轨道getVideoTracks。代码中为了测试canvas转视频可用，调用了MediaRecorder录制\n    function imageDataHRevert(sourceData, newData) {\n        for (var i = 0, h = sourceData.height; i &amp;lt; h; i++) {\n        for (j = 0, w = sourceData.width; j &amp;lt; w; j++) {\n            newData.data[i * w * 4 + j * 4 + 0] =\n            // (y*W+x)*4\n            sourceData.data[i * w * 4 + (w - j) * 4  -4+ 0];\n            // (y*W+(W-x-1))*4\n            newData.data[i * w * 4 + j * 4 + 1] =\n            sourceData.data[i * w * 4 + (w - j) * 4 -4+ 1];\n\n            newData.data[i * w * 4 + j * 4 + 2] =\n            sourceData.data[i * w * 4 + (w - j) * 4 -4+ 2];\n\n            newData.data[i * w * 4 + j * 4 + 3] =\n            sourceData.data[i * w * 4 + (w - j) * 4-4 + 3];\n        }\n        }\n        return newData;\n    }\n    function imageDataVRevert(sourceData, newData) {\n        for (var i = 0, h = sourceData.height; i &amp;lt; h; i++) {\n        for (var j = 0, w = sourceData.width; j &amp;lt; w; j++) {\n            newData.data[i * w * 4 + j * 4 + 0] =\n            sourceData.data[(h - i) * w * 4 + j * 4 + 0];\n\n            newData.data[i * w * 4 + j * 4 + 1] =\n            sourceData.data[(h - i) * w * 4 + j * 4 + 1];\n\n            newData.data[i * w * 4 + j * 4 + 2] =\n            sourceData.data[(h - i) * w * 4 + j * 4 + 2];\n\n            newData.data[i * w * 4 + j * 4 + 3] =\n            sourceData.data[(h - i) * w * 4 + j * 4 + 3];\n        }\n        }\n\n        return newData;\n    }\n\n    function render() {\n        var canvas = document.getElementById(&amp;quot;canvas&amp;quot;);\n        var video = document.getElementById(&amp;quot;video&amp;quot;);\n        var ctx1 = canvas.getContext(&amp;quot;2d&amp;quot;);\n        ctx1.drawImage(video, 0, 0, 500, 500);\n        var imgData = ctx1.getImageData(0, 0, 500, 500);\n        var newImgData = ctx1.getImageData(0, 0, 500, 500);\n        const HRevet = imageDataHRevert(newImgData, imgData);\n        console.error(HRevet, &amp;quot;HRevet&amp;quot;);\n        // 亮一点\n        for (var i = 0; i &amp;lt; HRevet.data.length; i += 4) {\n        HRevet.data[i] += 5;\n        HRevet.data[i + 1] += 5;\n        HRevet.data[i + 2] += 5;\n        }\n        ctx1.putImageData(HRevet, 0, 0);\n        requestAnimationFrame(render);\n    }\n    requestAnimationFrame(render);\n    const stream = canvas.captureStream(30);\n    // todo 自定义视频 canvas.captureStream(30).getVideoTracks()[0]\n    console.error(stream, &amp;quot;stream&amp;quot;);\n    // 自己测试录制视频的，可以不用看\n    recorder = new MediaRecorder(stream, { mimeType: &amp;quot;video/webm&amp;quot; });\n    recorder.ondataavailable = function (event) {\n        if (event.data &amp;amp;&amp;amp; event.data.size) {\n        data.push(event.data);\n        }\n    };\n    recorder.onstop = () =&amp;gt; {\n        const url = URL.createObjectURL(new Blob(data, { type: &amp;quot;video/webm&amp;quot; }));\n        document.getElementById(&amp;quot;video2&amp;quot;).src = url;\n    };\n    recorder.start();\n    setTimeout(() =&amp;gt; {\n        recorder.stop();\n    }, 6000);\n    };\n&amp;lt;/script&amp;gt;\n&amp;lt;/html&amp;gt;\n```\n结果：\n![](https://weidadeda.github.io/post-images/1647859629847.png)\n&amp;lt;!-- more --&amp;gt;\n\n#### 大家看的可能有点懵，没关系，拿个纸画一下，然后去套用公式就好了，一次不懂就多试几次。看不懂一定要拿张纸画一下！\n\n简单的增加美白效果（亮度），可给每个rgb通道加特定值。\n```js\nr1 = (x + W * y) * 4;\nr1 = (x + W * (H - 1 - y)) * 4;\n```\n推荐一个美颜库：opencvjs  \n推荐一个人脸识别库：face-api.js https://www.cnblogs.com/neozhu/p/11771148.html\n\n部分内容参考自 https://blog.csdn.net/frgod/article/details/106055830\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;li-yong-imagedata-shi-xian-tu-pian-fan-zhuan-he-shi-pin-jing-xiang&#34;,&#34;abstract&#34;:&#34;&lt;pre&gt;&lt;code&gt;最近在搞视频直播，其中有一个功能是视频镜像，那么有两种实现方式。\n- 一种是老师端点击镜像，通过css把自己的video标签镜像，然后发送信令给学生端，学生端收到消息之后也通过css去实现镜像\n- 第二种就是老师端对视频流做一个镜像处理，学生端无需操作，很显然第二种方法比较好\n\n怎么实现对视频流的镜像呢，首先要知道的就是视频是由一帧帧的图片组合而成，我们要对视频流镜像，首先要对图片进行镜像。\n\n对图片镜像的话，就要对ImageData做处理\n首先了解一下什么是ImageData：\n&amp;gt; ImageData 接口描述 canvas 元素的一个隐含像素数据的区域。使用 ImageData() 构造函数创建或者使用和 canvas 在一起的 CanvasRenderingContext2D 对象的创建方法： createImageData() 和 getImageData()。也可以使用 putImageData() 设置 canvas 的一部分。\n\n## 我们先以旋转图片为例子做个说明\n### 基本原理1——像素矩阵变换\nImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：\n\n- width  图片宽度，单位是像素\n- height  图片高度，单位是像素\n- data  [Uint8ClampedArray](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray)类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。\ndata属性返回一个 Uint8ClampedArray，它可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是&amp;quot;RGBA&amp;quot;格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。\n\n具体请看[像素操作](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas)\n\n我们通过ImageData可以对图片的每个像素点做操作。比如我们现在要将图片向右旋转90度\n\n一个 4 × 3 像素的原始图片，可以看作如下形式的像素矩阵 A：\n![](https://weidadeda.github.io/post-images/1647858122464.png)\n图片向右旋转 90°，实质就是设法将 A 变为 A’ ——\n![](https://weidadeda.github.io/post-images/1647858132107.png)\n这可以通过原矩阵一次 转置、与多次初等 列 变换（逆序排列各列）得到：\n![](https://weidadeda.github.io/post-images/1647858162556.png)\n同理，图片向左旋转 90°，实际上就是得到矩阵 A’&#39; ：\n![](https://weidadeda.github.io/post-images/1647858170777.png)\n这可以通过原矩阵一次 转置、与多次初等 行 变换（逆序排列各行）得到——\n![](https://weidadeda.github.io/post-images/1647858177575.png)\n### 基本原理2——像素数组与矩阵的对应关系\n由于 ImageData.data 对应一个数组，对于 4 × 3 的图片而言，ImageData.data 就是一个具有 48 个元素的数组 D，不妨每个元素的值就是其下标值，则：\n```js\nD=[0,1,2,3,4,5,6,7...44,45,46,47]\n```\n\n其中：\n元组 (0, 1, 2, 3) 表示第 1(= 0 / 4 + 1) 个像素的颜色为 rgba(0, 1, 2, 3/255)；\n元组 (4, 5, 6, 7) 表示第 2(= 4 / 4 + 1) 个像素的颜色为 rgba(4, 5, 6, 7/255)；\n元组 (8, 9, 10, 11) 表示第 3(= 8 / 4 + 1) 个像素的颜色为 rgba(8, 9, 10, 11/255)；\n…\n\n元组 (i, i+1, i+2, i+3) 表示第 (i / 4 + 1) 个像素的颜色为 rgba(i, i+1, i+2, (i+3)/255)；\n…\n元组 (44, 45, 46, 47) 表示第 12(= 44 / 4 + 1) 个像素的颜色为 rgba(44, 45, 46, 47/255)。\n\n可见从 0 开始遍历 D 数组，每次递增 4 个单位，即可依次得到各个像素的红色值 R，再依次加1、加2、加3，即得到对应的绿色值 G、蓝色值 B、等效 α 通道值 A。\n\n反之，如果知道图片的像素尺寸为 4 × 3，则可以通过下图找到数组 D 的各个元素：\n![](https://weidadeda.github.io/post-images/1647858189293.png)\n\n可见各像素点是按照 从左至右、从上至下 的顺序排列的。设图片总宽度像素为 W，总高度像素为 H，任一像素点 P 的坐标为 (x, y)，P 的红色值在数组 D 的下标为 R(x, y)，则：\n```js\nR(x,y)=(x+W*y)×4\n```\n验证：（x 与 y 均从 0 开始计数）\n\nR(2, 1) = (2 + 1 × 4) × 4 = 24\nR(1, 2) = (1 + 2 × 4) × 4 = 36\nR(3, 1) = (3 + 1 × 4) × 4 = 28\n\n拿到了 R(x, y)，不难求出该像素的纵向中心对称像素 Rh(x, y)、横向中心对称像素 Rw(x, y)、以及主对角线对称像素 Rd(x, y)：\n```js\nRh(x,y)=[x+W*(H−1−y)]*4 // 初等行变换\nRw(x,y)=[(W−1−x)+W*y]*4 // 初等列变换\nRd(x,y)=(y+H*x)*4\n```\n\n### 具体实现\n\n基本思路：\n\n- 通过 canvas 获取目标图片的 ImageData 对象；\n- 转置原图片数组，得到数组 AT；\n- 对 AT 执行一组初等行变换，使各行逆序排列，得到左旋 90° 效果；\n- 对 AT 执行一组初等列变换，使各列逆序排列，得到右旋 90° 效果；\n- 将新的像素数组写回图片源标签。\n\nHTML：\n```html\n&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;\n&amp;lt;head&amp;gt;\n    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;\n    &amp;lt;title&amp;gt;Rotate by ImageData&amp;lt;/title&amp;gt;\n    &amp;lt;style&amp;gt;\n        .image{ margin-top: 5px; }\n    &amp;lt;/style&amp;gt;\n&amp;lt;/head&amp;gt;\n&amp;lt;body&amp;gt;\n    &amp;lt;div class=&amp;quot;btns&amp;quot;&amp;gt;\n        &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;左转 90°&amp;quot; id=&amp;quot;turnLeft&amp;quot; /&amp;gt;\n        &amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;右转 90°&amp;quot; id=&amp;quot;turnRight&amp;quot; /&amp;gt;\n    &amp;lt;/div&amp;gt;\n    &amp;lt;div class=&amp;quot;image&amp;quot;&amp;gt;\n        &amp;lt;img id=&amp;quot;fruit&amp;quot; src=&amp;quot;fruit.jpg&amp;quot; class=&amp;quot;image&amp;quot; alt=&amp;quot;fruit&amp;quot; title=&amp;quot;fruit&amp;quot; /&amp;gt;\n    &amp;lt;/div&amp;gt;\n    &amp;lt;script src=&amp;quot;imageRotate.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;\n&amp;lt;/body&amp;gt;\n\n&amp;lt;/html&amp;gt;\n```\nimageRotate.js：\n```js\ndocument.querySelector(&#39;#turnLeft&#39; ).addEventListener(&#39;click&#39;, e =&amp;gt; rotateImage(&#39;l&#39;))\ndocument.querySelector(&#39;#turnRight&#39;).addEventListener(&#39;click&#39;, e =&amp;gt; rotateImage(&#39;r&#39;))\n\nfunction rotateImage(direction = &#39;l&#39;) {\n    // 1. Prepare ImageData\n    let img = document.querySelector(&#39;#fruit&#39;)\n    const { width: W, height: H } = img\n    let cvs = document.createElement(&#39;canvas&#39;)\n    cvs.width = W\n    cvs.height = H\n    let ctx = cvs.getContext(&#39;2d&#39;)\n    ctx.drawImage(img, 0, 0)\n    let imgDt0 = ctx.getImageData(0, 0, W, H)\n    let imgDt1 = new ImageData(H, W)\n    let imgDt2 = new ImageData(H, W)\n    let dt0 = imgDt0.data\n    let dt1 = imgDt1.data\n    let dt2 = imgDt2.data\n\n    // 2. Transpose\n    let r = r1 = 0  // index of red pixel in old and new ImageData, respectively\n    for (let y = 0, lenH = H; y &amp;lt; lenH; y++) {\n        for (let x = 0, lenW = W; x &amp;lt; lenW; x++) {\n            r  = (x + lenW * y) * 4\n            r1 = (y + lenH * x) * 4\n            dt1[r1 + 0] = dt0[r + 0]\n            dt1[r1 + 1] = dt0[r + 1]\n            dt1[r1 + 2] = dt0[r + 2]\n            dt1[r1 + 3] = dt0[r + 3]\n        }\n    }\n    \n    // 3. Reverse width / height\n    for (let y = 0, lenH = W; y &amp;lt; lenH; y++) {\n        for (let x = 0, lenW = H; x &amp;lt; lenW; x++) {\n            r  = (x + lenW * y) * 4\n            r1 = direction === &#39;l&#39;\n                ? (x + lenW * (lenH - 1 - y)) * 4\n                : ((lenW - 1 - x) + lenW * y) * 4\n            dt2[r1 + 0] = dt1[r + 0]\n            dt2[r1 + 1] = dt1[r + 1]\n            dt2[r1 + 2] = dt1[r + 2]\n            dt2[r1 + 3] = dt1[r + 3]\n        }\n    }\n    \n    // 4. Redraw image\n    cvs.width = H\n    cvs.height = W\n    ctx.clearRect(0, 0, W, H)\n    ctx.putImageData(imgDt2, 0, 0, 0, 0, H, W)\n    img.src = cvs.toDataURL(&#39;image/jpeg&#39;, 1)\n}\n```\n\n运行结果：\n原始图片\n![](https://weidadeda.github.io/post-images/1647858200595.png)\n左转90度\n![](https://weidadeda.github.io/post-images/1647858207477.png)\n右转90度\n![](https://weidadeda.github.io/post-images/1647858214763.png)\n\n好了，现在实现了图片旋转，那么我们接着套用公式实现图片镜像和视频镜像\n\nhtml\n```html\n&amp;lt;!DOCTYPE html&amp;gt;\n&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;\n&amp;lt;head&amp;gt;\n    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt;\n    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot; /&amp;gt;\n    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot; /&amp;gt;\n    &amp;lt;title&amp;gt;js通过浏览器调用摄像头&amp;lt;/title&amp;gt;\n    &amp;lt;style&amp;gt;\n    #video {\n        /* transform: rotate3d(1, 1, 1, 45deg); */\n    }\n    &amp;lt;/style&amp;gt;\n&amp;lt;/head&amp;gt;\n&amp;lt;body&amp;gt;\n    &amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;\n    &amp;lt;video id=&amp;quot;video&amp;quot; width=&amp;quot;500px&amp;quot; height=&amp;quot;500px&amp;quot; autoplay=&amp;quot;autoplay&amp;quot; /&amp;gt;\n    &amp;lt;/div&amp;gt;\n    &amp;lt;canvas width=&amp;quot;500&amp;quot; height=&amp;quot;500&amp;quot; id=&amp;quot;canvas&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;\n    &amp;lt;video\n    id=&amp;quot;video2&amp;quot;\n    width=&amp;quot;500px&amp;quot;\n    height=&amp;quot;500px&amp;quot;\n    autoplay=&amp;quot;autoplay&amp;quot;\n    controls=&amp;quot;controls&amp;quot;\n    /&amp;gt;\n&amp;lt;/body&amp;gt;\n&amp;lt;!-- &amp;lt;script src=&amp;quot;./test.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;\n&amp;lt;script&amp;gt;\n    function getMedia() {\n    let video = document.getElementById(&amp;quot;video&amp;quot;);\n    let constraints = {\n        video: { width: 500, height: 500 },\n        audio: false,\n    };\n    navigator.getUserMedia =\n        navigator.getUserMedia ||\n        navigator.webkitGetUserMedia ||\n        navigator.mozGetUserMedia ||\n        navigator.msGetUserMedia;\n    let promise = navigator.mediaDevices.getUserMedia(\n        constraints,\n        function (stream) {\n        video.src = stream;\n        video.play();\n        },\n        function (error) {\n        console.log(error);\n        }\n    );\n    promise.then(function (MediaStream) {\n        video.srcObject = MediaStream;\n        video.play();\n    });\n    }\n\n    getMedia();\n    window.onload = () =&amp;gt; {\n    const data = [];\n    var recorder;\n    // 获取视频流之后，用canvas对视频进行反转，然后使用captureStream获取视频流，此时可以通过声网自定义流获取视频轨道getVideoTracks。代码中为了测试canvas转视频可用，调用了MediaRecorder录制\n    function imageDataHRevert(sourceData, newData) {\n        for (var i = 0, h = sourceData.height; i &amp;lt; h; i++) {\n        for (j = 0, w = sourceData.width; j &amp;lt; w; j++) {\n            newData.data[i * w * 4 + j * 4 + 0] =\n            // (y*W+x)*4\n            sourceData.data[i * w * 4 + (w - j) * 4  -4+ 0];\n            // (y*W+(W-x-1))*4\n            newData.data[i * w * 4 + j * 4 + 1] =\n            sourceData.data[i * w * 4 + (w - j) * 4 -4+ 1];\n\n            newData.data[i * w * 4 + j * 4 + 2] =\n            sourceData.data[i * w * 4 + (w - j) * 4 -4+ 2];\n\n            newData.data[i * w * 4 + j * 4 + 3] =\n            sourceData.data[i * w * 4 + (w - j) * 4-4 + 3];\n        }\n        }\n        return newData;\n    }\n    function imageDataVRevert(sourceData, newData) {\n        for (var i = 0, h = sourceData.height; i &amp;lt; h; i++) {\n        for (var j = 0, w = sourceData.width; j &amp;lt; w; j++) {\n            newData.data[i * w * 4 + j * 4 + 0] =\n            sourceData.data[(h - i) * w * 4 + j * 4 + 0];\n\n            newData.data[i * w * 4 + j * 4 + 1] =\n            sourceData.data[(h - i) * w * 4 + j * 4 + 1];\n\n            newData.data[i * w * 4 + j * 4 + 2] =\n            sourceData.data[(h - i) * w * 4 + j * 4 + 2];\n\n            newData.data[i * w * 4 + j * 4 + 3] =\n            sourceData.data[(h - i) * w * 4 + j * 4 + 3];\n        }\n        }\n\n        return newData;\n    }\n\n    function render() {\n        var canvas = document.getElementById(&amp;quot;canvas&amp;quot;);\n        var video = document.getElementById(&amp;quot;video&amp;quot;);\n        var ctx1 = canvas.getContext(&amp;quot;2d&amp;quot;);\n        ctx1.drawImage(video, 0, 0, 500, 500);\n        var imgData = ctx1.getImageData(0, 0, 500, 500);\n        var newImgData = ctx1.getImageData(0, 0, 500, 500);\n        const HRevet = imageDataHRevert(newImgData, imgData);\n        console.error(HRevet, &amp;quot;HRevet&amp;quot;);\n        // 亮一点\n        for (var i = 0; i &amp;lt; HRevet.data.length; i += 4) {\n        HRevet.data[i] += 5;\n        HRevet.data[i + 1] += 5;\n        HRevet.data[i + 2] += 5;\n        }\n        ctx1.putImageData(HRevet, 0, 0);\n        requestAnimationFrame(render);\n    }\n    requestAnimationFrame(render);\n    const stream = canvas.captureStream(30);\n    // todo 自定义视频 canvas.captureStream(30).getVideoTracks()[0]\n    console.error(stream, &amp;quot;stream&amp;quot;);\n    // 自己测试录制视频的，可以不用看\n    recorder = new MediaRecorder(stream, { mimeType: &amp;quot;video/webm&amp;quot; });\n    recorder.ondataavailable = function (event) {\n        if (event.data &amp;amp;&amp;amp; event.data.size) {\n        data.push(event.data);\n        }\n    };\n    recorder.onstop = () =&amp;gt; {\n        const url = URL.createObjectURL(new Blob(data, { type: &amp;quot;video/webm&amp;quot; }));\n        document.getElementById(&amp;quot;video2&amp;quot;).src = url;\n    };\n    recorder.start();\n    setTimeout(() =&amp;gt; {\n        recorder.stop();\n    }, 6000);\n    };\n&amp;lt;/script&amp;gt;\n&amp;lt;/html&amp;gt;\n```\n结果：\n![](https://weidadeda.github.io/post-images/1647859629847.png)&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;利用 ImageData 实现图片翻转和视频镜像&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;canvas&#34;,&#34;slug&#34;:&#34;jFPmxhqKu&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/jFPmxhqKu&#34;},{&#34;name&#34;:&#34;js&#34;,&#34;slug&#34;:&#34;3uoOai8za&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/3uoOai8za&#34;}],&#34;date&#34;:&#34;2022-03-09 19:21:10&#34;,&#34;dateFormat&#34;:&#34;2022-03-09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/li-yong-imagedata-shi-xian-tu-pian-fan-zhuan-he-shi-pin-jing-xiang&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;13 min read&#34;,&#34;time&#34;:774000,&#34;words&#34;:2647,&#34;minutes&#34;:13},&#34;description&#34;:&#34;最近在搞视频直播，其中有一个功能是视频镜像，那么有两种实现方式。\n- 一种是老师端点击镜像，通过css把自己的video标签镜像，然后发送信令给学生端，学生端收到消息之后也通过css去实现镜像\n- 第二种就是老师端对视频流做一个镜像处理，学...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1646137679298.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;blockquote&gt;\n&lt;p&gt;目前小程序分包大小有以下限制：&lt;br&gt;\n整个小程序所有分包大小不超过 8M&lt;br&gt;\n单个分包/主包大小不能超过 2M&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;所以说8M的限制是要分包至少4个包，单个分包上限其实还是2M&lt;/p&gt;\n&lt;h3 id=\&#34;解决这个问题一种是分包\&#34;&gt;解决这个问题一种是分包&lt;/h3&gt;\n&lt;p&gt;官方给出的分包&lt;a href=\&#34;https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html\&#34;&gt;官网文档&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;另一种是减少包中的图片\&#34;&gt;另一种是减少包中的图片&lt;/h3&gt;\n&lt;p&gt;其实造成包体积过大的因素，很大原因是因为包里有图片，那体积就会变得很大。那我们可以将图片上传到CDN上，变成网络链接，这样的话就不会把图片打包进去了。但是这样又有一个不足，比如说我们一开始开发项目的时候，UI同学给了我们设计图，那我们要将图片一张张的上传到CDN上去吗？如果后期UI走查的时候要换图片呢？而且万一CDN上的图片被人误删了或者服务到期了呢（当然这种可能性很小，但也可以考虑进去），这时候我们的原图都会找不到，只能干着急。。。&lt;/p&gt;\n&lt;h4 id=\&#34;那么最好的方式就是将图片放在项目中本地开发的时候引用的就是本地的增删改找起来也方便但是打包构建的时候将图片压缩并上传cdn同时将项目中的图片引用路径改成网络链接然后删除dist中的所有图片-那么接下来我们就写个脚本实现一下\&#34;&gt;那么最好的方式就是将图片放在项目中，本地开发的时候引用的就是本地的，增删改找起来也方便，但是打包构建的时候将图片压缩并上传CDN，同时将项目中的图片引用路径改成网络链接，然后删除dist中的所有图片。那么接下来我们就写个脚本实现一下。&lt;/h4&gt;\n&lt;p&gt;直接上代码吧&lt;/p&gt;\n&lt;h4 id=\&#34;先写上传方法用于打包完上传先压缩再上传到阿里oss\&#34;&gt;先写上传方法，用于打包完上传，先压缩再上传到阿里oss&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// config/upload.js\nconst OSS = require(&amp;quot;ali-oss&amp;quot;);\nconst fs = require(&amp;quot;fs&amp;quot;);\nconst path = require(&amp;quot;path&amp;quot;);\nconst rimraf = require(&amp;quot;rimraf&amp;quot;);\nconst imagemin = require(&#39;imagemin&#39;)\nconst imageminJpegtran = require(&#39;imagemin-jpegtran&#39;)\nconst imageminPngquant = require(&#39;imagemin-pngquant&#39;)\nconst imageminSvgo = require(&#39;imagemin-svgo&#39;)\nconst imageminGifsicle = require(&#39;imagemin-gifsicle&#39;)\n\nconst client = new OSS({\n  region: &amp;quot;&amp;quot;,\n  endpoint: &amp;quot;&amp;quot;,\n  accessKeyId: &amp;quot;&amp;quot;,\n  accessKeySecret: &amp;quot;&amp;quot;,\n  bucket: &amp;quot;&amp;quot;\n});\nasync function compress() {\n  const files = await imagemin([&#39;../dist/**/*.{jpg,jpeg,png,svg,gif}&#39;], {\n    destination: &#39;../dist/assets&#39;,\n    plugins: [\n      imageminJpegtran({\n        progressive: true,\n        quality: 80,\n      }),\n      imageminPngquant({\n        quality: [0.6, 0.8],\n      }),\n      imageminSvgo({\n        plugins: [{ removeViewBox: false }],\n      }),\n      imageminGifsicle(),\n    ],\n  })\n  console.log(&#39;compress all images success!&#39;.info)\n  return files\n}\nconst putOSS = async function(src, dist) {\n  try {\n    let result = await client.put(dist, src);\n    console.log(&amp;quot;oss上传成功: &amp;quot; + result.name);\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nconst workList = [];\n\n/**\n *\n * @param {string} src 需要上传的文件夹\n * @param {string} dist oss文件夹\n */\n\nconst addFileToOSSSync = function(src, dist) {\n  try {\n    await compress()\n    var docs = fs.readdirSync(src);\n  } catch (error) {\n    console.log(src + &amp;quot;不存在&amp;quot;);\n    return;\n  }\n\n  docs.forEach(function(doc) {\n    const _src = src + &amp;quot;/&amp;quot; + doc;\n    const _dist = dist + &amp;quot;/&amp;quot; + doc;\n    const st = fs.statSync(_src);\n    // 判断是否为文件\n    if (st.isFile() &amp;amp;&amp;amp; doc !== &amp;quot;.DS_Store&amp;quot;) {\n      workList.push(putOSS(_src, _dist));\n      // console.log(_src + &#39;是文件&#39;, _dist);\n    } else if (st.isDirectory()) {\n      addFileToOSSSync(_src, _dist);\n    }\n  });\n};\n\naddFileToOSSSync(&amp;quot;dist/assets&amp;quot;, &amp;quot;weixin/gongyi/sdg/images&amp;quot;);\n\nPromise.all(workList).then(res =&amp;gt; {\n  rimraf(path.join(__dirname, &amp;quot;../dist/assets&amp;quot;), error =&amp;gt; {\n    if (error) {\n      throw error;\n    }\n    console.log(&amp;quot;done!&amp;quot;);\n  });\n});\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;上传方法写完了什么时候调用呢应该在构建完之后调用因为上传完要删除包中dist下的图片那么我们应该packagejson中更改命令\&#34;&gt;上传方法写完了，什么时候调用呢，应该在构建完之后调用，因为上传完要删除包中dist下的图片，那么我们应该package.json中更改命令&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// package.json\n&amp;quot;build:weapp&amp;quot;: &amp;quot;NODE_ENV=online taro build --type weapp &amp;amp;&amp;amp; node config/upload.js&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;还有设置一个全局变量\&#34;&gt;还有设置一个全局变量&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// Taro打包入口处\nconst ossPath = &#39;你的cdn域名&#39;\nlet projectPublicPath = &#39;/&#39;\n\nif (process.env.NODE_ENV !== &#39;development&#39;) {\n  // 你上传的cdn路径\n  projectPublicPath = `${ossPath}/1v1mp/${process.env.TARO_ENV}/${process.env.NODE_ENV}`\n}\n\nlet assetsPre =\n  process.env.TARO_ENV === &#39;weapp&#39;\n    ? process.env.NODE_ENV === &#39;development&#39;\n      ? &#39;&#39;\n      : projectPublicPath\n    : &#39;&#39;\nvar config = {\n  // ...其他配置正常写，主要是注意这两项\n  alias: {\n    &#39;@&#39;: path.resolve(__dirname, &#39;..&#39;, &#39;src&#39;),\n  },\n  defineConstants: {\n    assetsPre: `&amp;quot;${assetsPre}&amp;quot;`,\n  },\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;最后使用需要注意\&#34;&gt;最后使用需要注意：&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;所有图片文件放入&lt;code&gt;src/assets&lt;/code&gt;目录下，可以在&lt;code&gt;assets&lt;/code&gt;目录下创建各模块目录&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;使用 &lt;code&gt;import&lt;/code&gt; 引入后在&lt;code&gt;src&lt;/code&gt;处使用 &lt;code&gt;${assetsPre}${pic}&lt;/code&gt;的方式使用, &lt;code&gt;assetsPre&lt;/code&gt;是全局定义好的常量，可以直接使用。&lt;/p&gt;\n&lt;p&gt;例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;import pic from &#39;@/assets/defualt.jpg&#39;\n\nexport default function Index() {\n  // do some logic\n\n  return &amp;lt;Image src={`${assetsPre}${pic}`} /&amp;gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;tip: 有一点要说一下，虽然import引入了，但其实是个pic是个路径，webpack5以前会把它通过loader转为路径，webpack5通过内置Asset Modules转为路径。具体文档可见：&lt;a href=\&#34;https://webpack.docschina.org/guides/asset-management/#loading-images\&#34;&gt;加载images图像&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;taro-jie-jue-xiao-cheng-xu-bao-ti-ji-guo-da-de-wen-ti&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Taro解决小程序包体积过大的问题&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;小程序开发&#34;,&#34;slug&#34;:&#34;MyzxkxARV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/MyzxkxARV&#34;}],&#34;date&#34;:&#34;2022-03-01 20:27:38&#34;,&#34;dateFormat&#34;:&#34;2022-03-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/taro-jie-jue-xiao-cheng-xu-bao-ti-ji-guo-da-de-wen-ti&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:265000,&#34;words&#34;:1010,&#34;minutes&#34;:5},&#34;description&#34;:&#34;\n\n目前小程序分包大小有以下限制：\n整个小程序所有分包大小不超过 8M\n单个分包/主包大小不能超过 2M\n\n所以说8M的限制是要分包至少4个包，单个分包上限其实还是2M\n解决这个问题一种是分包\n官方给出的分包官网文档\n另一种是减少包中的图片...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%80%E7%A7%8D%E6%98%AF%E5%88%86%E5%8C%85\&#34;&gt;解决这个问题一种是分包&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%98%AF%E5%87%8F%E5%B0%91%E5%8C%85%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87\&#34;&gt;另一种是减少包中的图片&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%82%A3%E4%B9%88%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E5%B0%B1%E6%98%AF%E5%B0%86%E5%9B%BE%E7%89%87%E6%94%BE%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%9A%84%E6%97%B6%E5%80%99%E5%BC%95%E7%94%A8%E7%9A%84%E5%B0%B1%E6%98%AF%E6%9C%AC%E5%9C%B0%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%89%BE%E8%B5%B7%E6%9D%A5%E4%B9%9F%E6%96%B9%E4%BE%BF%E4%BD%86%E6%98%AF%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%86%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%B9%B6%E4%B8%8A%E4%BC%A0cdn%E5%90%8C%E6%97%B6%E5%B0%86%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84%E6%94%B9%E6%88%90%E7%BD%91%E7%BB%9C%E9%93%BE%E6%8E%A5%E7%84%B6%E5%90%8E%E5%88%A0%E9%99%A4dist%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%9B%BE%E7%89%87-%E9%82%A3%E4%B9%88%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E5%B0%B1%E5%86%99%E4%B8%AA%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%8B\&#34;&gt;那么最好的方式就是将图片放在项目中，本地开发的时候引用的就是本地的，增删改找起来也方便，但是打包构建的时候将图片压缩并上传CDN，同时将项目中的图片引用路径改成网络链接，然后删除dist中的所有图片。那么接下来我们就写个脚本实现一下。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%88%E5%86%99%E4%B8%8A%E4%BC%A0%E6%96%B9%E6%B3%95%E7%94%A8%E4%BA%8E%E6%89%93%E5%8C%85%E5%AE%8C%E4%B8%8A%E4%BC%A0%E5%85%88%E5%8E%8B%E7%BC%A9%E5%86%8D%E4%B8%8A%E4%BC%A0%E5%88%B0%E9%98%BF%E9%87%8Coss\&#34;&gt;先写上传方法，用于打包完上传，先压缩再上传到阿里oss&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8A%E4%BC%A0%E6%96%B9%E6%B3%95%E5%86%99%E5%AE%8C%E4%BA%86%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%B0%83%E7%94%A8%E5%91%A2%E5%BA%94%E8%AF%A5%E5%9C%A8%E6%9E%84%E5%BB%BA%E5%AE%8C%E4%B9%8B%E5%90%8E%E8%B0%83%E7%94%A8%E5%9B%A0%E4%B8%BA%E4%B8%8A%E4%BC%A0%E5%AE%8C%E8%A6%81%E5%88%A0%E9%99%A4%E5%8C%85%E4%B8%ADdist%E4%B8%8B%E7%9A%84%E5%9B%BE%E7%89%87%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5packagejson%E4%B8%AD%E6%9B%B4%E6%94%B9%E5%91%BD%E4%BB%A4\&#34;&gt;上传方法写完了，什么时候调用呢，应该在构建完之后调用，因为上传完要删除包中dist下的图片，那么我们应该package.json中更改命令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%98%E6%9C%89%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\&#34;&gt;还有设置一个全局变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%80%E5%90%8E%E4%BD%BF%E7%94%A8%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F\&#34;&gt;最后使用需要注意：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;public static createBitmap(imgUrl: string): Promise&amp;lt;any&amp;gt; {\n    return new Promise&amp;lt;object | number&amp;gt;((resolve, reject) =&amp;gt; {\n      const image: any = new Image()\n      image.src = imgUrl || &#39;&#39;\n      image.onload = () =&amp;gt; {\n        const Bitmap = new createjs.Bitmap(image)\n        const { width, height } = Bitmap.image\n        // Bitmap.setBounds(0, 0, width, height);\n        Bitmap.regX = width / 2\n        Bitmap.regY = height / 2\n        resolve(Bitmap)\n      }\n      image.onerror = (error: any) =&amp;gt; {\n        console.warn(`&amp;quot;image load fail&amp;quot;${imgUrl}`, error)\n      }\n    })\n  }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;注意默认注册中心点旋转时围绕的点是在左上角regxregy并不是改变注册中心点而是向左上方向偏移宽高的一半但只是偏移物体这个物体的注册中心点是不变的-想改变注册中心点只能靠xy来设置位置注册中心点永远都在左上角但通过regxregy可以把物体本身往反方向平移一半但注册中心点还在之前的位置这样的话我们的旋转位置看起来就是围着中间点旋转了-这么说大家可能有点懵没关系这里确实有点难理解~有个博客写的很好大家可以结合我总结的看一下\&#34;&gt;注意：默认注册中心点（旋转时围绕的点）是在左上角，regX，regY并不是改变注册中心点，而是向左上方向偏移宽高的一半，但只是偏移物体，这个物体的注册中心点是不变的。想改变注册中心点，只能靠x,y来设置位置，注册中心点永远都在左上角，但通过regX，regY可以把物体本身往反方向平移一半（但注册中心点还在之前的位置），这样的话，我们的旋转位置看起来就是围着中间点旋转了。这么说大家可能有点懵，没关系，这里确实有点难理解～有个博客写的很好，大家可以结合我总结的看一下：&lt;/h4&gt;\n&lt;p&gt;&lt;a href=\&#34;https://segmentfault.com/a/1190000016445744\&#34;&gt;Easeljs之regX/regY详解&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;createjs-chuang-jian-tu-pian-wei-tu-bing-she-zhi-zhong-xin-dian-wei-tu-pian-zhong-xin&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;createjs 创建图片位图并设置中心点为图片中心&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;createjs&#34;,&#34;slug&#34;:&#34;2Yx2EO2fG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/2Yx2EO2fG&#34;}],&#34;date&#34;:&#34;2022-02-22 11:38:28&#34;,&#34;dateFormat&#34;:&#34;2022-02-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/createjs-chuang-jian-tu-pian-wei-tu-bing-she-zhi-zhong-xin-dian-wei-tu-pian-zhong-xin&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:68000,&#34;words&#34;:274,&#34;minutes&#34;:2},&#34;description&#34;:&#34;public static createBitmap(imgUrl: string): Promise&amp;lt;any&amp;gt; {\n    return new Promise&amp;lt;object | number&amp;gt;((resolve,...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F%E9%BB%98%E8%AE%A4%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%82%B9%E6%97%8B%E8%BD%AC%E6%97%B6%E5%9B%B4%E7%BB%95%E7%9A%84%E7%82%B9%E6%98%AF%E5%9C%A8%E5%B7%A6%E4%B8%8A%E8%A7%92regxregy%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%94%B9%E5%8F%98%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%82%B9%E8%80%8C%E6%98%AF%E5%90%91%E5%B7%A6%E4%B8%8A%E6%96%B9%E5%90%91%E5%81%8F%E7%A7%BB%E5%AE%BD%E9%AB%98%E7%9A%84%E4%B8%80%E5%8D%8A%E4%BD%86%E5%8F%AA%E6%98%AF%E5%81%8F%E7%A7%BB%E7%89%A9%E4%BD%93%E8%BF%99%E4%B8%AA%E7%89%A9%E4%BD%93%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%82%B9%E6%98%AF%E4%B8%8D%E5%8F%98%E7%9A%84-%E6%83%B3%E6%94%B9%E5%8F%98%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%82%B9%E5%8F%AA%E8%83%BD%E9%9D%A0xy%E6%9D%A5%E8%AE%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%82%B9%E6%B0%B8%E8%BF%9C%E9%83%BD%E5%9C%A8%E5%B7%A6%E4%B8%8A%E8%A7%92%E4%BD%86%E9%80%9A%E8%BF%87regxregy%E5%8F%AF%E4%BB%A5%E6%8A%8A%E7%89%A9%E4%BD%93%E6%9C%AC%E8%BA%AB%E5%BE%80%E5%8F%8D%E6%96%B9%E5%90%91%E5%B9%B3%E7%A7%BB%E4%B8%80%E5%8D%8A%E4%BD%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%82%B9%E8%BF%98%E5%9C%A8%E4%B9%8B%E5%89%8D%E7%9A%84%E4%BD%8D%E7%BD%AE%E8%BF%99%E6%A0%B7%E7%9A%84%E8%AF%9D%E6%88%91%E4%BB%AC%E7%9A%84%E6%97%8B%E8%BD%AC%E4%BD%8D%E7%BD%AE%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%B0%B1%E6%98%AF%E5%9B%B4%E7%9D%80%E4%B8%AD%E9%97%B4%E7%82%B9%E6%97%8B%E8%BD%AC%E4%BA%86-%E8%BF%99%E4%B9%88%E8%AF%B4%E5%A4%A7%E5%AE%B6%E5%8F%AF%E8%83%BD%E6%9C%89%E7%82%B9%E6%87%B5%E6%B2%A1%E5%85%B3%E7%B3%BB%E8%BF%99%E9%87%8C%E7%A1%AE%E5%AE%9E%E6%9C%89%E7%82%B9%E9%9A%BE%E7%90%86%E8%A7%A3~%E6%9C%89%E4%B8%AA%E5%8D%9A%E5%AE%A2%E5%86%99%E7%9A%84%E5%BE%88%E5%A5%BD%E5%A4%A7%E5%AE%B6%E5%8F%AF%E4%BB%A5%E7%BB%93%E5%90%88%E6%88%91%E6%80%BB%E7%BB%93%E7%9A%84%E7%9C%8B%E4%B8%80%E4%B8%8B\&#34;&gt;注意：默认注册中心点（旋转时围绕的点）是在左上角，regX，regY并不是改变注册中心点，而是向左上方向偏移宽高的一半，但只是偏移物体，这个物体的注册中心点是不变的。想改变注册中心点，只能靠x,y来设置位置，注册中心点永远都在左上角，但通过regX，regY可以把物体本身往反方向平移一半（但注册中心点还在之前的位置），这样的话，我们的旋转位置看起来就是围着中间点旋转了。这么说大家可能有点懵，没关系，这里确实有点难理解～有个博客写的很好，大家可以结合我总结的看一下：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;https://vitejs.cn/guide/api-plugin.html\&#34;&gt;vite官网自定义插件&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Vite 插件扩展了设计出色的 Rollup 接口，带有一些 Vite 独有的配置项。因为vite是使用rollup打包的所以最好你能了解&lt;a href=\&#34;https://rollupjs.org/guide/en/#plugin-development\&#34;&gt;Rollup 插件文档&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;下面的都是按照官网介绍写的，因为毕竟你看到我这了，直接给你个链接再让你跳转到官网去看有点不负责任，如果你已经从官网看过了，并且对自定义插件很熟悉了，那么请直接到最下面看 &lt;a href=\&#34;#test\&#34;&gt;项目实战部分&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;约定\&#34;&gt;约定&lt;/h3&gt;\n&lt;p&gt;如果插件不使用 Vite 特有的钩子，可以作为 &lt;a href=\&#34;https://vitejs.cn/guide/api-plugin.html#rollup-plugin-compatibility\&#34;&gt;兼容 Rollup 的插件&lt;/a&gt; 来实现，推荐使用 &lt;a href=\&#34;https://rollupjs.org/guide/en/#conventions\&#34;&gt;Rollup 插件名称约定&lt;/a&gt;。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Rollup 插件应该有一个带 rollup-plugin- 前缀、语义清晰的名称。&lt;/li&gt;\n&lt;li&gt;在 package.json 中包含 rollup-plugin 和 vite-plugin 关键字。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;这样，插件也可以用于纯 Rollup 或基于 WMR 的项目。&lt;/p&gt;\n&lt;p&gt;对于 Vite 专属的插件：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Vite 插件应该有一个带 vite-plugin- 前缀、语义清晰的名称。&lt;/li&gt;\n&lt;li&gt;在 package.json 中包含 vite-plugin 关键字。&lt;/li&gt;\n&lt;li&gt;在插件文档增加一部分关于为什么本插件是一个 Vite 专属插件的详细说明（如，本插件使用了 Vite 特有的插件钩子）。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;如果你的插件只适用于特定的框架，它的名字应该遵循以下前缀格式：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;vite-plugin-vue- 前缀作为 Vue 插件&lt;/li&gt;\n&lt;li&gt;vite-plugin-react- 前缀作为 React 插件&lt;/li&gt;\n&lt;li&gt;vite-plugin-svelte- 前缀作为 Svelte 插件&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;插件配置\&#34;&gt;插件配置&lt;/h3&gt;\n&lt;p&gt;用户会将插件添加到项目的 devDependencies 中并使用数组形式的 plugins 选项配置它们。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// vite.config.js\nimport vitePlugin from &#39;vite-plugin-feature&#39;\nimport rollupPlugin from &#39;rollup-plugin-feature&#39;\n\nexport default defineConfig({\n  plugins: [vitePlugin(), rollupPlugin()]\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;假值的插件将被忽略，可以用来轻松地启用或停用插件。&lt;/p&gt;\n&lt;p&gt;plugins 也可以接受将多个插件作为单个元素的预设。这对于使用多个插件实现的复杂特性（如框架集成）很有用。该数组将在内部被扁平化（flatten）。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 框架插件\nimport frameworkRefresh from &#39;vite-plugin-framework-refresh&#39;\nimport frameworkDevtools from &#39;vite-plugin-framework-devtools&#39;\n\nexport default function framework(config) {\n  return [frameworkRefresh(config), frameworkDevTools(config)]\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// vite.config.js\nimport { defineConfig } from &#39;vite&#39;\nimport framework from &#39;vite-plugin-framework&#39;\n\nexport default defineConfig({\n  plugins: [framework()]\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;简单示例\&#34;&gt;简单示例&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;TIP&lt;br&gt;\n通常的惯例是创建一个 Vite/Rollup 插件作为一个返回实际插件对象的工厂函数。该函数可以接受允许用户自定义插件行为的选项。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;转换自定义文件类型\&#34;&gt;转换自定义文件类型&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const fileRegex = /\\.(my-file-ext)$/\n\nexport default function myPlugin() {\n  return {\n    name: &#39;transform-file&#39;,\n\n    transform(src, id) {\n      if (fileRegex.test(id)) {\n        return {\n          code: compileFileToJS(src),\n          map: null // 如果可行将提供 source map\n        }\n      }\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;通用钩子\&#34;&gt;通用钩子&lt;/h3&gt;\n&lt;p&gt;在开发中，Vite 开发服务器会创建一个插件容器来调用 &lt;a href=\&#34;https://rollupjs.org/guide/en/#build-hooks\&#34;&gt;Rollup 构建钩子&lt;/a&gt;，与 Rollup 如出一辙。&lt;/p&gt;\n&lt;p&gt;以下钩子在服务器启动时被调用：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;options&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;buildStart&lt;br&gt;\n以下钩子会在每个传入模块请求时被调用：&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;resolveId&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;load&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;transform&lt;br&gt;\n以下钩子在服务器关闭时被调用：&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;buildEnd&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;closeBundle&lt;br&gt;\n请注意 moduleParsed 钩子在开发中是 不会 被调用的，因为 Vite 为了性能会避免完整的 AST 解析。&lt;br&gt;\nOutput Generation Hooks（除了 closeBundle) 在开发中是 不会 被调用的。你可以认为 Vite 的开发服务器只调用了 rollup.rollup() 而没有调用 bundle.generate()。&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645006280268.jpeg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;vite-独有钩子\&#34;&gt;Vite 独有钩子&lt;/h3&gt;\n&lt;p&gt;Vite 插件也可以提供钩子来服务于特定的 Vite 目标。这些钩子会被 Rollup 忽略。&lt;/p&gt;\n&lt;h4 id=\&#34;config\&#34;&gt;config&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;类型： (config: UserConfig, env: { mode: string, command: string }) =&amp;gt; UserConfig | null | void&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;种类： async, sequential&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在解析 Vite 配置前调用。钩子接收原始用户配置（命令行选项指定的会与配置文件合并）和一个描述配置环境的变量，包含正在使用的 mode 和 command。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置（如果默认的合并不能达到预期的结果）。&lt;/p&gt;\n&lt;p&gt;示例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 返回部分配置（推荐）\nconst partialConfigPlugin = () =&amp;gt; ({\n  name: &#39;return-partial&#39;,\n  config: () =&amp;gt; ({\n    alias: {\n      foo: &#39;bar&#39;\n    }\n  })\n})\n\n// 直接改变配置（应仅在合并不起作用时使用）\nconst mutateConfigPlugin = () =&amp;gt; ({\n  name: &#39;mutate-config&#39;,\n  config(config, { command }) {\n    if (command === &#39;build&#39;) {\n      config.root = __dirname\n    }\n  }\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;注意&lt;br&gt;\n用户插件在运行这个钩子之前会被解析，因此在 config 钩子中注入其他插件不会有任何效果。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;configresolved\&#34;&gt;configResolved&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;类型： (config: ResolvedConfig) =&amp;gt; void | Promise&lt;void&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;种类： async, parallel&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在解析 Vite 配置后调用。使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。&lt;/p&gt;\n&lt;p&gt;示例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const exmaplePlugin = () =&amp;gt; {\n  let config\n\n  return {\n    name: &#39;read-config&#39;,\n\n    configResolved(resolvedConfig) {\n      // 存储最终解析的配置\n      config = resolvedConfig\n    },\n\n    // 在其他钩子中使用存储的配置\n    transform(code, id) {\n      if (config.command === &#39;serve&#39;) {\n        // dev: 由开发服务器调用的插件\n      } else {\n        // build: 由 Rollup 调用的插件\n      }\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;注意，在开发环境下，command 的值为 serve（在 CLI 中，vite 和 vite dev 是 vite serve 的别名）。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;configureserver\&#34;&gt;configureServer&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;类型： (server: ViteDevServer) =&amp;gt; (() =&amp;gt; void) | void | Promise&amp;lt;(() =&amp;gt; void) | void&amp;gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;种类： async, sequential&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;此外请看 &lt;a href=\&#34;https://vitejs.cn/guide/api-javascript.html#vitedevserver\&#34;&gt;ViteDevServer&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;是用于配置开发服务器的钩子。最常见的用例是在内部 connect 应用程序中添加自定义中间件:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const myPlugin = () =&amp;gt; ({\n  name: &#39;configure-server&#39;,\n  configureServer(server) {\n    server.middlewares.use((req, res, next) =&amp;gt; {\n      // 自定义请求处理...\n    })\n  }\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注入后置中间件&lt;/p&gt;\n&lt;p&gt;configureServer 钩子将在内部中间件被安装前调用，所以自定义的中间件将会默认会比内部中间件早运行。如果你想注入一个在内部中间件 之后 运行的中间件，你可以从 configureServer 返回一个函数，将会在内部中间件安装后被调用：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const myPlugin = () =&amp;gt; ({\n  name: &#39;configure-server&#39;,\n  configureServer(server) {\n    // 返回一个在内部中间件安装后\n    // 被调用的后置钩子\n    return () =&amp;gt; {\n      server.middlewares.use((req, res, next) =&amp;gt; {\n        // 自定义请求处理...\n      })\n    }\n  }\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;存储服务器访问&lt;/p&gt;\n&lt;p&gt;在某些情况下，其他插件钩子可能需要访问开发服务器实例（例如访问 websocket 服务器、文件系统监视程序或模块图）。这个钩子也可以用来存储服务器实例以供其他钩子访问:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const myPlugin = () =&amp;gt; {\n  let server\n  return {\n    name: &#39;configure-server&#39;,\n    configureServer(_server) {\n      server = _server\n    },\n    transform(code, id) {\n      if (server) {\n        // 使用 server...\n      }\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意 configureServer 在运行生产版本时不会被调用，所以其他钩子需要防范它缺失。&lt;/p&gt;\n&lt;h4 id=\&#34;transformindexhtml\&#34;&gt;transformIndexHtml&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;类型： IndexHtmlTransformHook | { enforce?: &#39;pre&#39; | &#39;post&#39;, transform: IndexHtmlTransformHook }&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;种类： async, sequential&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文。上下文在开发期间暴露ViteDevServer实例，在构建期间暴露 Rollup 输出的包。&lt;br&gt;\n这个钩子可以是异步的，并且可以返回以下其中之一:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;经过转换的 HTML 字符串&lt;/li&gt;\n&lt;li&gt;注入到现有 HTML 中的标签描述符对象数组（{ tag, attrs, children }）。每个标签也可以指定它应该被注入到哪里（默认是在 &lt;head&gt; 之前）&lt;/li&gt;\n&lt;li&gt;一个包含 { html, tags } 的对象&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;基础示例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const htmlPlugin = () =&amp;gt; {\n  return {\n    name: &#39;html-transform&#39;,\n    transformIndexHtml(html) {\n      return html.replace(\n        /&amp;lt;title&amp;gt;(.*?)&amp;lt;\\/title&amp;gt;/,\n        `&amp;lt;title&amp;gt;Title replaced!&amp;lt;/title&amp;gt;`\n      )\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;handlehotupdate\&#34;&gt;handleHotUpdate&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;类型： (ctx: HmrContext) =&amp;gt; Array&lt;ModuleNode&gt; | void | Promise&amp;lt;Array&lt;ModuleNode&gt; | void&amp;gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;执行自定义 HMR 更新处理。钩子接收一个带有以下签名的上下文对象：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;interface HmrContext {\n  file: string\n  timestamp: number\n  modules: Array&amp;lt;ModuleNode&amp;gt;\n  read: () =&amp;gt; string | Promise&amp;lt;string&amp;gt;\n  server: ViteDevServer\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;modules 是受更改文件影响的模块数组。它是一个数组，因为单个文件可能映射到多个服务模块（例如 Vue 单文件组件）。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;read 这是一个异步读函数，它返回文件的内容。之所以这样做，是因为在某些系统上，文件更改的回调函数可能会在编辑器完成文件更新之前过快地触发，并 fs.readFile 直接会返回空内容。传入的 read 函数规范了这种行为。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;钩子可以选择:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;过滤和缩小受影响的模块列表，使 HMR 更准确。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;返回一个空数组，并通过向客户端发送自定义事件来执行完整的自定义 HMR 处理:&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;handleHotUpdate({ server }) {\n  server.ws.send({\n    type: &#39;custom&#39;,\n    event: &#39;special-update&#39;,\n    data: {}\n  })\n  return []\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;客户端代码应该使用 &lt;a href=\&#34;https://vitejs.cn/guide/api-hmr.html\&#34;&gt;HMR API&lt;/a&gt; 注册相应的处理器（这应该被相同插件的 transform 钩子注入）：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;if (import.meta.hot) {\n  import.meta.hot.on(&#39;special-update&#39;, (data) =&amp;gt; {\n    // 执行自定义更新\n  })\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;插件顺序\&#34;&gt;插件顺序&lt;/h3&gt;\n&lt;p&gt;一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。解析后的插件将按照以下顺序排列：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Alias&lt;/li&gt;\n&lt;li&gt;带有 enforce: &#39;pre&#39; 的用户插件&lt;/li&gt;\n&lt;li&gt;Vite 核心插件&lt;/li&gt;\n&lt;li&gt;没有 enforce 值的用户插件&lt;/li&gt;\n&lt;li&gt;Vite 构建用的插件&lt;/li&gt;\n&lt;li&gt;带有 enforce: &#39;post&#39; 的用户插件&lt;/li&gt;\n&lt;li&gt;Vite 后置构建插件（最小化，manifest，报告）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;情景应用\&#34;&gt;情景应用&lt;/h3&gt;\n&lt;p&gt;默认情况下插件在开发（serve）和构建（build）模式中都会调用。如果插件只需要在预览或构建期间有条件地应用，请使用 apply 属性指明它们仅在 &#39;build&#39; 或 &#39;serve&#39; 模式时调用：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;function myPlugin() {\n  return {\n    name: &#39;build-only&#39;,\n    apply: &#39;build&#39; // 或 &#39;serve&#39;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;同时，还可以使用函数来进行更精准的控制：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;apply(config, { command }) {\n  // 非 SSR 情况下的 build\n  return command === &#39;build&#39; &amp;amp;&amp;amp; !config.build.ssr\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;rollup-插件兼容性\&#34;&gt;Rollup 插件兼容性&lt;/h3&gt;\n&lt;p&gt;相当数量的 Rollup 插件将直接作为 Vite 插件工作（例如：@rollup/plugin-alias 或 @rollup/plugin-json），但并不是所有的，因为有些插件钩子在非构建式的开发服务器上下文中没有意义。&lt;/p&gt;\n&lt;p&gt;一般来说，只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;没有使用 moduleParsed 钩子。&lt;/li&gt;\n&lt;li&gt;它在打包钩子和输出钩子之间没有很强的耦合。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。&lt;/p&gt;\n&lt;p&gt;你也可以用 Vite 独有的属性来扩展现有的 Rollup 插件:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// vite.config.js\nimport example from &#39;rollup-plugin-example&#39;\nimport { defineConfig } from &#39;vite&#39;\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...example(),\n      enforce: &#39;post&#39;,\n      apply: &#39;build&#39;\n    }\n  ]\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;查看 &lt;a href=\&#34;https://vite-rollup-plugins.patak.dev/\&#34;&gt;Vite Rollup 插件&lt;/a&gt; 获取兼容的官方 Rollup 插件列表及其使用指南。&lt;/p&gt;\n&lt;h3 id=\&#34;a-idtest-nametest项目实战a\&#34;&gt;&lt;a id=\&#34;test\&#34; name=\&#34;test\&#34;&gt;项目实战&lt;/a&gt;&lt;/h3&gt;\n&lt;p&gt;先说下我们要做什么，我们用vite打包完之后需要将打包出来的静态资源上传到cdn上，但现有的插件不够灵活，比如&lt;a href=\&#34;https://www.npmjs.com/package/vite-plugin-assets-uploader\&#34;&gt;vite-plugin-assets-uploader&lt;br&gt;\n&lt;/a&gt;这个很好，但是需要将oss的密钥等信息写在前端，不够安全。对此我们就用node写了个接口，前端只需要调用node接口就能够上传到oss。而且将代码上传到cdn之后，我们的base路径也要改成cdn的路径。&lt;/p&gt;\n&lt;p&gt;自定义上传插件代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-self-assign */\nconst path = require(&#39;path&#39;)\nconst fs = require(&#39;fs-extra&#39;)\nconst request = require(&#39;request&#39;)\nconst glob = require(&#39;glob&#39;)\nimport { Ioptions } from &#39;../type&#39;\nimport &#39;colors&#39;\nconst packageInfo: any = require(path.resolve(&#39;package.json&#39;))\nclass FileUploader {\n  bucket?: string\n  uploadUrl: string\n  domain: string\n  env: string\n  prefix?: string\n  constructor({ bucket, prefix, env }: { bucket?: string; prefix?: string; env: string }) {\n    this.env = env\n    if (!env) {\n      new Error(&#39;请传入env&#39;)\n      return\n    }\n    this.bucket = bucket || &#39;默认bucket&#39;\n    this.prefix = prefix || `${packageInfo.name}/${this.env}/${packageInfo.version}/`\n    this.uploadUrl = &#39;接口域名&#39;\n    this.domain = &#39;domain&#39;\n  }\n  // 获取base\n  getBase() {\n    return `${this.domain}/${this.prefix}`\n  }\n  // vite上传插件\n  UploadPlugin() {\n    const options: Ioptions = {\n      assetsDir: &#39;&#39;,\n      mode: &#39;&#39;,\n      outDir: &#39;&#39;\n    }\n    const that = this\n    return {\n      name: &#39;vite-plugin-upload&#39;,\n      configResolved: function(config: any) {\n        const outDir = config.build.hasOwnProperty(&#39;outDir&#39;) ? config.build.outDir : &#39;dist&#39;\n        const outDirArr = outDir.split(path.sep)\n        options.outDir = outDirArr[outDirArr.length - 1]\n        options.assetsDir = `${options.outDir}/${config.build.assetsDir}`\n        options.mode = config.mode\n      },\n      closeBundle() {\n        const files = glob.sync(`${options.assetsDir}/*`)\n        files.map((item: any) =&amp;gt; {\n          that.uploadPre(path.relative(options.outDir, path.resolve(item)), options.outDir)\n        })\n      }\n    }\n  }\n  // init判断是否支持此bucket\n  init() {\n    return new Promise((resolve, reject) =&amp;gt; {\n      request.get(\n        { url: this.uploadUrl + &#39;/api/bucketList&#39; },\n        (err: any, response: { statusCode: any }, body: string) =&amp;gt; {\n          const { code, data } = typeof body === &#39;object&#39; ? body : JSON.parse(body)\n          if (err) {\n            reject(false)\n          }\n          if (code !== 0) {\n            reject(false)\n          } else {\n            let cdnInfo = new Map([])\n            data.forEach((v: any) =&amp;gt; {\n              cdnInfo.set(v.bucket, v.url)\n            })\n            if (!cdnInfo.has(this.bucket)) {\n              throw new Error(`目前仅支持以下bucket${data.map((v: any) =&amp;gt; v.bucket).join(&#39; | &#39;)}`)\n            } else {\n              this.domain = cdnInfo.get(this.bucket) as string\n              resolve(this.getBase())\n            }\n          }\n        }\n      )\n    })\n  }\n  // 检查是否存在该文件\n  isExistObject(filePath: string) {\n    return new Promise(reslove =&amp;gt; {\n      request.get(\n        {\n          url: `${this.uploadUrl}/api/isExistObject?name=${this.prefix + filePath}&amp;amp;bucket=${\n            this.bucket\n          }`\n        },\n        (err: any, response: any, body: string) =&amp;gt; {\n          if (err) {\n            console.log(&#39;err&#39;, err)\n            process.exit(1)\n          }\n          if (response.statusCode !== 200) {\n            console.log(&#39;err&#39;, &#39;http err&#39;)\n            process.exit(1)\n          }\n          const bodys = JSON.parse(body)\n          if (bodys.code === 0) {\n            console.log(this.prefix + filePath, &#39;已存在&#39;.yellow)\n            reslove(0)\n          } else {\n            reslove(1)\n          }\n        }\n      )\n    })\n  }\n  // 上传\n  upload(filePath: string, outDir: string) {\n    return new Promise(reslove =&amp;gt; {\n      const formData = {\n        key: this.prefix + filePath,\n        file: fs.createReadStream(path.resolve(path.join(outDir, filePath))),\n        bucket: this.bucket\n      }\n      request.post(\n        {\n          url: `${this.uploadUrl}/api/upload`,\n          formData\n        },\n        (err: any, response: any, body: string) =&amp;gt; {\n          if (err) {\n            console.log(&#39;err&#39;, err)\n            process.exit(1)\n          }\n          if (response.statusCode !== 200) {\n            console.log(&#39;err&#39;, &#39;http err&#39;)\n            process.exit(1)\n          }\n          const bodys = JSON.parse(body)\n          if (bodys.code === 0) {\n            console.log(bodys.data.fixUrl, &#39;success~&#39;.green)\n            reslove(1)\n          }\n        }\n      )\n    })\n  }\n  // 上传前检测\n  uploadPre(filePath: string, outDir: string) {\n    this.isExistObject(filePath).then((res: number) =&amp;gt; {\n      if (res === 1) {\n        return this.upload(filePath, outDir)\n      }\n    })\n  }\n}\nexport default FileUploader\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们将它封装到前端组件库中，然后在vite中使用&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// vite.config.js\nimport { FileUploader } from &#39;@msb-next/vite-plugin-upload&#39;\nconst isProd = process.env.VITE_APP_ENV &amp;amp;&amp;amp; process.env.VITE_APP_ENV !== &#39;dev&#39;\n  let plugins = [\n    reactRefresh(),\n    antdDayjs(),\n    vitePluginImp({\n      libList: [\n        {\n          libName: &#39;lodash&#39;,\n          libDirectory: &#39;&#39;,\n          camel2DashComponentName: false,\n          style: () =&amp;gt; {\n            return false\n          },\n        },\n        {\n          libName: &#39;antd&#39;,\n          style(name) {\n            return `antd/es/${name}/style/index.css`\n          },\n        },\n      ],\n    }),\n  ]\n  let base = &#39;/&#39;\n  let sourcemap = true\n  //////////////////////////// 主要是这里 /////////////////////////////////////\n  if (isProd) {\n    const uploader = new FileUploader({\n      env: process.env.VITE_APP_ENV,\n    })\n    // 修改base路径\n    base = (await uploader.init()) as string\n    plugins.push(uploader.UploadPlugin())\n    sourcemap = false\n  }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;到这里，其实思路就很清晰了，大家基本能够完成一个自定义vite插件了，下面就是我node层的代码了，大家应该能看明白：&lt;br&gt;\n先自定义一个koa中间件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const OSS = require(&#39;ali-oss&#39;);\n/**\n * oss 连接oss\n * @param ctx\n * @param next\n * @returns {Promise&amp;lt;void&amp;gt;}\n */\nconst connect = async (ctx, next) =&amp;gt; {\n  let bucket = &#39;&#39;;\n  if (ctx.request.method === &#39;POST&#39;) {\n    const body = ctx.request.body;\n    bucket = body.bucket;\n  } else {\n    bucket = ctx.query.bucket;\n  }\n  // 从redis中获取oss密钥等重要信息，看看是否支持当前的bucket，这样新增bucket时比较灵活，当然也可以直接写死。\n  const ossAccessRes = await redisClient.get(&#39;ossAccess&#39;);\n  const ossAccess = JSON.parse(ossAccessRes);\n\n  const ossConf = ossAccess.find(v =&amp;gt; v.bucket === bucket);\n  let client, urlPrefix;\n  try {\n    client = new OSS(ossConf);\n    urlPrefix = ossConf.url;\n  } catch (e) {\n    ctx.DATA.msg = &#39;暂不支持当前bucket&#39;;\n    ctx.body = ctx.DATA;\n    throw new HttpError(200);\n  }\n  ctx.OSS = client;\n  ctx.urlPrefix = urlPrefix;\n  await next();\n};\n\nmodule.exports = {\n  connect\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;router.js&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const router = require(&#39;koa-router&#39;)();\n\n// 刚才定义的 oss 中间件\nconst oss = require(&#39;../utils/middleware/oss&#39;);\n\n// 控制器\nconst {index, bucketList} = require(&#39;../controllers/index&#39;);\nconst api = require(&#39;../controllers/api&#39;);\n\n// 添加路由\nrouter.post(&#39;/api/upload&#39;, oss.connect, api.upload);\nrouter.get(&#39;/api/list&#39;, oss.connect, api.list);\nrouter.get(&#39;/api/url&#39;, oss.connect, api.url);\nrouter.post(&#39;/api/del&#39;, oss.connect, api.del);\nrouter.get(&#39;/api/isExistObject&#39;, oss.connect, api.isExistObject);\nrouter.get(&#39;/api/bucketList&#39;, bucketList);\n\nmodule.exports = router;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;controller/api.js&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const fs = require(&#39;fs&#39;);\nconst {CustomError} = require(&#39;../utils/tool/error&#39;);\nconst DEL_SWITCH = false;\n\n/**\n * 上传\n */\nconst upload = async (ctx) =&amp;gt; {\n  const {file} = ctx.request.files;\n  const {key} = ctx.request.body;\n  const stream = fs.createReadStream(file.path);\n  const {name, res, url} = await ctx.OSS.putStream(key, stream);\n  ctx.DATA.data = {\n    ...res,\n    name,\n    url,\n    fixUrl: `${ctx.urlPrefix}/${name}`\n  };\n  ctx.body = ctx.DATA;\n};\n\n/**\n * 获取oss列表\n */\nconst list = async (ctx, next) =&amp;gt; {\n  const name = ctx.query.name;\n  console.log(name);\n  ctx.DATA.data = await ctx.OSS.list({\n    prefix: name,\n    delimiter: &#39;/&#39;\n  });\n  if (ctx.DATA.data.res.status !== 200) {\n    throw new CustomError(0, &#39;文件查找失败&#39;);\n  }\n  delete ctx.DATA.data.res;\n  ctx.body = ctx.DATA;\n};\n\n/**\n * 获取文件下载链接，有效期1分钟\n */\nconst url = async (ctx) =&amp;gt; {\n  const name = ctx.query.name;\n  ctx.DATA.data = ctx.OSS.signatureUrl(name, {expires: 3600});\n  ctx.body = ctx.DATA;\n};\n\n/**\n * 删除文件、文件夹\n */\nconst del = async (ctx) =&amp;gt; {\n  if (DEL_SWITCH) {\n    let dat = ctx.request.body;\n    let delList = dat[0];\n    let directory = dat[1];\n    try {\n      for (let i = 0; i &amp;lt; directory.length; i++) {\n        let retList = await ctx.OSS.list({\n          prefix: directory[i]\n        });\n        retList.objects.reverse();\n        retList.objects.map(item =&amp;gt; {\n          delList.push(item.name);\n        });\n      }\n    } catch (e) {\n      throw new CustomError(0, &#39;删除文件:整合失败&#39;);\n    }\n    let result = await ctx.OSS.deleteMulti(delList, {quiet: true});\n    if (result.res.status !== 200) {\n      throw new CustomError(0, &#39;删除失败&#39;);\n    }\n    ctx.DATA.msg = &#39;删除成功&#39;;\n    ctx.body = ctx.DATA;\n  } else {\n    ctx.DATA.msg = &#39;删除文件、文件夹功能未开放！&#39;;\n    ctx.body = ctx.DATA;\n  }\n};\n\n/**\n * 判断文件是否存在\n * @param ctx\n * @returns {Promise&amp;lt;void&amp;gt;}\n */\nconst isExistObject = async (ctx) =&amp;gt; {\n  // 用于判断受版本控制Bucket中指定versionId的Object是否存在。\n  const options = {\n    // 填写Object的versionId。\n    versionId: &#39;&#39;\n  };\n  const name = ctx.query.name;\n  try {\n    const res = await ctx.OSS.head(name, options);\n    ctx.DATA.data = res;\n    ctx.DATA.msg = &#39;文件存在&#39;;\n    ctx.body = ctx.DATA;\n  }  catch (error) {\n    if (error.code === &#39;NoSuchKey&#39;) {\n      ctx.DATA.code = 1;\n      ctx.DATA.msg = &#39;文件不存在&#39;;\n      ctx.body = ctx.DATA;\n    }\n  }\n};\n\nmodule.exports = {\n  upload,\n  list,\n  url,\n  del,\n  isExistObject,\n};\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;vite-zi-ding-yi-cha-jian&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;vite自定义上传插件&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;vite&#34;,&#34;slug&#34;:&#34;94Lh5N6ed&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/94Lh5N6ed&#34;},{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;},{&#34;name&#34;:&#34;工程化&#34;,&#34;slug&#34;:&#34;_l9fydARk&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/_l9fydARk&#34;}],&#34;date&#34;:&#34;2022-02-15 19:53:23&#34;,&#34;dateFormat&#34;:&#34;2022-02-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/vite-zi-ding-yi-cha-jian&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;18 min read&#34;,&#34;time&#34;:1045000,&#34;words&#34;:3910,&#34;minutes&#34;:18},&#34;description&#34;:&#34;vite官网自定义插件\nVite 插件扩展了设计出色的 Rollup 接口，带有一些 Vite 独有的配置项。因为vite是使用rollup打包的所以最好你能了解Rollup 插件文档\n\n下面的都是按照官网介绍写的，因为毕竟你看到我这了，直...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%A6%E5%AE%9A\&#34;&gt;约定&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE\&#34;&gt;插件配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B\&#34;&gt;简单示例&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BD%AC%E6%8D%A2%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B\&#34;&gt;转换自定义文件类型&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%9A%E7%94%A8%E9%92%A9%E5%AD%90\&#34;&gt;通用钩子&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#vite-%E7%8B%AC%E6%9C%89%E9%92%A9%E5%AD%90\&#34;&gt;Vite 独有钩子&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#config\&#34;&gt;config&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#configresolved\&#34;&gt;configResolved&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#configureserver\&#34;&gt;configureServer&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#transformindexhtml\&#34;&gt;transformIndexHtml&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#handlehotupdate\&#34;&gt;handleHotUpdate&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%92%E4%BB%B6%E9%A1%BA%E5%BA%8F\&#34;&gt;插件顺序&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%83%85%E6%99%AF%E5%BA%94%E7%94%A8\&#34;&gt;情景应用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rollup-%E6%8F%92%E4%BB%B6%E5%85%BC%E5%AE%B9%E6%80%A7\&#34;&gt;Rollup 插件兼容性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#a-idtest-nametest%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98a\&#34;&gt;&lt;a id=\&#34;test\&#34; name=\&#34;test\&#34;&gt;项目实战&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;1-webpack插件的基本原理\&#34;&gt;1、webpack插件的基本原理&lt;/h3&gt;\n&lt;p&gt;我们知道，webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。&lt;br&gt;\nwebpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好。&lt;br&gt;\n&lt;a href=\&#34;https://www.webpackjs.com/contribute/writing-a-plugin/\&#34;&gt;官网提供的自定义插件文档&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;tapable 是一个类似于 Node.js 中的 EventEmitter的库，但更专注于自定义事件的触发和处理。webpack 通过 tapable 将实现与流程解耦，所有具体实现通过插件的形式存在。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;tapable作为webpack的主模块，需要单独抽一篇出来讲。需要注意的是，如果你要写sdk需要向外层吐露数据的话，建议还是用EventEmitter库，不建议用tapable，因为它销毁全部注册事件不是很容易。&lt;br&gt;\n好了，写webpack插件必须要了解tapable，这里我们先简单介绍一下它的几个常用的钩子，其他的可以网上查，这里有篇写的还不错&lt;a href=\&#34;https://blog.csdn.net/mafan121/article/details/113120081\&#34;&gt;tapable详解&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;const {\n  SyncHook,\n  SyncBailHook,\n  SyncWaterfallHook,\n  SyncLoopHook,\n  AsyncParallelHook,\n  AsyncParallelBailHook,\n  AsyncSeriesHook,\n  AsyncSeriesBailHook,\n  AsyncSeriesWaterfallHook\n} = require(&#39;tapable&#39;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;tapable通过tap注册一个事件通过call执行该钩子注册的所有事件-tapable的每个hooks都tap一个或多个事件-tapasynccallasync-tappromisepromise用于注册同步执行的异步事件callasync用在并行执行的异步钩子完成后再执行该函数\&#34;&gt;tapable通过tap注册一个事件，通过call执行该钩子注册的所有事件。tapable的每个hooks都tap一个或多个事件。tapAsync/callAsync、tapPromise/Promise用于注册同步执行的异步事件，callAsync用在并行执行的异步钩子完成后再执行该函数。&lt;/h3&gt;\n&lt;p&gt;具体使用举个例子（比如SyncHook，依次执行注册事件，无法中断）&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt; const hook = new SyncHook([&#39;name&#39;, &#39;sex&#39;])\n  /*\n  tap(options,function):\n  options是事件描述，可以为一个字符串，也可以为一个对象,为对象时必须包含name属性，描述该插件名称。\n  function:回调函数\n  */\n  // 打印我的名字\n  hook.tap(&#39;printName&#39;, (name) =&amp;gt; {\n    console.log(&#39;my name is &#39; + name);\n  })\n  hook.tap(&#39;printSex&#39;, (name, sex) =&amp;gt; {\n    console.log(&#39;I’m a &#39; + sex);\n  })\n  // call(arg1,arg2,...)\n  hook.call(&#39;张三&#39;, &#39;man&#39;);\n\n  执行结果：\n\n    my name is 张三\n\n    I’m a man\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;好了，说了一堆tapable了，该说webpack插件了。&lt;/p&gt;\n&lt;p&gt;webpack 插件由以下组成：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;一个 JavaScript 命名函数。&lt;/li&gt;\n&lt;li&gt;在插件函数的 prototype 上定义一个 apply 方法。&lt;/li&gt;\n&lt;li&gt;指定一个绑定到 webpack 自身的事件钩子。&lt;/li&gt;\n&lt;li&gt;处理 webpack 内部实例的特定数据。&lt;/li&gt;\n&lt;li&gt;功能完成后调用 webpack 提供的回调。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;下面是官网的简单例子：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 一个 JavaScript 命名函数。\nfunction MyExampleWebpackPlugin() {\n\n};\n\n// 在插件函数的 prototype 上定义一个 `apply` 方法。\nMyExampleWebpackPlugin.prototype.apply = function(compiler) {\n  // 指定一个挂载到 webpack 自身的事件钩子。\n  compiler.plugin(&#39;webpacksEventHook&#39;, function(compilation /* 处理 webpack 内部实例的特定数据。*/, callback) {\n    console.log(&amp;quot;This is an example plugin!!!&amp;quot;);\n\n    // 功能完成后调用 webpack 提供的回调。\n    callback();\n  });\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在我们使用该plugin的时候，相关调用及配置代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const MyExampleWebpackPlugin = require(&#39;./MyExampleWebpackPlugin&#39;);\nmodule.exports = {\n  plugins: [\n    new MyExampleWebpackPlugin(options)\n  ]\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我开始说了一大堆tapable，其实就是为了说明白webpack插件的原理&lt;/p&gt;\n&lt;p&gt;用代码说明吧，一个compiler.js，一个main.js&lt;br&gt;\ncompiler.js&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 需要做的事情如下：\n// 1. 定义一个 Compiler 类，接收一个options对象参数，该参数是从main.js中的MyPlugin类的实列对象。该对象下有 apply函数。\n\n// 2. 在该类中我们定义了run方法，我们在main.js 中执行该run函数就可以自动执行对应的插件了。\n\nconst { SyncHook, AsyncParallelHook } = require(&#39;tapable&#39;);\n\nclass Compiler {\n  constructor(options) {\n    this.hooks = {\n      kzSyncHook: new SyncHook([&#39;name&#39;, &#39;age&#39;]),\n      kzAsyncHook: new AsyncParallelHook([&#39;name&#39;, &#39;age&#39;])\n    };\n    let plugins = options.plugins;\n    if (plugins &amp;amp;&amp;amp; plugins.length &amp;gt; 0) {\n      plugins.forEach(plugin =&amp;gt; plugin.apply(this));\n    }\n  }\n  run() {\n    console.log(&#39;开始执行了---------&#39;);\n    this.kzSyncHook(&#39;我是小明&#39;, 81);\n    this.kzAsyncHook(&#39;我是小红&#39;, 91);\n  }\n  kzSyncHook(name, age) {\n    this.hooks.kzSyncHook.call(name, age);\n  }\n  kzAsyncHook(name, age) {\n    this.hooks.kzAsyncHook.callAsync(name, age);\n  }\n}\n\nmodule.exports = Compiler;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;main.js&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 需要做的事情如下：\n// 1. 引入 compiler.js 文件。\n// 2. 定义一个自己的插件，比如叫 MyPlugin 类，该类下有 apply 函数。该函数有一个 compiler 参数，该参数就是我们的 compiler.js 中的实列对象。然后我们会使用 compiler 实列对象去调用 compiler.js 里面的函数。因此就可以自动执行了。\nconst Compiler = require(&#39;./compiler&#39;);\n\nclass MyPlugin {\n  constructor() {\n    \n  }\n  apply(compiler) {\n    compiler.hooks.kzSyncHook.tap(&amp;quot;eventName1&amp;quot;, (name, age) =&amp;gt; {\n      console.log(`同步事件eventName1： ${name} this year ${age} 周岁了, 可是还是单身`);\n    });\n    compiler.hooks.kzAsyncHook.tapAsync(&#39;eventName2&#39;, (name, age) =&amp;gt; {\n      setTimeout(() =&amp;gt; {\n        console.log(`异步事件eventName2： ${name} this year ${age}周岁了，可是还是单身`);\n      }, 1000)\n    });\n  }\n}\n\nconst myPlugin = new MyPlugin();\n\nconst options = {\n  plugins: [myPlugin]\n};\n\nconst compiler = new Compiler(options);\ncompiler.run();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;看到没，这种使用方式是不是和官网的使用方式很相似～这回知道原理了吧～&lt;/p&gt;\n&lt;p&gt;现在看官网的简单例子，webpack启动后，在读取配置的过程中会先执行 new MyExampleWebpackPlugin(options) 初始化MyExampleWebpackPlugin来获得一个实例。&lt;br&gt;\n然后我们会把该实例当做参数传递给我们的Compiler对象，然后会实例化 Compiler类(这个逻辑可以结合看我们上面实现了一个简单的demo中 的main.js和compiler.js的代码结合起来理解)。在Compiler类中，我们会获取到options的这个参数，该参数是一个对象，该对象下有一个 plugins 这个属性。&lt;br&gt;\n然后遍历该属性，然后依次执行 某项插件中的apply方法，即：myExampleWebpackPlugin.apply(compiler); 给插件传递compiler对象。插件实例获取该compiler对象后，就可以通过 compiler.plugin(&#39;事件名称&#39;, &#39;回调函数&#39;); 监听到webpack广播出来的事件.(这个地方我们可以看我们上面的main.js中的如下代码可以看到, 在我们的main.js代码中有这样代码：compiler.hooks.kzSyncHook.tap(&amp;quot;eventName1&amp;quot;, (name, age) =&amp;gt; {}));&lt;/p&gt;\n&lt;p&gt;如上就是一个简单的Plugin的插件原理(切记：结合上面的demo中main.js和compiller.js来理解效果会更好)。&lt;/p&gt;\n&lt;h3 id=\&#34;2-compiler-和-compilation\&#34;&gt;2、Compiler 和 Compilation&lt;/h3&gt;\n&lt;p&gt;在开发Plugin时我们最常用的两个对象就是 Compiler 和 Compilation, 他们是Plugin和webpack之间的桥梁。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;compiler对象\&#34;&gt;Compiler对象&lt;/h4&gt;\n&lt;p&gt;Compiler对象包含了Webpack环境所有的配置信息，包含options，loaders, plugins这些项，这个对象在webpack启动时候被实例化，它是全局唯一的。我们可以把它理解为webpack的实例。&lt;/p&gt;\n&lt;p&gt;基本源码可以看如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// webpack/lib/webpack.js\nconst Compiler = require(&amp;quot;./Compiler&amp;quot;)\n\nconst webpack = (options, callback) =&amp;gt; {\n  ...\n  // 初始化 webpack 各配置参数\n  options = new WebpackOptionsDefaulter().process(options);\n\n  // 初始化 compiler 对象，这里 options.context 为 process.cwd()\n  let compiler = new Compiler(options.context);\n\n  compiler.options = options                               // 往 compiler 添加初始化参数\n\n  new NodeEnvironmentPlugin().apply(compiler)              // 往 compiler 添加 Node 环境相关方法\n\n  for (const plugin of options.plugins) {\n    plugin.apply(compiler);\n  }\n  ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/webpack/webpack/blob/10282ea20648b465caec6448849f24fc34e1ba3e/lib/webpack.js#L30\&#34;&gt;源码可以点击这里&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;如上我们可以看到，Compiler对象包含了所有的webpack可配置的内容。开发插件时，我们可以从 compiler 对象中拿到所有和 webpack 主环境相关的内容。&lt;/p&gt;\n&lt;h4 id=\&#34;compilation对象\&#34;&gt;compilation对象&lt;/h4&gt;\n&lt;p&gt;compilation 对象包含了当前的模块资源、编译生成资源、文件的变化等。当webpack在开发模式下运行时，每当检测到一个文件发生改变的时候，那么一次新的 Compilation将会被创建。从而生成一组新的编译资源。&lt;/p&gt;\n&lt;p&gt;Compiler对象 与 Compilation 对象 的区别是：Compiler代表了是整个webpack从启动到关闭的生命周期。Compilation 对象只代表了一次新的编译。&lt;/p&gt;\n&lt;p&gt;Compiler对象的事件钩子:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;钩子               作用                     参数               类型\nafter-plugins     设置完一组初始化插件之后    compiler          sync\nafter-resolvers   设置完 resolvers 之后     compiler          sync\nrun               在读取记录之前             compiler          async\ncompile           在创建新 compilation之前  compilationParams  sync\ncompilation       compilation 创建完成      compilation        sync\nemit              在生成资源并输出到目录之前  compilation        async\nafter-emit        在生成资源并输出到目录之后  compilation        async\ndone              完成编译                  stats              sync\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/webpack/webpack/blob/eca7bad8de54c39b9cb8b138793362b8a17ac11b/lib/Compiler.js#L32\&#34;&gt;源码地址&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\&#34;理解webpack中的事件流\&#34;&gt;理解webpack中的事件流&lt;/h4&gt;\n&lt;p&gt;我们可以把webpack理解为一条生产线，需要经过一系列处理流程后才能将源文件转换成输出结果。&lt;br&gt;\n这条生产线上的每个处理流程的职责都是单一的，多个流程之间会存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。&lt;/p&gt;\n&lt;p&gt;我们的插件就像一个插入到生产线中的一个功能，在特定的时机对生产线上的资源会做处理。webpack它是通过 Tapable来组织这条复杂的生产线的。&lt;/p&gt;\n&lt;p&gt;webpack在运行的过程中会广播事件，插件只需要关心监听它的事件，就能加入到这条生产线中。然后会执行相关的操作。&lt;br&gt;\nwebpack的事件流机制它能保证了插件的有序性，使整个系统的扩展性好。事件流机制使用了观察者模式来实现的。比如如下代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 广播事件\n * myPlugin-name 为事件名称\n * params 为附带的参数\n*/\n\ncompiler.apply(&#39;myPlugin-name&#39;, params); // myPlugin-name随便写，就是一个名字\n\n/*\n * 监听名称为 &#39;myPlugin-name&#39; 的事件，当 myPlugin-name 事件发生时，函数就会执行。\n*/\n\ncompiler.hooks.myPlugin-name.tap(&#39;myPlugin-name&#39;, function(params) {\n  \n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;插件中常用的api\&#34;&gt;插件中常用的API&lt;/h3&gt;\n&lt;h4 id=\&#34;compiler生命周期钩子\&#34;&gt;compiler生命周期钩子&lt;/h4&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.webpackjs.com/api/compiler-hooks/\&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Compiler 支持可以监控文件系统的&lt;a href=\&#34;https://www.webpackjs.com/api/node/#watching\&#34;&gt;监听(watching)&lt;/a&gt;机制，并且在文件修改时重新编译。当处于监听模式(watch mode)时，compiler 会触发诸如 watchRun, watchClose 和 invalid 等额外的事件。通常用于开发环境中使用，也常常会在 webpack-dev-server 这些工具的底层之下调用，由此开发人员无须每次都使用手动方式重新编译。还可以通过 CLI 进入监听模式。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;相关钩子：&lt;br&gt;\n以下生命周期钩子函数，是由 compiler 暴露，可以通过如下方式访问：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;compiler.hooks.someHook.tap(...)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;取决于不同的钩子类型，也可以在某些钩子上访问 tapAsync 和 tapPromise。&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;生命周期&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;对应hooks&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;执行时机&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;参数&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;entryOption&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncBailHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;在 entry 配置项处理过之后，执行插件。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;afterPlugins&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;设置完初始插件之后，执行插件。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compiler&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;afterResolvers&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;resolver 安装完成之后，执行插件。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compiler&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;environment&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;environment 准备好之后，执行插件。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;afterEnvironment&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;environment 安装完成之后，执行插件。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;beforeRun&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;AsyncSeriesHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compiler.run() 执行之前，添加一个钩子。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compiler&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;run&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;AsyncSeriesHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;开始读取 records 之前，钩入(hook into) compiler。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compiler&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;watchRun&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;AsyncSeriesHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;监听模式下，一个新的编译(compilation)触发之后，执行一个插件，但是是在实际编译开始之前。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compiler&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;normalModuleFactory&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;NormalModuleFactory 创建之后，执行插件。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;normalModuleFactory&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;contextModuleFactory&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;ContextModuleFactory 创建之后，执行插件。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;contextModuleFactory&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;beforeCompile&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;AsyncSeriesHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;编译(compilation)参数创建之后，执行插件。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compilationParams&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compile&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;一个新的编译(compilation)创建之后，钩入(hook into) compiler。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compilationParams&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;thisCompilation&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;触发 compilation 事件之前执行（查看下面的 compilation）&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compilation&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compilation&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;编译(compilation)创建之后，执行插件&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compilation&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;make&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;AsyncParallelHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compilation&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;afterCompile&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;AsyncSeriesHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compilation&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;shouldEmit&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncBailHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;此时返回 true/false。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compilation&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;needAdditionalPass&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncBailHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;emit&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;AsyncSeriesHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;生成资源到 output 目录之前。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compilation&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;afterEmit&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;AsyncSeriesHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;生成资源到 output 目录之后。&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;compilation&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;done&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;编译(compilation)完成&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;stats&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;failed&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;编译(compilation)失败&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;error&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;invalid&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;监听模式下，编译无效时&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;fileName, changeTime&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;watchClose&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;SyncHook&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;监听模式停止&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h4 id=\&#34;读取输出资源-模块及依赖\&#34;&gt;读取输出资源、模块及依赖&lt;/h4&gt;\n&lt;p&gt;在我们的emit钩子事件发生时，表示的含义是：源文件的转换和组装已经完成了，在这里事件钩子里面我们可以读取到最终将输出的资源、代码块、模块及对应的依赖文件。并且我们还可以输出资源文件的内容。比如插件代码如下:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;class MyPlugin {\n  apply(compiler) {\n    compiler.plugin(&#39;emit&#39;, function(compilation, callback) {\n      // compilation.chunks 是存放了所有的代码块，是一个数组，我们需要遍历\n      compilation.chunks.forEach(function(chunk) {\n        /*\n         * chunk 代表一个代码块，代码块它是由多个模块组成的。\n         * 我们可以通过 chunk.forEachModule 能读取组成代码块的每个模块\n        */\n        chunk.forEachModule(function(module) {\n          // module 代表一个模块。\n          // module.fileDependencies 存放当前模块的所有依赖的文件路径，它是一个数组\n          module.fileDependencies.forEach(function(filepath) {\n            console.log(filepath);\n          });\n        });\n        /*\n         webpack 会根据chunk去生成输出的文件资源，每个chunk都对应一个及以上的输出文件。\n         比如在 Chunk中包含了css 模块并且使用了 ExtractTextPlugin 时，\n         那么该Chunk 就会生成 .js 和 .css 两个文件\n        */\n        chunk.files.forEach(function(filename) {\n          // compilation.assets 是存放当前所有即将输出的资源。\n          // 调用一个输出资源的 source() 方法能获取到输出资源的内容\n          const source = compilation.assets[filename].source();\n        });\n      });\n      /*\n       该事件是异步事件，因此要调用 callback 来通知本次的 webpack事件监听结束。\n       如果我们没有调用callback(); 那么webpack就会一直卡在这里不会往后执行。\n      */\n      callback();\n    })\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;监听文件变化\&#34;&gt;监听文件变化&lt;/h4&gt;\n&lt;p&gt;webpack读取文件的时候，它会从入口模块去读取，然后依次找出所有的依赖模块。当入口模块或依赖的模块发生改变的时候，那么就会触发一次新的 Compilation。&lt;/p&gt;\n&lt;p&gt;在我们开发插件的时候，我们需要知道是那个文件发生改变，导致了新的Compilation, 我们可以添加如下代码进行监听。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 当依赖的文件发生改变的时候 会触发 watch-run 事件\nclass MyPlugin {\n  apply(compiler) {\n    compiler.plugin(&#39;watch-run&#39;, (watching, callback) =&amp;gt; {\n      // 获取发生变换的文件列表\n      const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes;\n      // changedFiles 格式为键值对的形式，当键为发生变化的文件路径\n      if (changedFiles[filePath] !== undefined) {\n        // 对应的文件就发生了变化了\n      }\n      callback();\n    });\n\n    /*\n     默认情况下Webpack只会监听入口文件或其依赖的模块是否发生变化，但是在有些情况下比如html文件发生改变的时候，那么webpack\n     就会去监听html文件的变化。因此就不会重新触发新的 Compilation。因此为了监听html文件的变化，我们需要把html文件加入到\n     依赖列表中。因此我们需要添加如下代码：\n    */\n    compiler.plugin(&#39;after-compile&#39;, (compilation, callback) =&amp;gt; {\n      /*\n       如下的参数filePath是html文件路径，我们把HTML文件添加到文件依赖表中，然后我们的webpack会去监听html模块文件，\n       html模板文件发生改变的时候，会重新启动下重新编译一个新的 Compilation.\n      */\n      compilation.fileDependencies.push(filePath);\n      callback();\n    })\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;修改输出资源\&#34;&gt;修改输出资源&lt;/h4&gt;\n&lt;p&gt;我们在第一点说过：在我们的emit钩子事件发生时，表示的含义是：源文件的转换和组装已经完成了，在这里事件钩子里面我们可以读取到最终将输出的资源、代码块、模块及对应的依赖文件。因此如果我们现在要修改输出资源的内容的话，我们可以在emit事件中去做修改。那么所有输出的资源会存放在 compilation.assets中，compilation.assets是一个键值对，键为需要输出的文件名，值为文件对应的内容。如下代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;class MyPlugin {\n  apply(compiler) {\n    compiler.plugin(&#39;emit&#39;, (compilation, callback) =&amp;gt; {\n      // 设置名称为 fileName 的输出资源\n      compilation.assets[fileName] = {\n        // 返回文件内容\n        source: () =&amp;gt; {\n          // fileContent 即可以代表文本文件的字符串，也可以是代表二进制文件的buffer\n          return fileContent;\n        },\n        // 返回文件大小\n        size: () =&amp;gt; {\n          return Buffer.byteLength(fileContent, &#39;utf8&#39;);\n        }\n      };\n      callback();\n    });\n    // 读取 compilation.assets 代码如下：\n    compiler.plugin(&#39;emit&#39;, (compilation, callback) =&amp;gt; {\n      // 读取名称为 fileName 的输出资源\n      const asset = compilation.assets[fileName];\n      // 获取输出资源的内容\n      asset.source();\n      // 获取输出资源的文件大小\n      asset.size();\n      callback();\n    });\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;判断webpack使用了哪些插件\&#34;&gt;判断webpack使用了哪些插件&lt;/h4&gt;\n&lt;p&gt;在我们开发一个插件的时候，我们需要根据当前配置是否使用了其他某个插件，我们可以通过读取webpack某个插件配置的情况，比如来判断我们当前是否使用了 HtmlWebpackPlugin 插件。代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;/*\n 判断当前配置使用了 HtmlWebpackPlugin 插件。\n compiler参数即为 webpack 在 apply(compiler) 中传入的参数\n*/\n\nfunction hasHtmlWebpackPlugin(compiler) {\n  // 获取当前配置下所有的插件列表\n  const plugins = compiler.options.plugins;\n  // 去plugins中寻找有没有 HtmlWebpackPlugin 的实列\n  return plugins.find(plugin =&amp;gt; plugin.__proto__.constructor === HtmlWebpackPlugin) !== null;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;实战\&#34;&gt;实战&lt;/h3&gt;\n&lt;h4 id=\&#34;实现一个打印日志的logwebpackplugin插件\&#34;&gt;实现一个打印日志的LogWebpackPlugin插件&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 这个文件为了观看更直观，先放到webpack.config.js中，真正使用时可以将你的自定义webpack插件封装到你们的前端组件库中。\nclass LogWebpackPlugin {\n  constructor(doneCallback, emitCallback) {\n    this.emitCallback = emitCallback\n    this.doneCallback = doneCallback\n  }\n  apply(compiler) {\n    compiler.hooks.emit.tap(&#39;LogWebpackPlugin&#39;, () =&amp;gt; {\n      // 在 emit 事件中回调 emitCallback\n      this.emitCallback();\n    });\n    compiler.hooks.done.tap(&#39;LogWebpackPlugin&#39;, (err) =&amp;gt; {\n      // 在 done 事件中回调 doneCallback\n      this.doneCallback();\n    });\n    compiler.hooks.compilation.tap(&#39;LogWebpackPlugin&#39;, () =&amp;gt; {\n      // compilation（&#39;编译器&#39;对&#39;编译ing&#39;这个事件的监听）\n      console.log(&amp;quot;The compiler is starting a new compilation...&amp;quot;)\n    });\n    compiler.hooks.compile.tap(&#39;LogWebpackPlugin&#39;, () =&amp;gt; {\n      // compile（&#39;编译器&#39;对&#39;开始编译&#39;这个事件的监听）\n      console.log(&amp;quot;The compiler is starting to compile...&amp;quot;)\n    });\n  }\n}\n\n\n// 使用\nmodule.exports = {\n  plugins: [\n    new LogWebpackPlugin(() =&amp;gt; {\n      // Webpack 模块完成转换成功\n      console.log(&#39;emit 事件发生啦，所有模块的转换和代码块对应的文件已经生成好~&#39;)\n    } , () =&amp;gt; {\n      // Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作\n      console.log(&#39;done 事件发生啦，成功构建完成~&#39;)\n    })\n  ]\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;编写去除生成-bundlejs-中多余的注释的插件\&#34;&gt;编写去除生成 bundle.js 中多余的注释的插件&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;class MyPlugin {\n  constructor(options) {\n    this.options = options;\n    this.externalModules = {};\n  }\n  apply(compiler) {\n    var reg = /(&amp;quot;([^\\\\\\&amp;quot;]*(\\\\.)?)*&amp;quot;)|(&#39;([^\\\\\\&#39;]*(\\\\.)?)*&#39;)|(\\/{2,}.*?(\\r|\\n))|(\\/\\*(\\n|.)*?\\*\\/)|(\\/\\*\\*\\*\\*\\*\\*\\/)/g;\n    compiler.hooks.emit.tap(&#39;CodeBeautify&#39;, (compilation) =&amp;gt; {\n      Object.keys(compilation.assets).forEach((data) =&amp;gt; {\n        console.log(data);\n        let content = compilation.assets[data].source(); // 获取处理的文本\n        content = content.replace(reg, function (word) { // 去除注释后的文本\n          return /^\\/{2,}/.test(word) || /^\\/\\*!/.test(word) || /^\\/\\*{3,}\\//.test(word) ? &amp;quot;&amp;quot; : word;\n        });\n        compilation.assets[data] = {\n          source() {\n            return content;\n          },\n          size() {\n            return content.length;\n          }\n        }\n      });\n    });\n  }\n}\nmodule.exports = MyPlugin;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个js代码的真正的含义才是我们今天要讲到的，这个插件最主要作用是 去除注释后的文本。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;第一步，我们使用 compiler.hooks.emit 钩子函数。在生成资源并输出到目录之前触发该函数，也就是说将编译好的代码发射到指定的stream中就会触发，然后我们从回调函数返回的 compilation 对象上可以拿到编译好的 stream.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;访问compilation对象，compilation内部会返回很多内部对象，这边先不打印了，因为打印的话直接会卡死掉，要等很长时间才会打印出来，你们自己可以试试；然后我们遍历 assets.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;Object.keys(compilation.assets).forEach((data) =&amp;gt; {\n  console.log(compilation.assets);\n  console.log(8888)\n  console.log(data);\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如下图所示：&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644922971138.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;assets 数组对象中的key是资源名。在如上代码，我们通过 Object.key()方法拿到了。如下所示：&lt;pre&gt;&lt;code&gt;main.css\nbundle.js\nindex.html\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;然后我们调用 compilation.assets[data].source(); 可以获取资源的内容。&lt;/li&gt;\n&lt;li&gt;使用正则，去掉注释，如下代码：&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;Object.keys(compilation.assets).forEach((data) =&amp;gt; {\n  let content = compilation.assets[data].source(); // 获取处理的文本\n  content = content.replace(reg, function (word) { // 去除注释后的文本\n      return /^\\/{2,}/.test(word) || /^\\/\\*!/.test(word) || /^\\/\\*{3,}\\//.test(word) ? &amp;quot;&amp;quot; : word;\n  });\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;更新 compilation.assets[data] 对象，如下代码：&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;compilation.assets[data] = {\n  source() {\n      return content;\n  },\n  size() {\n      return content.length;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;最后使用&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;module.exports = {\n  plugins:[\n      new MyPlugin(),\n  ]\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;webpack40之后用compilerhooks注册之前用comlilerplugin注册但为了保险起见还是两种办法都写这样能应付服务器无webpack4版本详见这篇文章\&#34;&gt;webpack4.0之后用compiler.hooks注册，之前用comliler.plugin注册，但为了保险起见，还是两种办法都写，这样能应付服务器无webpack4版本，详见：&lt;a href=\&#34;https://www.cnblogs.com/dashnowords/p/9572749.html\&#34;&gt;这篇文章&lt;/a&gt;&lt;/h4&gt;\n&lt;h3 id=\&#34;最后扩展简单看了几个插件之后是不是可以考虑做些其他的事情比如删除consolelog-或者构建完成时做一些文件上传cdn的操作马上动手吧~\&#34;&gt;最后扩展：简单看了几个插件之后，是不是可以考虑做些其他的事情，比如删除console.log、或者构建完成时做一些文件上传cdn的操作，马上动手吧～&lt;/h3&gt;\n&#34;,&#34;fileName&#34;:&#34;zi-ding-yi-yi-ge-webpack-de-cha-jian&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;自定义一个WebPack的插件&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;webpack&#34;,&#34;slug&#34;:&#34;ZE2xVCkDq&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/ZE2xVCkDq&#34;}],&#34;date&#34;:&#34;2022-02-14 18:32:14&#34;,&#34;dateFormat&#34;:&#34;2022-02-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/zi-ding-yi-yi-ge-webpack-de-cha-jian&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;21 min read&#34;,&#34;time&#34;:1215000,&#34;words&#34;:5141,&#34;minutes&#34;:21},&#34;description&#34;:&#34;1、webpack插件的基本原理\n我们知道，webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-webpack%E6%8F%92%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\&#34;&gt;1、webpack插件的基本原理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tapable%E9%80%9A%E8%BF%87tap%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E9%80%9A%E8%BF%87call%E6%89%A7%E8%A1%8C%E8%AF%A5%E9%92%A9%E5%AD%90%E6%B3%A8%E5%86%8C%E7%9A%84%E6%89%80%E6%9C%89%E4%BA%8B%E4%BB%B6-tapable%E7%9A%84%E6%AF%8F%E4%B8%AAhooks%E9%83%BDtap%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E4%BA%8B%E4%BB%B6-tapasynccallasync-tappromisepromise%E7%94%A8%E4%BA%8E%E6%B3%A8%E5%86%8C%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6callasync%E7%94%A8%E5%9C%A8%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E5%BC%82%E6%AD%A5%E9%92%A9%E5%AD%90%E5%AE%8C%E6%88%90%E5%90%8E%E5%86%8D%E6%89%A7%E8%A1%8C%E8%AF%A5%E5%87%BD%E6%95%B0\&#34;&gt;tapable通过tap注册一个事件，通过call执行该钩子注册的所有事件。tapable的每个hooks都tap一个或多个事件。tapAsync/callAsync、tapPromise/Promise用于注册同步执行的异步事件，callAsync用在并行执行的异步钩子完成后再执行该函数。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-compiler-%E5%92%8C-compilation\&#34;&gt;2、Compiler 和 Compilation&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#compiler%E5%AF%B9%E8%B1%A1\&#34;&gt;Compiler对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#compilation%E5%AF%B9%E8%B1%A1\&#34;&gt;compilation对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%90%86%E8%A7%A3webpack%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81\&#34;&gt;理解webpack中的事件流&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%92%E4%BB%B6%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84api\&#34;&gt;插件中常用的API&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#compiler%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\&#34;&gt;compiler生命周期钩子&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%BB%E5%8F%96%E8%BE%93%E5%87%BA%E8%B5%84%E6%BA%90-%E6%A8%A1%E5%9D%97%E5%8F%8A%E4%BE%9D%E8%B5%96\&#34;&gt;读取输出资源、模块及依赖&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96\&#34;&gt;监听文件变化&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%AE%E6%94%B9%E8%BE%93%E5%87%BA%E8%B5%84%E6%BA%90\&#34;&gt;修改输出资源&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A4%E6%96%ADwebpack%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E6%8F%92%E4%BB%B6\&#34;&gt;判断webpack使用了哪些插件&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E6%88%98\&#34;&gt;实战&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E7%9A%84logwebpackplugin%E6%8F%92%E4%BB%B6\&#34;&gt;实现一个打印日志的LogWebpackPlugin插件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99%E5%8E%BB%E9%99%A4%E7%94%9F%E6%88%90-bundlejs-%E4%B8%AD%E5%A4%9A%E4%BD%99%E7%9A%84%E6%B3%A8%E9%87%8A%E7%9A%84%E6%8F%92%E4%BB%B6\&#34;&gt;编写去除生成 bundle.js 中多余的注释的插件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#webpack40%E4%B9%8B%E5%90%8E%E7%94%A8compilerhooks%E6%B3%A8%E5%86%8C%E4%B9%8B%E5%89%8D%E7%94%A8comlilerplugin%E6%B3%A8%E5%86%8C%E4%BD%86%E4%B8%BA%E4%BA%86%E4%BF%9D%E9%99%A9%E8%B5%B7%E8%A7%81%E8%BF%98%E6%98%AF%E4%B8%A4%E7%A7%8D%E5%8A%9E%E6%B3%95%E9%83%BD%E5%86%99%E8%BF%99%E6%A0%B7%E8%83%BD%E5%BA%94%E4%BB%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A0webpack4%E7%89%88%E6%9C%AC%E8%AF%A6%E8%A7%81%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0\&#34;&gt;webpack4.0之后用compiler.hooks注册，之前用comliler.plugin注册，但为了保险起见，还是两种办法都写，这样能应付服务器无webpack4版本，详见：这篇文章&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%80%E5%90%8E%E6%89%A9%E5%B1%95%E7%AE%80%E5%8D%95%E7%9C%8B%E4%BA%86%E5%87%A0%E4%B8%AA%E6%8F%92%E4%BB%B6%E4%B9%8B%E5%90%8E%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E5%81%9A%E4%BA%9B%E5%85%B6%E4%BB%96%E7%9A%84%E4%BA%8B%E6%83%85%E6%AF%94%E5%A6%82%E5%88%A0%E9%99%A4consolelog-%E6%88%96%E8%80%85%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%88%90%E6%97%B6%E5%81%9A%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0cdn%E7%9A%84%E6%93%8D%E4%BD%9C%E9%A9%AC%E4%B8%8A%E5%8A%A8%E6%89%8B%E5%90%A7~\&#34;&gt;最后扩展：简单看了几个插件之后，是不是可以考虑做些其他的事情，比如删除console.log、或者构建完成时做一些文件上传cdn的操作，马上动手吧～&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644479995097.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;duan-xin-duan-lian-jie-huan-qi-app&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;短信短链接唤起APP&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;App内嵌h5混合开发&#34;,&#34;slug&#34;:&#34;-PSB0uA8b&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/-PSB0uA8b&#34;}],&#34;date&#34;:&#34;2022-02-10 15:59:08&#34;,&#34;dateFormat&#34;:&#34;2022-02-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;0 min read&#34;,&#34;time&#34;:0,&#34;words&#34;:0,&#34;minutes&#34;:0},&#34;description&#34;:&#34;\n...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;先说下为什么要获取-openid\&#34;&gt;先说下为什么要获取 openid?&lt;/h3&gt;\n&lt;p&gt;因为用户管理类接口可以通过openid可以获取用户的一些信息的.&lt;/p&gt;\n&lt;h3 id=\&#34;说到-openid-必须先说微信授权登录的过程\&#34;&gt;说到 openid 必须先说微信授权登录的过程&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644479416142.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;前端需要在进入路由的是beaforEach的时候，先去判断链接上有没有 openid&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;如果没有，就去跳转到服务端给的一个地址。如果有，就继续往下走（next())&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;这个时候服务端会往下面的链接（https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;amp;redirect_uri=REDIRECT_URI&amp;amp;response_type=code&amp;amp;scope=SCOPE&amp;amp;state=STATE#wechat_redirect来获取code）上跳转，去引导用户去点击授权，用户授权之后就会重定向到 redirect_uri（服务端的地址）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;利用 code 获取 openid 之后(服务端去做)，服务端会跳转到前端页面(带上openid)&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;下面作为了解：&lt;/p&gt;\n&lt;p&gt;微信授权使用的是 OAuth2.0授权方式。主要有以下简略的步骤：&lt;br&gt;\n第一步：用户同意授权，获取 code&lt;br&gt;\n　　第二步：通过 code获取网页授权access_token&lt;br&gt;\n　　第三步：刷新access_token（如果需要）&lt;br&gt;\n　　第四步：拉取用户信息(需scope为 snsapi_userinfo)&lt;/p&gt;\n&lt;h3 id=\&#34;下面来具体api表示下怎么获取的-code-和-openid-吧\&#34;&gt;下面来具体api表示下怎么获取的 code 和 openid 吧&lt;/h3&gt;\n&lt;h3 id=\&#34;一获取code\&#34;&gt;一：获取code:&lt;/h3&gt;\n&lt;p&gt;通过https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;amp;redirect_uri=REDIRECT_URI&amp;amp;response_type=code&amp;amp;scope=SCOPE&amp;amp;state=STATE#wechat_redirect来获取code&lt;br&gt;\n参数：&lt;br&gt;\nAPPID：应用唯一标识&lt;br&gt;\nredirect_uri：授权后重定向的回调链接地址，用户同意后，code 会自动添加到后面。（请使用urlEncode对链接进行处理 （$url = urlencode(&#39;&#39;)） ）&lt;br&gt;\nscope：是应用授权作用域 （一般有两种：一种是静默方式（snsapi_base); 一种是非静默方式（snsapi_userinfo），需要用户去手动同意才能获取用户信息）&lt;/p&gt;\n&lt;p&gt;微信中尤其提醒：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问&lt;/p&gt;\n&lt;p&gt;** code 是微信自动生成的。并且放在redirect_uri（重定向后的回调链接地址）后面,并且带上code和state参数&lt;/p&gt;\n&lt;p&gt;上面提到了 code。那么 code又是什么呢？&lt;br&gt;\ncode:作为换取 access_token的票据，每次用户授权带上的 code 都不一样。5分钟未被使用自动过期（过期的这里下面有讲）&lt;/p&gt;\n&lt;h3 id=\&#34;二然后授权成功之后-得到-code-就用-code-去获取access_token\&#34;&gt;二：然后授权成功之后。得到 code。就用 code 去获取access_token&lt;/h3&gt;\n&lt;p&gt;https://api.weixin.qq.com/sns/oauth2/access_token?appid=wx41cb8dbd827a16e9&amp;amp;secret=d4624c36b6795d1d99dcf0547af5443d&amp;amp;code=00137323023ab55775be09d6d8e75ffA&amp;amp;grant_type=authorization_code&lt;br&gt;\n参数说明：&lt;br&gt;\nappid：应用唯一标识&lt;br&gt;\ncode：上一步已经获取到了&lt;br&gt;\nsecret：应用密钥AppSecret，在微信开放平台提交应用审核通过后获得&lt;/p&gt;\n&lt;p&gt;正确的返回&lt;br&gt;\n&amp;quot;access_token&amp;quot;:&amp;quot;ACCESS_TOKEN&amp;quot;, // 接口调用凭证 &amp;quot;expires_in&amp;quot;:7200, // access_token接口调用凭证超时时间 &amp;quot;refresh_token&amp;quot;:&amp;quot;REFRESH_TOKEN&amp;quot;, // 用户刷新access_token &amp;quot;openid&amp;quot;:&amp;quot;OPENID&amp;quot;, // 授权用户唯一标识 &amp;quot;scope&amp;quot;:&amp;quot;SCOPE&amp;quot;, // 作用域 等&lt;/p&gt;\n&lt;h3 id=\&#34;三通过access_token-openid获取用户信息\&#34;&gt;三：通过access_token、openid获取用户信息&lt;/h3&gt;\n&lt;p&gt;https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;amp;openid=OPENID&lt;br&gt;\n就会得到用户的信息：&lt;br&gt;\n得到参数：&lt;br&gt;\nopenid：用户的唯一标识&lt;br&gt;\nnickname：用户昵称&lt;br&gt;\nsex： 男女&lt;br&gt;\n等。。。&lt;br&gt;\n特别注意：&lt;br&gt;\n1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）； 2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为； 3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。 建议将secret、用户数据（如access_token）放在App云端服务器，由云端中转接口调用请求。&lt;/p&gt;\n&lt;h3 id=\&#34;最后总结下详细的步骤\&#34;&gt;最后总结下详细的步骤：&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;1．用户关注微信公众账号。&lt;/li&gt;\n&lt;li&gt;2．微信公众账号提供用户请求授权页面URL。&lt;/li&gt;\n&lt;li&gt;3．用户点击授权页面URL，将向服务器发起请求&lt;/li&gt;\n&lt;li&gt;4．服务器询问用户是否同意授权给微信公众账号(scope为snsapi_base时无此步骤)&lt;/li&gt;\n&lt;li&gt;5．用户同意(scope为snsapi_base时无此步骤)&lt;/li&gt;\n&lt;li&gt;6．服务器将CODE通过回调传给微信公众账号&lt;/li&gt;\n&lt;li&gt;7．微信公众账号获得CODE&lt;/li&gt;\n&lt;li&gt;8．微信公众账号通过CODE向服务器请求Access Token&lt;/li&gt;\n&lt;li&gt;9．服务器返回Access Token和OpenID给微信公众账号&lt;/li&gt;\n&lt;li&gt;10．微信公众账号通过Access Token向服务器请求用户信息(scope为snsapi_base时无此步骤)&lt;/li&gt;\n&lt;li&gt;11．服务器将用户信息回送给微信公众账号(scope为snsapi_base时无此步骤)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;公众号链接(官网更权威)：&lt;br&gt;\nhttps://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html&lt;/p&gt;\n&lt;p&gt;https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;微信公众号获取openid等一系列流程&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;微信公众号开发&#34;,&#34;slug&#34;:&#34;UY3g_0Q2F&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/UY3g_0Q2F&#34;}],&#34;date&#34;:&#34;2022-02-08 20:49:25&#34;,&#34;dateFormat&#34;:&#34;2022-02-08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:285000,&#34;words&#34;:1239,&#34;minutes&#34;:5},&#34;description&#34;:&#34;先说下为什么要获取 openid?\n因为用户管理类接口可以通过openid可以获取用户的一些信息的.\n说到 openid 必须先说微信授权登录的过程\n\n\n\n前端需要在进入路由的是beaforEach的时候，先去判断链接上有没有 openid...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%88%E8%AF%B4%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%8E%B7%E5%8F%96-openid\&#34;&gt;先说下为什么要获取 openid?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%B4%E5%88%B0-openid-%E5%BF%85%E9%A1%BB%E5%85%88%E8%AF%B4%E5%BE%AE%E4%BF%A1%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E7%9A%84%E8%BF%87%E7%A8%8B\&#34;&gt;说到 openid 必须先说微信授权登录的过程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E9%9D%A2%E6%9D%A5%E5%85%B7%E4%BD%93api%E8%A1%A8%E7%A4%BA%E4%B8%8B%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E7%9A%84-code-%E5%92%8C-openid-%E5%90%A7\&#34;&gt;下面来具体api表示下怎么获取的 code 和 openid 吧&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80%E8%8E%B7%E5%8F%96code\&#34;&gt;一：获取code:&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C%E7%84%B6%E5%90%8E%E6%8E%88%E6%9D%83%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E-%E5%BE%97%E5%88%B0-code-%E5%B0%B1%E7%94%A8-code-%E5%8E%BB%E8%8E%B7%E5%8F%96access_token\&#34;&gt;二：然后授权成功之后。得到 code。就用 code 去获取access_token&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89%E9%80%9A%E8%BF%87access_token-openid%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF\&#34;&gt;三：通过access_token、openid获取用户信息&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93%E4%B8%8B%E8%AF%A6%E7%BB%86%E7%9A%84%E6%AD%A5%E9%AA%A4\&#34;&gt;最后总结下详细的步骤：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;自定义hooks\&#34;&gt;自定义hooks&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;function usePrevious(value) {\n  const ref = useRef();\n  useEffect(() =&amp;gt; {\n    ref.current = value;\n  });\n  return ref.current;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;使用\&#34;&gt;使用&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const Component = (props) =&amp;gt; {\n    const {valueA, valueB} = props\n    \n    const prevValue = usePrevious({valueA, valueB});\n    useEffect(() =&amp;gt; {\n        if(prevValue.valueA !== valueA) {\n           ...\n       }\n        if(prevValue.valueB !== valueB) {\n           ...\n        }\n    }, [valueA, valueB])\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;ru-he-bi-jiao-react-hooks-shang-de-jiu-zhi-he-xin-zhi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;如何比较 React Hooks 上的旧值和新值？&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;react&#34;,&#34;slug&#34;:&#34;N_eTPldB8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/N_eTPldB8&#34;}],&#34;date&#34;:&#34;2022-01-27 20:24:38&#34;,&#34;dateFormat&#34;:&#34;2022-01-27&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/ru-he-bi-jiao-react-hooks-shang-de-jiu-zhi-he-xin-zhi&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:16000,&#34;words&#34;:45,&#34;minutes&#34;:1},&#34;description&#34;:&#34;自定义hooks\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() =&amp;gt; {\n    ref.current = value;\n  });\n  r...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%AE%9A%E4%B9%89hooks\&#34;&gt;自定义hooks&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8\&#34;&gt;使用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;区别概览\&#34;&gt;区别概览&lt;/h3&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;-&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;useCallBack&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;useMemo&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;返回值&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;一个缓存的回调函数&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;一个缓存的值&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;参数&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;需要缓存的函数，依赖项&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;需要缓存的值(也可以是个计算然后再返回值的函数) ，依赖项&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;使用场景&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;父组件更新时，通过props传递给子组件的函数也会重新创建，然后这个时候使用 useCallBack 就可以缓存函数不使它重新创建&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;组件更新时，一些计算量很大的值也有可能被重新计算，这个时候就可以使用 useMemo 直接使用上一次缓存的值&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h3 id=\&#34;usecallback-具体示例\&#34;&gt;useCallBack 具体示例&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://codesandbox.io/s/usecallback-1w9f1?file=/src/App.jsx\&#34;&gt;codesanbox在线示例&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;import React, { useCallback, useEffect, useState } from &amp;quot;react&amp;quot;;\nimport &amp;quot;./styles.css&amp;quot;;\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  // 使用 useCallBack 缓存\n  const handleCountAddByCallBack = useCallback(() =&amp;gt; {\n    setCount((count) =&amp;gt; count + 1);\n  }, []);\n\n  // 不缓存，每次 count 更新时都会重新创建\n  const handleCountAdd = () =&amp;gt; {\n    setCount((count) =&amp;gt; count + 1);\n  };\n\n  return (\n    &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;\n      &amp;lt;h3&amp;gt;CountAddByChild1: {count}&amp;lt;/h3&amp;gt;\n      &amp;lt;Child1 addByCallBack={handleCountAddByCallBack} add={handleCountAdd} /&amp;gt;\n    &amp;lt;/div&amp;gt;\n  );\n}\n\nconst Child1 = React.memo(function (props) {\n  const { add, addByCallBack } = props;\n  \n  // 没有缓存，由于每次都创建，memo 认为两次地址都不同，属于不同的函数，所以会触发 useEffect\n  useEffect(() =&amp;gt; {\n    console.log(&amp;quot;Child1----addFcUpdate&amp;quot;, props);\n  }, [add]);\n\n  // 有缓存，memo 判定两次地址都相同，所以不触发 useEffect\n  useEffect(() =&amp;gt; {\n    console.log(&amp;quot;Child1----addByCallBackFcUpdate&amp;quot;, props);\n  }, [addByCallBack]);\n\n  return (\n    &amp;lt;div&amp;gt;\n      &amp;lt;button onClick={props.add}&amp;gt;+1&amp;lt;/button&amp;gt;\n      &amp;lt;br /&amp;gt;\n      &amp;lt;button onClick={props.addByCallBack}&amp;gt;+1(addByCallBack)&amp;lt;/button&amp;gt;\n    &amp;lt;/div&amp;gt;\n  );\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;usememo-示例\&#34;&gt;useMemo 示例&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://codesandbox.io/s/usememo-p9t7e?file=/src/App.jsx\&#34;&gt;codesandbox 在线示例&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;import { useState, useMemo } from &amp;quot;react&amp;quot;;\nimport &amp;quot;./styles.css&amp;quot;;\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n  const [total, setTotal] = useState(0);\n\n  // 没有使用 useMemo，即使是更新 total, countToString 也会重新计算\n  const countToString = (() =&amp;gt; {\n    console.log(&amp;quot;countToString 被调用&amp;quot;);\n    return count.toString();\n  })();\n\n  // 使用了 useMemo, 只有 total 改变，才会重新计算\n  const totalToStringByMemo = useMemo(() =&amp;gt; {\n    console.log(&amp;quot;totalToStringByMemo 被调用&amp;quot;);\n    return total + &amp;quot;&amp;quot;;\n  }, [total]);\n\n  return (\n    &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;\n      &amp;lt;h3&amp;gt;countToString: {countToString}&amp;lt;/h3&amp;gt;\n      &amp;lt;h3&amp;gt;countToString: {totalToStringByMemo}&amp;lt;/h3&amp;gt;\n      &amp;lt;button\n        onClick={() =&amp;gt; {\n          setCount((count) =&amp;gt; count + 1);\n        }}\n      &amp;gt;\n        Add Count\n      &amp;lt;/button&amp;gt;\n      &amp;lt;br /&amp;gt;\n      &amp;lt;button\n        onClick={() =&amp;gt; {\n          setTotal((total) =&amp;gt; total + 1);\n        }}\n      &amp;gt;\n        Add Total\n      &amp;lt;/button&amp;gt;\n    &amp;lt;/div&amp;gt;\n  );\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;小结\&#34;&gt;小结&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;共同作用：仅仅 依赖数据 发生变化, 才会重新计算结果，也就是起到缓存的作用&lt;/li&gt;\n&lt;li&gt;区别\n&lt;ul&gt;\n&lt;li&gt;useCallBack 针对可能重新创建的函数进行优化，使得函数被缓存，React.memo 认定两次地址是相同就可以避免子组件冗余的更新。&lt;/li&gt;\n&lt;li&gt;useMemo 针对不必要的计算进行优化，避免了当前组件中一些的冗余计算操作。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;转载自：https://www.jianshu.com/p/b8d27018ed22&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;usecallback-he-usememo-de-qu-bie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;useCallback 和 useMemo 的区别&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;react&#34;,&#34;slug&#34;:&#34;N_eTPldB8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/N_eTPldB8&#34;}],&#34;date&#34;:&#34;2022-01-11 11:32:58&#34;,&#34;dateFormat&#34;:&#34;2022-01-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/usecallback-he-usememo-de-qu-bie&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:176000,&#34;words&#34;:646,&#34;minutes&#34;:3},&#34;description&#34;:&#34;区别概览\n\n\n\n-\nuseCallBack\nuseMemo\n\n\n\n\n返回值\n一个缓存的回调函数\n一个缓存的值\n\n\n参数\n需要缓存的函数，依赖项\n需要缓存的值(也可以是个计算然后再返回值的函数) ，依赖项\n\n\n使用场景\n父组件更新时，通过pr...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%BA%E5%88%AB%E6%A6%82%E8%A7%88\&#34;&gt;区别概览&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#usecallback-%E5%85%B7%E4%BD%93%E7%A4%BA%E4%BE%8B\&#34;&gt;useCallBack 具体示例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#usememo-%E7%A4%BA%E4%BE%8B\&#34;&gt;useMemo 示例&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%8F%E7%BB%93\&#34;&gt;小结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;对象类型\&#34;&gt;对象类型&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;import React, { useState } from &#39;react&#39;;\n\nconst Index = ()=&amp;gt; {\n  const [obj, setObj] = useState({name:&amp;quot;zhangsan&amp;quot;});\n\n  return (\n    &amp;lt;&amp;gt;\n      &amp;lt;h2&amp;gt;{obj.name}---{obj.age}&amp;lt;/h2&amp;gt;\t  \n      &amp;lt;button onClick={()=&amp;gt; (\n\t\tsetObj({\n\t\t  ...obj,\n\t\t  age:18\n\t\t})\n\t  )}&amp;gt;change-obj&amp;lt;/button&amp;gt;\n    &amp;lt;/&amp;gt;\n  );\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;数组类型\&#34;&gt;数组类型&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;import React, { useState } from &#39;react&#39;;\n\nconst Index = ()=&amp;gt; {\n  const [arr, setArr] = useState([1,2,3]);\n\n  return (\n    &amp;lt;&amp;gt;\n\n      &amp;lt;h2&amp;gt;{arr}&amp;lt;/h2&amp;gt;\n      &amp;lt;button onClick={()=&amp;gt;(setArr(\n\t\tsetarr(()=&amp;gt; {\n\t\t  arr.push(4);\n\t\t  return [...arr]\n\t\t})&amp;gt;change-arr&amp;lt;/button&amp;gt;\n\n    &amp;lt;/&amp;gt;\n  );\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;shi-yong-react-hooks-geng-xin-dui-xiang-huo-shu-zu-de-zhi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;使用React Hooks更新对象或数组的值&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;react&#34;,&#34;slug&#34;:&#34;N_eTPldB8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/N_eTPldB8&#34;}],&#34;date&#34;:&#34;2022-01-07 21:58:55&#34;,&#34;dateFormat&#34;:&#34;2022-01-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/shi-yong-react-hooks-geng-xin-dui-xiang-huo-shu-zu-de-zhi&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:35000,&#34;words&#34;:98,&#34;minutes&#34;:1},&#34;description&#34;:&#34;对象类型\nimport React, { useState } from &#39;react&#39;;\n\nconst Index = ()=&amp;gt; {\n  const [obj, setObj] = useState({name:&amp;quot;zhan...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B\&#34;&gt;对象类型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B\&#34;&gt;数组类型&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;&lt;em&gt;用更合理的方式写 CSS 和 Sass&lt;/em&gt; 翻译自&lt;a href=\&#34;https://github.com/airbnb/css\&#34;&gt;Airbnb CSS / Sass Styleguide&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;术语\&#34;&gt;术语&lt;/h3&gt;\n&lt;h4 id=\&#34;规则声明\&#34;&gt;规则声明&lt;/h4&gt;\n&lt;p&gt;我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.listing {\n  font-size: 18px;\n  line-height: 1.2;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;选择器\&#34;&gt;选择器&lt;/h4&gt;\n&lt;p&gt;在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.my-element-class {\n  /* ... */\n}\n\n[aria-hidden] {\n  /* ... */\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;属性\&#34;&gt;属性&lt;/h4&gt;\n&lt;p&gt;最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;/* some selector */ {\n  background: #f1f1f1;\n  color: #333;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;css格式\&#34;&gt;CSS格式&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;使用 2 个空格作为缩进。&lt;/li&gt;\n&lt;li&gt;类名建议使用破折号代替驼峰法。如果你使用 BEM，也可以使用下划线（参见下面的 &lt;a href=\&#34;#oocss-and-bem\&#34;&gt;OOCSS 和 BEM&lt;/a&gt;）。&lt;/li&gt;\n&lt;li&gt;不要使用 ID 选择器。&lt;/li&gt;\n&lt;li&gt;在一个规则声明中应用了多个选择器时，每个选择器独占一行。&lt;/li&gt;\n&lt;li&gt;在规则声明的左大括号 { 前加上一个空格。&lt;/li&gt;\n&lt;li&gt;在属性的冒号 : 后面加上一个空格，前面不加空格。&lt;/li&gt;\n&lt;li&gt;规则声明的右大括号 } 独占一行。&lt;/li&gt;\n&lt;li&gt;规则声明之间用空行分隔开。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;bad\&#34;&gt;Bad&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.avatar{\n    border-radius:50%;\n    border:2px solid white; }\n.no, .nope, .not_good {\n    // ...\n}\n#lol-no {\n  // ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;good\&#34;&gt;Good&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.avatar {\n  border-radius: 50%;\n  border: 2px solid white;\n}\n\n.one,\n.selector,\n.per-line {\n  // ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;注释\&#34;&gt;注释&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;建议使用行注释 (在 Sass 中是 //) 代替块注释。&lt;/li&gt;\n&lt;li&gt;建议注释独占一行。避免行末注释。&lt;/li&gt;\n&lt;li&gt;给没有自注释的代码写上详细说明，比如：&lt;br&gt;\n为什么用到了 z-index&lt;br&gt;\n兼容性处理或者针对特定浏览器的 hack&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;id-选择器\&#34;&gt;ID 选择器&lt;/h3&gt;\n&lt;p&gt;在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高优先级，而且 ID 选择器是不可重用的。&lt;/p&gt;\n&lt;p&gt;想要了解关于这个主题的更多内容，参见 &lt;a href=\&#34;https://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/\&#34;&gt;CSS Wizardry&lt;/a&gt; 的文章，文章中有关于如何处理优先级的内容。&lt;/p&gt;\n&lt;h3 id=\&#34;javascript-钩子\&#34;&gt;JavaScript 钩子&lt;/h3&gt;\n&lt;p&gt;避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。&lt;/p&gt;\n&lt;p&gt;我们推荐在创建用于特定 JavaScript 的类名时，添加 .js- 前缀：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-html\&#34;&gt;&amp;lt;button class=&amp;quot;btn btn-primary js-request-to-book&amp;quot;&amp;gt;Request to Book&amp;lt;/button&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;边框\&#34;&gt;边框&lt;/h3&gt;\n&lt;p&gt;在定义无边框样式时，使用 0 代替 none。&lt;/p&gt;\n&lt;h4 id=\&#34;bad-2\&#34;&gt;Bad&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.foo {\n  border: none;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;good-2\&#34;&gt;Good&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.foo {\n  border: 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;sass\&#34;&gt;Sass&lt;/h3&gt;\n&lt;p&gt;语法&lt;br&gt;\n使用 .scss 的语法，不使用 .sass 原本的语法。&lt;br&gt;\nCSS 和 @include 声明按照以下逻辑排序（参见下文）&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-html\&#34;&gt;&amp;lt;a name=&amp;quot;ordering-of-property-declarations&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;属性声明的排序\&#34;&gt;属性声明的排序&lt;/h3&gt;\n&lt;h4 id=\&#34;属性声明\&#34;&gt;属性声明&lt;/h4&gt;\n&lt;p&gt;首先列出除去 @include 和嵌套选择器之外的所有属性声明。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;.btn-green { background: green; font-weight: bold; // ... }&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;include-声明\&#34;&gt;@include 声明&lt;/h4&gt;\n&lt;p&gt;紧随后面的是 @include，这样可以使得整个选择器的可读性更高。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;.btn-green { background: green; font-weight: bold; @include transition(background 0.5s ease); // ... }&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;嵌套选择器\&#34;&gt;嵌套选择器&lt;/h4&gt;\n&lt;p&gt;_如果有必要_用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。&lt;/p&gt;\n&lt;p&gt;` .btn { background: green; font-weight: bold; @include transition(background 0.5s ease);&lt;/p&gt;\n&lt;p&gt;.icon { margin-right: 10px; } } `&lt;/p&gt;\n&lt;h3 id=\&#34;变量\&#34;&gt;变量&lt;/h3&gt;\n&lt;p&gt;变量名应使用破折号（例如 $my-variable）代替 camelCased 和 snake_cased 风格。对于仅用在当前文件的变量，可以在变量名之前添加下划线前缀（例如 $_my-variable）。&lt;/p&gt;\n&lt;h3 id=\&#34;mixins\&#34;&gt;Mixins&lt;/h3&gt;\n&lt;p&gt;为了让代码遵循 DRY 原则（Don&#39;t Repeat Yourself）、增强清晰性或抽象化复杂性，应该使用 mixin，这与那些命名良好的函数的作用是异曲同工的。虽然 mixin 可以不接收参数，但要注意，假如你不压缩负载（比如通过 gzip），这样会导致最终的样式包含不必要的代码重复。&lt;/p&gt;\n&lt;h3 id=\&#34;扩展指令\&#34;&gt;扩展指令&lt;/h3&gt;\n&lt;p&gt;应避免使用 @extend 指令，因为它并不直观，而且具有潜在风险，特别是用在嵌套选择器的时候。即便是在顶层占位符选择器使用扩展，如果选择器的顺序最终会改变，也可能会导致问题。（比如，如果它们存在于其他文件，而加载顺序发生了变化）。其实，使用 @extend 所获得的大部分优化效果，gzip 压缩已经帮助你做到了，因此你只需要通过 mixin 让样式表更符合 DRY 原则就足够了。&lt;/p&gt;\n&lt;h3 id=\&#34;嵌套选择器-2\&#34;&gt;嵌套选择器&lt;/h3&gt;\n&lt;p&gt;请不要让嵌套选择器的深度超过 3 层！&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sass\&#34;&gt;.page-container {\n  .content {\n    .profile {\n      // STOP!\n    }\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当遇到以上情况的时候，你也许是这样写 CSS 的：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;与 HTML 强耦合的（也是脆弱的）&lt;em&gt;—或者—&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;过于具体（强大）&lt;em&gt;—或者—&lt;/em&gt;&lt;/li&gt;\n&lt;li&gt;没有重用&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h5 id=\&#34;再说一遍-永远不要嵌套-id-选择器-永远不要嵌套-id-选择器-永远不要嵌套-id-选择器\&#34;&gt;再说一遍: 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！&lt;/h5&gt;\n&lt;p&gt;如果你始终坚持要使用 ID 选择器（劝你三思），那也不应该嵌套它们。如果你正打算这么做，你需要先重新检查你的标签，或者指明原因。如果你想要写出风格良好的 HTML 和 CSS，你是不应该这样做的。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;airbnb-css-sass-gui-fan-zhi-nan&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Airbnb CSS / Sass 规范指南&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;代码规范&#34;,&#34;slug&#34;:&#34;wSYaCu5wB&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/wSYaCu5wB&#34;}],&#34;date&#34;:&#34;2022-01-05 16:18:02&#34;,&#34;dateFormat&#34;:&#34;2022-01-05&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/airbnb-css-sass-gui-fan-zhi-nan&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:315000,&#34;words&#34;:1402,&#34;minutes&#34;:6},&#34;description&#34;:&#34;\n用更合理的方式写 CSS 和 Sass 翻译自Airbnb CSS / Sass Styleguide\n\n术语\n规则声明\n我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子：\n.listing {\n  font-size:...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AF%E8%AF%AD\&#34;&gt;术语&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%84%E5%88%99%E5%A3%B0%E6%98%8E\&#34;&gt;规则声明&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%89%E6%8B%A9%E5%99%A8\&#34;&gt;选择器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B1%9E%E6%80%A7\&#34;&gt;属性&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#css%E6%A0%BC%E5%BC%8F\&#34;&gt;CSS格式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#bad\&#34;&gt;Bad&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#good\&#34;&gt;Good&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E9%87%8A\&#34;&gt;注释&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#id-%E9%80%89%E6%8B%A9%E5%99%A8\&#34;&gt;ID 选择器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#javascript-%E9%92%A9%E5%AD%90\&#34;&gt;JavaScript 钩子&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BE%B9%E6%A1%86\&#34;&gt;边框&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#bad-2\&#34;&gt;Bad&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#good-2\&#34;&gt;Good&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#sass\&#34;&gt;Sass&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8E%92%E5%BA%8F\&#34;&gt;属性声明的排序&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E\&#34;&gt;属性声明&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#include-%E5%A3%B0%E6%98%8E\&#34;&gt;@include 声明&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B5%8C%E5%A5%97%E9%80%89%E6%8B%A9%E5%99%A8\&#34;&gt;嵌套选择器&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%98%E9%87%8F\&#34;&gt;变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#mixins\&#34;&gt;Mixins&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%A9%E5%B1%95%E6%8C%87%E4%BB%A4\&#34;&gt;扩展指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B5%8C%E5%A5%97%E9%80%89%E6%8B%A9%E5%99%A8-2\&#34;&gt;嵌套选择器&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%8D%E8%AF%B4%E4%B8%80%E9%81%8D-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%B5%8C%E5%A5%97-id-%E9%80%89%E6%8B%A9%E5%99%A8-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%B5%8C%E5%A5%97-id-%E9%80%89%E6%8B%A9%E5%99%A8-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%B5%8C%E5%A5%97-id-%E9%80%89%E6%8B%A9%E5%99%A8\&#34;&gt;再说一遍: 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;ul&gt;\n&lt;li&gt;目录 全小写中划线&lt;/li&gt;\n&lt;li&gt;文件 全小写中划线&lt;/li&gt;\n&lt;li&gt;类名 大驼峰&lt;/li&gt;\n&lt;li&gt;变量 小驼峰&lt;/li&gt;\n&lt;li&gt;常量 全大写 下划线风格&lt;/li&gt;\n&lt;li&gt;特殊变量&lt;/li&gt;\n&lt;li&gt;css类名 小写中划线&lt;/li&gt;\n&lt;li&gt;单词拼音不允许&lt;/li&gt;\n&lt;li&gt;复杂函数和公用函数必须加注释&lt;/li&gt;\n&lt;li&gt;函数的参数最多不能超过三个&lt;/li&gt;\n&lt;li&gt;url 全小写 中划线&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;qian-duan-chang-yong-de-ming-ming-gui-fan&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;前端常用的命名规范&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;命名规范&#34;,&#34;slug&#34;:&#34;fyCFn2Pdt&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/fyCFn2Pdt&#34;}],&#34;date&#34;:&#34;2021-12-20 19:20:48&#34;,&#34;dateFormat&#34;:&#34;2021-12-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/qian-duan-chang-yong-de-ming-ming-gui-fan&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:18000,&#34;words&#34;:89,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n目录 全小写中划线\n文件 全小写中划线\n类名 大驼峰\n变量 小驼峰\n常量 全大写 下划线风格\n特殊变量\ncss类名 小写中划线\n单词拼音不允许\n复杂函数和公用函数必须加注释\n函数的参数最多不能超过三个\nurl 全小写 中划线\n\n...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;遇到问题时的解决方法及使用注意事项：&lt;/p&gt;\n&lt;p&gt;1、下拉刷新会导致瀑布流顺序错乱，重新new一下瀑布流即可。&lt;/p&gt;\n&lt;p&gt;2、图片宽高必须要让服务端返，前端去获取数据太多会导致性能非常慢。&lt;/p&gt;\n&lt;p&gt;3、dom加载时获取小程序的某个dom的宽度（列宽）为空，放在wx.nextTick中即可。还获取不到，就需要看自己要获取的dom是否已加载。&lt;/p&gt;\n&lt;p&gt;4、此代码抗揍，如果出问题先从自身找问题，再仔细阅读一遍此代码。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;class Waterfall {\n  constructor(options) {\n    this.initWaterfall(options);\n  }\n    /**\n   * 初始化瀑布流\n   * @param {Object} options\n   * @param {Array&amp;lt;Object&amp;gt;} options.columns {width} - 此参数主要定义每列的宽度\n   */\n  initWaterfall(options) {\n    this.columns = options.columns;\n    this.formatedData = [];\n    for (let column of options.columns) {\n      this.formatedData.push({\n        width: column.width,\n        height: 0\n      });\n    }\n  }\n  imageUrlFeild = &#39;imageUrl&#39;\n \n  /**\n   * 格式化从数据中获取图片url的方法\n   * @param {Function | String | Number} fn - 若为函数，则需要返回瀑布流每项数据对应的图片字段\n   */\n \n  formatGetImageUrlMethod(fn) {\n    this.imageUrlFeild = typeof fn === &#39;function&#39; ? fn() : fn\n  }\n \n  /**\n   * 向瀑布流中填充数据\n   * @param {Object}  resource - 单个瀑布流项的数据源\n   */\n  getResourceInfo(resource) {\n    const _self = this\n    return new Promise(resolve =&amp;gt; {\n      if (resource[_self.imageUrlFeild]) {\n        // getImageInfo方法在小程序中使用，h5中暂未测试，不过一般都是让服务端直接返回图片宽高，所以这个方法一般用不到，如果需要用到的话，必须加一层loading阻止用户操作\n        wx.getImageInfo({\n          src: resource[_self.imageUrlFeild],\n          success(res) {\n            resolve(res)\n          },\n          fail() {\n            resolve()\n          }\n        })\n      } else {\n        resolve()\n      }\n    })\n  }\n \n  /**\n   * 向瀑布流中补充数据\n   * @param {Boolean} extraVal 瀑布流的卡片中图片之外的内容\n   * @param {Array&amp;lt;resource&amp;gt;}  resources\n   */\n \n  async addResources(resources, extraVal) {\n    // let promiseArray = []\n    let newResourcesArray = Array.apply(null, Array(this.columns.length)).map(\n      _ =&amp;gt; []\n    )\n    for (let resource of resources) {\n      // promiseArray.push(this.getResourceInfo(resource))\n      // let imageInfo\n      // imageInfo = await this.getResourceInfo(resource)\n      const width = Number(resource.width) || 100;\n      const height = Number(resource.height) || 100;\n      // 获取最短列的索引\n      const index = this.getShortestColumn();\n      // 卡片宽度\n      const imageWidth = this.formatedData[index].width;\n      // 附加的卡片高度在这里是写死的，每个项目会有不同高度\n      const extraHeight = extraVal ? extraVal : 0;\n      // 获取卡片高度\n      const cardHeight = imageWidth / (width / height) + extraHeight;\n      // 当前列总高度\n      this.formatedData[index].height += cardHeight;\n      // 返回卡片高度\n      resource.cardHeight = cardHeight;\n      // 返回图片高度\n      resource.computedHeight = cardHeight - extraVal;\n      // 返回当前列的数组\n      newResourcesArray[index].push(resource);\n    }\n    return newResourcesArray\n  }\n \n  /**\n   * 最重要的地方\n   * 获取当前数据中填充最短的列\n   * 返回最短列的索引\n   */\n  getShortestColumn() {\n    let minHeight = Infinity\n    let minHeightColumnIndex = 0\n    for (let index = this.formatedData.length - 1; index &amp;gt; -1; index--) {\n      //从后往前遍历，防止每列的高度相同的情况\n      const height = this.formatedData[index].height\n      if (height &amp;lt;= minHeight) {\n        minHeightColumnIndex = index\n        minHeight = height\n      }\n    }\n    return minHeightColumnIndex\n  }\n}\n \nexport default Waterfall;\n \n \n// 例：双列瀑布流\nlet newList = new Waterfall({\n      columns: [\n        {\n          width: 列宽\n        },\n        {\n          width: 列宽\n        }\n      ]\n    });\nnewList.addResources(lists, 卡片内除图片的额外高度).then(res =&amp;gt; {});\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;pu-bu-liu-ji-suan-js-yuan-ma&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;瀑布流计算js源码&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;瀑布流&#34;,&#34;slug&#34;:&#34;sahncmfum&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/sahncmfum&#34;}],&#34;date&#34;:&#34;2021-11-24 22:38:44&#34;,&#34;dateFormat&#34;:&#34;2021-11-24&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/pu-bu-liu-ji-suan-js-yuan-ma&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:178000,&#34;words&#34;:677,&#34;minutes&#34;:3},&#34;description&#34;:&#34;遇到问题时的解决方法及使用注意事项：\n1、下拉刷新会导致瀑布流顺序错乱，重新new一下瀑布流即可。\n2、图片宽高必须要让服务端返，前端去获取数据太多会导致性能非常慢。\n3、dom加载时获取小程序的某个dom的宽度（列宽）为空，放在wx.ne...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;1-直播组件优先开通实时音频和视频管理后台申请对应的证书\&#34;&gt;1、直播组件优先开通实时音频和视频（管理后台），申请对应的证书&lt;/h3&gt;\n&lt;h3 id=\&#34;2-直播组件需要做系统权限验证麦克风和相机引导用户打开权限不然部分手机加载失败-insertliveplayerfailaccess-denied-因为权限有三个状态undefined-denied-authorizedauthorized代表系统权限已开\&#34;&gt;2、直播组件需要做【系统】权限验证，（麦克风和相机）,引导用户打开权限，不然部分手机加载失败（ insertLivePlayer:fail:access denied） 因为权限有三个状态(undefined、denied、authorized)，authorized代表系统权限已开&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;export const getSystemInfo = (keys: Tkey[], content = &#39;&#39;) =&amp;gt; {\n  return new Promise((resolve) =&amp;gt; {\n    const systemInfo = wx.getAppAuthorizeSetting();\n    console.log(&#39;system&#39;, systemInfo);\n    if (!systemInfo) {\n      return resolve({ code: -1, msg: &#39;获取系统权限失败~&#39; });\n    }\n    keys.forEach((item) =&amp;gt; {\n      if (systemInfo[item] !== &#39;authorized&#39;) {\n        Taro.showModal({\n          content,\n          success: (res) =&amp;gt; {\n            if (res.confirm) {\n              wx.openAppAuthorizeSetting({\n                success: () =&amp;gt; {\n                  return resolve({ code: 100, msg: &#39;打开系统授权页成功~&#39; });\n                },\n                fail: () =&amp;gt; {\n                  return resolve({ code: 101, msg: &#39;打开系统授权页失败~&#39; });\n                }\n              });\n            } else {\n              return resolve({ code: 403, msg: &#39;用户点击取消~&#39; });\n            }\n          }\n        });\n        return resolve({ code: 401, msg: &#39;权限没打开~&#39; });\n      }\n    });\n    return resolve({ code: 0, msg: &#39;用户已开通对应权限~&#39; });\n  });\n};\n \n// 获取系统权限\n      const res: any = await getSystemInfo(\n        [&#39;cameraAuthorized&#39;, &#39;microphoneAuthorized&#39;],\n        &#39;检测到您没有打开麦克风和相机权限，部分功能将没法使用~&#39;\n      );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;3-直播组件同层渲染在全屏下失效需要单独处理全屏做coverviewcoverimage做原生覆盖能力处理不是全屏就同层渲染全屏处理时候顶层容器和直接子节点需要设置-visiblityvisiblepositionrelativez-index99999-必须得处理不然android-的coverview覆盖不了原生直播组件\&#34;&gt;3、直播组件同层渲染在全屏下失效，需要单独处理，全屏做CoverView\\CoverImage做原生覆盖能力处理，不是全屏就同层渲染，全屏处理时候顶层容器和直接子节点需要设置 visiblity:visible;position:relative;z-index:99999; 必须得处理，不然android 的CoverView覆盖不了原生直播组件。&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;.cover-main{\n    position: absolute;\n    visibility: visible;\n    z-index: 999999;\n}\n \n&amp;lt;CoverView className={style[&#39;cover-main&#39;]}&amp;gt;\n                &amp;lt;CoverView className={style[&#39;cover-main&#39;]}&amp;gt;\n                  &amp;lt;CoverView className={style[&#39;live-control&#39;]} onClick={showTips}&amp;gt;&amp;lt;/CoverView&amp;gt;\n \n        {fullScreenFlag &amp;amp;&amp;amp; (\n        &amp;lt;&amp;gt;\n            {/*广告*/}\n            &amp;lt;Curtain /&amp;gt;\n\n            {/* 封面*/}\n            {startStatus === false ? (\n            &amp;lt;CoverView className={style.cannot_see}&amp;gt;\n                &amp;lt;CoverImage className={style.cannot_see_img} src={readyImg}&amp;gt;&amp;lt;/CoverImage&amp;gt;\n            &amp;lt;/CoverView&amp;gt;\n            ) : teachStatus === false ? (\n            &amp;lt;CoverView className={style.cannot_see}&amp;gt;\n                &amp;lt;CoverImage className={style.cannot_see_img} src={outImg}&amp;gt;&amp;lt;/CoverImage&amp;gt;\n            &amp;lt;/CoverView&amp;gt;\n            ) : null}\n\n            {/* 倒计时*/}\n            {time &amp;gt;= 1800 ? &amp;lt;CountDown time={time} /&amp;gt; : null}\n        &amp;lt;/&amp;gt;\n        )}\n\n        {/*控制*/}\n        &amp;lt;CoverView\n        className={`${style.control} ${tips ? style[&#39;up-ani&#39;] : style[&#39;down-ani&#39;]}`}\n        &amp;gt;\n        &amp;lt;CoverView className={style.info}&amp;gt;\n            &amp;lt;CoverView&amp;gt;直播&amp;lt;/CoverView&amp;gt;\n        &amp;lt;/CoverView&amp;gt;\n        &amp;lt;CoverView className={style[&#39;full-screen&#39;]} onClick={handleFullScreen}&amp;gt;\n            &amp;lt;CoverImage\n            className={style.icon}\n            src={fullScreenFlag ? tuichuquanping : quanping}\n            &amp;gt;&amp;lt;/CoverImage&amp;gt;\n            &amp;lt;CoverView&amp;gt;{fullScreenFlag ? &#39;小屏播放&#39; : &#39;全屏播放&#39;}&amp;lt;/CoverView&amp;gt;\n        &amp;lt;/CoverView&amp;gt;\n        &amp;lt;/CoverView&amp;gt;\n    &amp;lt;/CoverView&amp;gt;\n    &amp;lt;/CoverView&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;taro-xiao-cheng-xu-zhi-bo-zu-jian-liveplayer-zhu-yi-shi-xiang&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Taro 小程序直播组件 LivePlayer 注意事项&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;小程序开发&#34;,&#34;slug&#34;:&#34;MyzxkxARV&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/MyzxkxARV&#34;}],&#34;date&#34;:&#34;2021-11-15 21:49:16&#34;,&#34;dateFormat&#34;:&#34;2021-11-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/taro-xiao-cheng-xu-zhi-bo-zu-jian-liveplayer-zhu-yi-shi-xiang&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:153000,&#34;words&#34;:528,&#34;minutes&#34;:3},&#34;description&#34;:&#34;1、直播组件优先开通实时音频和视频（管理后台），申请对应的证书\n2、直播组件需要做【系统】权限验证，（麦克风和相机）,引导用户打开权限，不然部分手机加载失败（ insertLivePlayer:fail:access denied） 因为权...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E7%9B%B4%E6%92%AD%E7%BB%84%E4%BB%B6%E4%BC%98%E5%85%88%E5%BC%80%E9%80%9A%E5%AE%9E%E6%97%B6%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E7%94%B3%E8%AF%B7%E5%AF%B9%E5%BA%94%E7%9A%84%E8%AF%81%E4%B9%A6\&#34;&gt;1、直播组件优先开通实时音频和视频（管理后台），申请对应的证书&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E7%9B%B4%E6%92%AD%E7%BB%84%E4%BB%B6%E9%9C%80%E8%A6%81%E5%81%9A%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E9%BA%A6%E5%85%8B%E9%A3%8E%E5%92%8C%E7%9B%B8%E6%9C%BA%E5%BC%95%E5%AF%BC%E7%94%A8%E6%88%B7%E6%89%93%E5%BC%80%E6%9D%83%E9%99%90%E4%B8%8D%E7%84%B6%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5-insertliveplayerfailaccess-denied-%E5%9B%A0%E4%B8%BA%E6%9D%83%E9%99%90%E6%9C%89%E4%B8%89%E4%B8%AA%E7%8A%B6%E6%80%81undefined-denied-authorizedauthorized%E4%BB%A3%E8%A1%A8%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E5%B7%B2%E5%BC%80\&#34;&gt;2、直播组件需要做【系统】权限验证，（麦克风和相机）,引导用户打开权限，不然部分手机加载失败（ insertLivePlayer:fail:access denied） 因为权限有三个状态(undefined、denied、authorized)，authorized代表系统权限已开&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E7%9B%B4%E6%92%AD%E7%BB%84%E4%BB%B6%E5%90%8C%E5%B1%82%E6%B8%B2%E6%9F%93%E5%9C%A8%E5%85%A8%E5%B1%8F%E4%B8%8B%E5%A4%B1%E6%95%88%E9%9C%80%E8%A6%81%E5%8D%95%E7%8B%AC%E5%A4%84%E7%90%86%E5%85%A8%E5%B1%8F%E5%81%9Acoverviewcoverimage%E5%81%9A%E5%8E%9F%E7%94%9F%E8%A6%86%E7%9B%96%E8%83%BD%E5%8A%9B%E5%A4%84%E7%90%86%E4%B8%8D%E6%98%AF%E5%85%A8%E5%B1%8F%E5%B0%B1%E5%90%8C%E5%B1%82%E6%B8%B2%E6%9F%93%E5%85%A8%E5%B1%8F%E5%A4%84%E7%90%86%E6%97%B6%E5%80%99%E9%A1%B6%E5%B1%82%E5%AE%B9%E5%99%A8%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%AD%90%E8%8A%82%E7%82%B9%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE-visiblityvisiblepositionrelativez-index99999-%E5%BF%85%E9%A1%BB%E5%BE%97%E5%A4%84%E7%90%86%E4%B8%8D%E7%84%B6android-%E7%9A%84coverview%E8%A6%86%E7%9B%96%E4%B8%8D%E4%BA%86%E5%8E%9F%E7%94%9F%E7%9B%B4%E6%92%AD%E7%BB%84%E4%BB%B6\&#34;&gt;3、直播组件同层渲染在全屏下失效，需要单独处理，全屏做CoverView\\CoverImage做原生覆盖能力处理，不是全屏就同层渲染，全屏处理时候顶层容器和直接子节点需要设置 visiblity:visible;position:relative;z-index:99999; 必须得处理，不然android 的CoverView覆盖不了原生直播组件。&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644219568486.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n上面是一个使用脚手架来初始化项目的典型例子。&lt;br&gt;\n随着前端工程化的理念不断深入，越来越多的人选择使用脚手架来从零到一搭建自己的项目。其中大家最熟悉的就是create-react-app和vue-cli，它们可以帮助我们初始化配置、生成项目结构、自动安装依赖，最后我们一行指令即可运行项目开始开发，或者进行项目构建（build）。&lt;br&gt;\n这些脚手架提供的都是普遍意义上的最佳实践，但是我在开发中发现，随着业务的不断发展，必然会出现需要针对业务开发的实际情况来进行调整。例如：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;项目架构的配置&lt;br&gt;\na. webpack/gulp的配置&lt;br&gt;\nⅰ. style/less/sass的选择和处理配置。&lt;br&gt;\nⅱ. Typescript和JavaScript的loader和babel的配置，比如babel-loader和tsc。&lt;br&gt;\nⅲ. 图片的配置，比如需要file-loader或者url-loader。&lt;br&gt;\nⅳ. 静态资源的配置。&lt;br&gt;\nⅴ. 企业内部，真对于某些特定功能的webpack-loader/webpack-plugin，比如打包完图片上传。&lt;br&gt;\nb. 是否内置一些第三方框架供上手使用，比如Element-UI，Antd等。&lt;br&gt;\nc. 项目的路由的设计和配置。&lt;br&gt;\nd. 项目目录结构的设计和配置。&lt;br&gt;\ne. 项目通用功能的有关代码，比如登陆和欢迎页等。&lt;br&gt;\nf.通过调整插件与配置实现 Webpack 打包性能优化&lt;br&gt;\ng.针对生产环境做的单独处理&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;项目开发中的配置&lt;br&gt;\na. eslint。&lt;br&gt;\nb. style-lint。&lt;br&gt;\nc. prettier。&lt;br&gt;\nd. 单元测试jest或者其他单元测试框架。&lt;br&gt;\ne. 项目文档的自动生成，比如docz。&lt;br&gt;\nf. git相关的，比如git提交的校验，生成changelog&lt;br&gt;\ng. npm相关，除非是开发npm包，否则npm相关的不是那么重要&lt;br&gt;\nh. 与开发有关的工具，比如打包构建结果的包分析、比如相似代码自动生成&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;项目上线脚本，这个应该是可选项？更优的方法应该是使用内部的例如发布平台之类的工具完成，或者通过jekins或者gitlab-ci进行自动化发布，回滚等操作。上线发布回滚的动作可以完全交给非开发人员完成。&lt;br&gt;\na. 比如由nodejs编写的上线脚本，或者是用于上线的shell脚本。&lt;br&gt;\nb. gitlab-ci的配置文件&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;……&lt;br&gt;\n总而言之，随着业务发展，我们往往会沉淀出一套更“个性化”的业务方案。这时候我们最直接的做法就是开发出一个该方案的脚手架来，以便今后能复用这些最佳实践与方案。&lt;br&gt;\n那么就需要使用一个工具来帮我们做这些处理，我们使用的就是yoman。&lt;a href=\&#34;https://yeoman.io/\&#34;&gt;官网地址&lt;/a&gt;&lt;br&gt;\n我们可以使用yeoman和yeoman的generator来更加便捷实现我们的脚手架，可以说基本是零成本。&lt;br&gt;\n先说说Yeoman是什么，它想做什么？&lt;br&gt;\nYeamon帮助你快速的开展一个项目工程，提供最佳实践和工具，来让你保持高效率编码。&lt;/p&gt;\n&lt;p&gt;他们自己提供了一个构建生态系统，主要通过‘yo’这个命令来构建一个完整的项目或者项目的一部分。&lt;/p&gt;\n&lt;p&gt;通过官方的生成器，他们建立了一个Yeoman的工作流，这个流是由一个强大的,固定的客户端组建，包含工具和框架帮助开发者快速建立牛逼的web应用。他们尽量提供了开发者所需的东西。比如先下载对应模版项目，然后下载模版项目中的package.json中的包&lt;/p&gt;\n&lt;p&gt;作为良好文档和深入思考构建过程的思想者，Yeoman包含了检测（静态检测）、测试以及压缩等等一系列工具，让开发者能够更加专注于思考解决方案。&lt;/p&gt;\n&lt;h3 id=\&#34;如何使用\&#34;&gt;如何使用：&lt;/h3&gt;\n&lt;p&gt;1、npm install -g yo //权限不够，请加上 sudo，一般来说mac都需要。&lt;br&gt;\n安装完成之后，你就拥有了1个命令 -- yo 可以选择自定义的，也可以搜索你想要的现成的，这里我们选择自己的。 官网提供的地址：http://yeoman.io/generators/&lt;br&gt;\n那我们开始编写一个自己的generators。&lt;br&gt;\n2、开发自己的generator&lt;br&gt;\n创建项目&lt;br&gt;\n全局安装generator-generator，然后使用创建项目，根据提示输出我们的generator项目的名字，yeoman规定项目名字必须以generator开头，所以我们可以选择generator-xxx作为我们的项目名&lt;br&gt;\nnpm i -g generator-generator&lt;br&gt;\nyo generator&lt;br&gt;\n创建好项目之后，我们可以发现已经自动为我们配置好了eslint，jest，husky&lt;/p&gt;\n&lt;p&gt;我们主要需要修改的代码位于generators/app内&lt;br&gt;\n● index.js定义了我们使用此generator时的一些操作配置项&lt;br&gt;\n● templates内存放的是要生成的项目的项目模板，项目模板也可以放在git上，然后通过download-git-repo下载到本地&lt;br&gt;\n验证我们创建的项目&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;在当前项目执行npm link使其被链接到全局&lt;/li&gt;\n&lt;li&gt;然后找一个目录，终端执行yo，此时便可以发现我们的generator已经出现在了选择列表中。然后选择我们的generator运行即可。等待完成，会发现成功的创建了一个叫做dummyfile.txt的文件夹。&lt;br&gt;\ngenerators/app/index.js&lt;br&gt;\n初始化的文件如下。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code&gt;&amp;quot;use strict&amp;quot;;\nconst Generator = require(&amp;quot;yeoman-generator&amp;quot;);\nconst chalk = require(&amp;quot;chalk&amp;quot;);\nconst yosay = require(&amp;quot;yosay&amp;quot;);\n\nmodule.exports = class extends Generator {\n  prompting() {\n    // Have Yeoman greet the user.\n    this.log(\n      yosay(\n        `Welcome to the fantastic ${chalk.red(&amp;quot;generator-rc-op&amp;quot;)} generator!`\n      )\n    );\n\n    const prompts = [\n      {\n        type: &amp;quot;confirm&amp;quot;,\n        name: &amp;quot;someAnswer&amp;quot;,\n        message: &amp;quot;Would you like to enable this option?&amp;quot;,\n        default: true\n      }\n    ];\n\n    return this.prompt(prompts).then(props =&amp;gt; {\n      // To access props later use this.props.someAnswer;\n      this.props = props;\n    });\n  }\n\n  writing() {\n    this.fs.copy(\n      this.templatePath(&amp;quot;dummyfile.txt&amp;quot;),\n      this.destinationPath(&amp;quot;dummyfile.txt&amp;quot;)\n    );\n  }\n\n  install() {\n    this.installDependencies();\n  }\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从文件的内容可以看出主要操作是暴露出一个继承自Generator的类，在类的内部定义了部分生命周期方法，供yoeman在适当的时候调用。我们只需要完善这些方法就可以了。&lt;/p&gt;\n&lt;h3 id=\&#34;yeoman提供的生命周期如下\&#34;&gt;yeoman提供的生命周期如下：&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;initializing：初始化必要的依赖，或者比如检测新版本&lt;/li&gt;\n&lt;li&gt;prompting：用来处理终端的交互&lt;/li&gt;\n&lt;li&gt;default：这里指的是自己自定义的方法，而不是名为default的方法，自己定义的方法如果不想被调用，那么需要确保方法名以_为开头。&lt;/li&gt;\n&lt;li&gt;writing：将经过ejs模板渲染后的内容写入文件系统。&lt;/li&gt;\n&lt;li&gt;conflicts：勇于解决将文件内容写入文件系统时可能造成的冲突&lt;/li&gt;\n&lt;li&gt;install：安装项目的依赖，比如npm install 或者 bower install&lt;/li&gt;\n&lt;li&gt;end：做一些收尾的工作。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;这些生命周期方法均支持返回Promise来进行异步操作。&lt;/p&gt;\n&lt;h3 id=\&#34;内置常用工具\&#34;&gt;内置常用工具&lt;/h3&gt;\n&lt;p&gt;终端交互：内置了Inquirer提供终端交互&lt;br&gt;\n模板填充：内置了ejs模板&lt;br&gt;\n文件操作&lt;br&gt;\n● this.fs.copyTpl：用于拷贝并且根据数据使用ejs模板渲染文件。此函数接受三个参数，源文件路径，目标文件路径，传给ejs用于渲染目标问价的数据。&lt;br&gt;\n● this.fs.copy：将文件丛源路径复制到目标路径。&lt;br&gt;\n● this.destinationPath() ：此函数返回最终生成项目的路径&lt;br&gt;\n其他&lt;br&gt;\n● this.npmInstall：实现npm isntall&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 部分代码，完整代码见最下方链接\nwriting() {\n    const done = this.async();\n    this.log(&amp;quot;⚙  Finish basic configuration.&amp;quot;, chalk.green(&amp;quot;✔&amp;quot;));\n    this.log(&amp;quot;📂 Generate the project template and configuration...&amp;quot;);\n    let spinner = ora({\n      text: `Download the template from ${GIT_BASE}${TPL_REPOSITORY}...`,\n      spinner: ORA_SPINNER\n    }).start();\n    this._downloadTemplate(TPL_REPOSITORY)\n      .then(() =&amp;gt; {\n        spinner.stopAndPersist({\n          symbol: chalk.green(&amp;quot;   ✔&amp;quot;),\n          text: `Finish downloading the template from ${GIT_BASE}${TPL_REPOSITORY}`\n        });\n        spinner = ora({\n          text: `Copy files into the project folder...`,\n          spinner: ORA_SPINNER\n        }).start();\n        const templateRoot = this.destinationPath(this.dirName, &amp;quot;.tmp&amp;quot;);\n        this.log(`\\n${templateRoot}`, &amp;quot;templateRoot&amp;quot;);\n        const resoPath = path.resolve(templateRoot, &amp;quot;../&amp;quot;);\n        this.log(resoPath, &amp;quot;resoPath&amp;quot;);\n        spinner.stopAndPersist({\n          symbol: chalk.green(&amp;quot;   ✔&amp;quot;),\n          text: `Finish copying files into the project folder`\n        });\n        execSync(`cp -R ${resoPath}/.tmp/* ${resoPath}`, { stdio: &amp;quot;inherit&amp;quot; });\n        spinner = ora({\n          text: `Clean tmp files and folders...`,\n          spinner: ORA_SPINNER\n        }).start();\n        fs.removeSync(templateRoot);\n        spinner.stopAndPersist({\n          symbol: chalk.green(&amp;quot;   ✔&amp;quot;),\n          text: `Finish cleaning tmp files and folders`\n        });\n        // ExecSync(`rm -R ${resoPath}/.tmp`, { stdio: &amp;quot;inherit&amp;quot; });\n        // 将新生成的项目的title换成自定义的项目名称\n        ejs.renderFile(\n          `${resoPath}/public/index.html`,\n          { dirName: this.dirName },\n          function(err, str) {\n            // Str =&amp;gt; 输出渲染后的 HTML 字符串\n            fs.writeFile(`${resoPath}/public/index.html`, str);\n          }\n        );\n        // 将新生成的项目的package.json的name换成自定义的项目名称\n        ejs.renderFile(\n          `${resoPath}/package.json`,\n          { dirName: this.dirName },\n          function(err, str) {\n            // Str =&amp;gt; 输出渲染后的 HTML 字符串\n            fs.writeFile(`${resoPath}/package.json`, str);\n          }\n        );\n        done();\n      })\n      .catch(err =&amp;gt; this.env.error(err));\n  }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;其他可能用到的工具\&#34;&gt;其他可能用到的工具&lt;/h3&gt;\n&lt;p&gt;● ora：用于创建Spinner，即比如下载模板文件时需要展示的laoding效果。&lt;br&gt;\n● chalk：用于打印彩色的信息&lt;br&gt;\n● update-notifier&lt;br&gt;\n● beeper&lt;br&gt;\n● boxen&lt;br&gt;\n调试&lt;br&gt;\n由于yeoman是通过npm包的形式进行使用的，所以我们可以在我们开发的generator项目的跟目录下，执行npm link 将我们开发的generator链接到全局，这样我们直接使用yo命令查看可以使用的generator，就可以看到我们所开发的generator了，并且是实时生效的&lt;/p&gt;\n&lt;h3 id=\&#34;我的代码是在本地的用的npm-link没有上传到github或npm此处贴出其他大佬的项目代码-快动手试一下吧~\&#34;&gt;我的代码是在本地的，用的npm link，没有上传到github或npm，此处贴出其他大佬的项目代码。快动手试一下吧～&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/alienzhou/webpack-kickoff-template\&#34;&gt;模版完整代码&lt;/a&gt;   注意要给ejs写入的空位&lt;br&gt;\n&lt;a href=\&#34;https://github.com/alienzhou/generator-webpack-kickoff\&#34;&gt;脚手架完整代码&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;参考文章\&#34;&gt;参考文章：&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.yuque.com/kongdepeng/rgpm60/qrluup\&#34;&gt;前端自动化工具 - yeoman&lt;/a&gt;&lt;br&gt;\n&lt;a href=\&#34;https://zhuanlan.zhihu.com/p/66190308\&#34;&gt;如何快速开发一个自己的项目脚手架？&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;用yeoman开发一个自己的项目脚手架&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;工程化&#34;,&#34;slug&#34;:&#34;_l9fydARk&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/_l9fydARk&#34;}],&#34;date&#34;:&#34;2021-10-19 20:37:02&#34;,&#34;dateFormat&#34;:&#34;2021-10-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:559000,&#34;words&#34;:2362,&#34;minutes&#34;:10},&#34;description&#34;:&#34;\n上面是一个使用脚手架来初始化项目的典型例子。\n随着前端工程化的理念不断深入，越来越多的人选择使用脚手架来从零到一搭建自己的项目。其中大家最熟悉的就是create-react-app和vue-cli，它们可以帮助我们初始化配置、生成项目结构...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\&#34;&gt;如何使用：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#yeoman%E6%8F%90%E4%BE%9B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%A6%82%E4%B8%8B\&#34;&gt;yeoman提供的生命周期如下：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E7%BD%AE%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7\&#34;&gt;内置常用工具&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B6%E4%BB%96%E5%8F%AF%E8%83%BD%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7\&#34;&gt;其他可能用到的工具&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E5%9C%A8%E6%9C%AC%E5%9C%B0%E7%9A%84%E7%94%A8%E7%9A%84npm-link%E6%B2%A1%E6%9C%89%E4%B8%8A%E4%BC%A0%E5%88%B0github%E6%88%96npm%E6%AD%A4%E5%A4%84%E8%B4%B4%E5%87%BA%E5%85%B6%E4%BB%96%E5%A4%A7%E4%BD%AC%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81-%E5%BF%AB%E5%8A%A8%E6%89%8B%E8%AF%95%E4%B8%80%E4%B8%8B%E5%90%A7~\&#34;&gt;我的代码是在本地的，用的npm link，没有上传到github或npm，此处贴出其他大佬的项目代码。快动手试一下吧～&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\&#34;&gt;参考文章：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;开发C端时遇到的一些问题与解决方法，都记录下来，希望对你也有帮助。&lt;/p&gt;\n&lt;h3 id=\&#34;1部分机型拍照上传图片旋转问题\&#34;&gt;1.部分机型拍照上传图片旋转问题：&lt;/h3&gt;\n&lt;p&gt;直接从图片后面加参数‘?x-oss-process=image/auto-orient,1/resize,m_fixed’（加上参数之后会自动旋转回来，其他参数可参考阿里OSS官方文档https://help.aliyun.com/document_detail/44691.html?spm=a2c4g.11186623.6.1390.750ac1f6HTe92Q）&lt;/p&gt;\n&lt;h3 id=\&#34;2swiper3d两边留白效果\&#34;&gt;2.swiper3D两边留白效果：&lt;/h3&gt;\n&lt;p&gt;（小程序h5均适用），代码如下，需要注意的是必须给swiper父级元素加overflow-x:hidden&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;.swiper-container {\n  height: 100%;\n  width: 600px;\n  perspective: 1600px;\n  overflow: visible;\n  img {\n    width: 100%;\n    height: 720px;\n    border-radius: 20px;\n  }\n}\n.swiper-slide {\n  padding: 0 24px;\n  box-sizing: border-box;\n  text-align: center;\n  transition: transform 0.5s;\n  transform-origin: 50% 50%;\n  transform: scale(0.9);\n  &amp;amp;.swiper-slide-active {\n    transform: scale(1);\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;3小程序的跳转十层限制不要一直用navigateto这样属于一直前进如果需要跳转回首页或者其他可以使用relaunch逻辑复杂时可自己写顶部导航栏包括返回按钮\&#34;&gt;3.小程序的跳转十层限制，不要一直用navigateTo，这样属于一直前进，如果需要跳转回首页或者其他可以使用reLaunch，逻辑复杂时可自己写顶部导航栏包括返回按钮。&lt;/h3&gt;\n&lt;h3 id=\&#34;4保存海报到本地推荐一波生成小程序海报的插件非常简单方便\&#34;&gt;4.保存海报到本地：推荐一波生成小程序海报的插件，非常简单方便&lt;/h3&gt;\n&lt;p&gt;taro-plugin-canvas (Taro环境使用)与wxa-plugin-canvas（普通小程序使用）&lt;br&gt;\ntip:如果遇到非常规的情况，需要手写canvas并且宽高尺寸乘2保证清晰度。&lt;/p&gt;\n&lt;h3 id=\&#34;5input光标永远停留在最后\&#34;&gt;5.input光标永远停留在最后：&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;var el = document.getElementById(&amp;quot;IPTname&amp;quot;);\nvar range = document.createRange();\nrange.selectNodeContents(el);\nrange.collapse(false);\nvar sel = window.getSelection();\nsel.removeAllRanges();\nsel.addRange(range);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;6小程序获取用户授权用户信息用户定位用户相册访问权限等时需要处理拒绝时的情况-生成海报到自己相册的时候如果用户在授权的时候点击了拒绝如果不兼容拒绝授权则直接生成失败\&#34;&gt;6.小程序获取用户授权（用户信息/用户定位/用户相册访问权限等）时需要处理拒绝时的情况。生成海报到自己相册的时候如果用户在授权的时候点击了拒绝，如果不兼容拒绝授权则直接生成失败。&lt;/h3&gt;\n&lt;h3 id=\&#34;7监听移动端键盘弹出和收起事件\&#34;&gt;7.监听移动端键盘弹出和收起事件。&lt;/h3&gt;\n&lt;p&gt;在ios设备上,操作表单输入时,键盘弹出时会把页面顶起来,键盘收起时并不会把页面恢复成原来的样子,造成页面样式错乱,利用focusout和focusin事件,可以间接地监听到键盘的收起和弹出事件,然后操作页面滚动到想要的位置.&lt;/p&gt;\n&lt;p&gt;focusout触发时机:  当元素即将失去焦点时，focusout 事件被触发。focusout 事件和 blur 事件之间的主要区别在于后者不会冒泡。&lt;/p&gt;\n&lt;p&gt;focusin触发时机:    当元素即将接收 focus 事件时，focusin 事件被触发。 这个事件和 focus 事件的主要区别在于后者不会冒泡。&lt;/p&gt;\n&lt;p&gt;监听方式:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;let scrollTop = 0\n//键盘收起\ndocument.body.addEventListener(&#39;focusout&#39;,()=&amp;gt;{\n   document.body.scrollTop=document.documentElement.scrollTop=scrollTop\n})\n//键盘弹出\ndocument.body.addEventListener(&#39;focusin&#39;,()=&amp;gt;{\n   scrollTop = document.body.scrollTop || document.documentElement.scrollTop\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;8移动端代码返回上一页windowlocationback失效\&#34;&gt;8.移动端代码返回上一页（window.location.back()失效）&lt;/h3&gt;\n&lt;p&gt;尼玛。。移动端返回上一页有时候用window.location.back()不好使，无解。可以使用window.location.href = document.referrer。&lt;/p&gt;\n&lt;h3 id=\&#34;9单页面应用跳转路由之后再次使用echarts时不展示\&#34;&gt;9.单页面应用跳转路由之后再次使用echarts时不展示&lt;/h3&gt;\n&lt;p&gt;首次使用不展示，可以延迟加载，但是当路由跳转回来之后延迟都不管用，那么需要在init Echarts之前动态设置容器宽高，并且清空父元素，因为再次回来的时候之前的echarts实例已经是存在的了，可在调试中查看详情。&lt;/p&gt;\n&lt;h3 id=\&#34;10-视频黑边问题\&#34;&gt;10. 视频黑边问题&lt;/h3&gt;\n&lt;p&gt;给video标签（原生video标签）加一个object-fit:fill属性即可解决。要强调的是，千万不要使用Taro的Video标签，很坑，解决了黑边，全屏时又会导致视频变形，不用object:fill的话也能解决黑边，但是全屏时视频的退出全屏样式又会被覆盖。&lt;/p&gt;\n&lt;h3 id=\&#34;11-手机锁屏时倒计时停止\&#34;&gt;11. 手机锁屏时倒计时停止&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;window.addEventListener(&#39;visibilitychange&#39;,() =&amp;gt; {\n   if (\n     //hidden为锁屏时或页面不展示时，可重新获取时间开始倒计时。\n      document.visibilityState ==&#39;hidden&#39;\n   ) \n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;12移动端实现省-市-区-街道四级联动\&#34;&gt;12.移动端实现省-市-区-街道四级联动&lt;/h3&gt;\n&lt;p&gt;需求是要实现地区四级联动，但是vant的插件只支持三级地区联动，就很尴尬，只能自己写，但是自己写的话UI与交互体验会很差，所以就想办法去和后端对接。其实很简单，写出来只是提醒大家可以这么实现，减少思考与踩坑的时间。三级联动选择完之后会返回地区编码，eg:Array&amp;lt;{code:&#39;110101&#39;,name:&#39;东城区&#39;}&amp;gt;,然后去请求后端的接口将地区编码传过去，就能得到其街道的相关信息，然后简单过滤一下，放在Picker选择器中就可以实现。接下来就可以写业务逻辑了。&lt;/p&gt;\n&lt;h3 id=\&#34;13ios内webview中vue项目会出现大块白色遮罩\&#34;&gt;13.ios内webview中vue项目会出现大块白色遮罩&lt;/h3&gt;\n&lt;p&gt;问题描述：&lt;/p&gt;\n&lt;p&gt;A页面——&amp;gt;B页面——&amp;gt;ios自带的返回——&amp;gt;白屏出现(像个魔鬼)——&amp;gt;点击或滑动页面——&amp;gt;问题解决&lt;/p&gt;\n&lt;p&gt;原因是，经过排查，发现在ios 机器上使用webview 开发Vue项目时候，go history (-1)，无法将body 的高度拉掉，使得遮住，触发轻点击，方可消除该遮罩&lt;/p&gt;\n&lt;p&gt;解决的理论：用于最重要的html 容器是container，然而因为设置html、body高度是100%，从而造成了 container 撑开父级，但浏览器默认滚动的scroll 并不是 container，而是body，某些因素，造成返回history 后，无法复原（ios 的锅），为此，将 container(app.vue中包裹的div，也可以是#app) 进行了绝对定位，并让它重新成为 scroll 的对象，从而解决问题。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;html, body {\n\n width: 100%;\n\n height: 100%;\n min-height: 100vh;\n\n margin: 0;\n\n padding: 0;\n\n position: relative;\n\n}\n\n.container {\n\n width: 100%;\n\nheight: 100vh;\n min-height: 100vh;\n\n background: #fff;\n\n overflow: scroll;\n\n -webkit-overflow-scrolling: touch;\n\n position: absolute;\n\n left:0;\n\n top:0;\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;14在ios上a页面分享朋友圈之后跳转到-b-页面或进行别的操作\&#34;&gt;14.在ios上A页面分享朋友圈之后，跳转到 B 页面（或进行别的操作）&lt;/h3&gt;\n&lt;p&gt;注：离开 app的 A 页面去微信，再次回到 app 的时候跳转到 B 页面&lt;/p&gt;\n&lt;p&gt;visibilitychange：当用户最小化窗口或者切换选项卡的时候，api 就会发送visibilitychange事件，让开发者知道页面状态已更改。你可以检测事件并执行某些操作或行为。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;//这个方法在分享被触发的时候执行\ninitVisibilityChange() {\n      if (typeof document.visibilityState != &amp;quot;undefined&amp;quot;) {\n        this.visibleChange = &amp;quot;visibilitychange&amp;quot;;\n        this.vibibleState = &amp;quot;visibilityState&amp;quot;;\n      } else if (\n        typeof (document as any).webkitVisibilityState != &amp;quot;undefined&amp;quot;\n      ) {\n        this.visibleChange = &amp;quot;webkitvisibilitychange&amp;quot;;\n        this.vibibleState = &amp;quot;webkitVisibilityState&amp;quot;;\n      }\n      if (this.visibleChange) {\n        document.addEventListener(\n          this.visibleChange,\n          this.onVisibilityChanged,\n          false\n        );\n      }\n    },\n      /**\n     * 从微信返回app可以在这里面处理事情\n     */\n    onVisibilityChanged(event: any) {\n      var hidden = event.target.webkitHidden;\n      if ((document as any)[this.vibibleState] == &amp;quot;visible&amp;quot;) {\n          this.goRun(); // 做自己需要的逻辑处理\n          this.removeVisibilityChange();\n      }\n    },\n     // 移除app后台监听事件\n    removeVisibilityChange() {\n      document.removeEventListener(\n        this.visibleChange,\n        this.onVisibilityChanged,\n        false\n      );\n    },\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;15-从vue页面跳转到非vue页面点击返回ios设备上页面数据不刷新\&#34;&gt;15. 从vue页面跳转到非vue页面，点击返回，ios设备上页面数据不刷新。&lt;/h3&gt;\n&lt;p&gt;比如A页面定义了一个变量为true，点击跳转到非vue项目页面（php），点击返回，查看这个变量，在安卓上依然为ture，但是在ios上就变成了false。&lt;/p&gt;\n&lt;p&gt;解决方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;window.onpageshow=function(e){\n　　if(e.persisted) {\n　　　　window.location.reload()\n　　}\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;16-app点击自带返回按钮关闭页面以及禁用返回的踩坑记录\&#34;&gt;16. app点击自带返回按钮关闭页面以及禁用返回的踩坑记录&lt;/h3&gt;\n&lt;p&gt;http://note.youdao.com/s/4qUINhV0 （比较多，有道云链接发出来，希望对大家有帮助）&lt;/p&gt;\n&lt;h3 id=\&#34;17-wxchooseimage方法在安卓与ios上取到的base64格式不一样安卓没有dataimagejpgbase64前缀需要单独处理\&#34;&gt;17. wx.chooseImage方法在安卓与ios上取到的base64格式不一样，安卓没有data:image/jpg;base64前缀，需要单独处理&lt;/h3&gt;\n&lt;h3 id=\&#34;18-手机内h5点击input无法唤起自带键盘可以给input添加click事件手动触发focus事件\&#34;&gt;18. 手机内h5点击input无法唤起自带键盘：可以给input添加click事件手动触发focus事件。&lt;/h3&gt;\n&lt;h3 id=\&#34;19-canvas绘制圆角矩形方法\&#34;&gt;19. canvas绘制圆角矩形方法&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;// x、y、w、h与canvas的rect方法参数相同\n//r代表圆角大小，1、2、3、4分别代表上左、上右、下右、下左\nfunction drawRoundRect(ctx, x, y, w, h, r1, r2, r3, r4) {\n  ctx.beginPath()\n  ctx.moveTo(x + r1, y)\n  ctx.arcTo(x + w, y, x + w, y + h, r2)\n  ctx.arcTo(x + w, y + h, x, y + h, r3)\n  ctx.arcTo(x, y + h, x, y, r4)\n  ctx.arcTo(x, y, x + w, y, r1)\n  ctx.closePath()\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;20-post导出文件处理\&#34;&gt;20. POST导出文件处理&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;fetch请求方法中，增加类型处理，预设请求传入字段控制，返回为：response.blob()；&lt;/li&gt;\n&lt;li&gt;返回值处理：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;const blob = new Blob([data], {type: &amp;quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&amp;quot;})\n    const a = document.createElement(&amp;quot;a&amp;quot;);\n    const filename ={\n      exportDetail: &#39;推广人员用户明细&#39;,\n      exportRecord: &#39;推广人员跟进记录明细&#39;\n    }\n    a.href = URL.createObjectURL(data)\n    a.download = filename[type] // 这里填保存成的文件名\n    a.click()\n    URL.revokeObjectURL(a.href)\n　　 a.remove();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;21-解决css瀑布流只能竖向展示问题非排名或排序时可用\&#34;&gt;21. 解决css瀑布流只能竖向展示问题(非排名或排序时可用)&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;// 父元素\ncolumn-count: 2;\nwidth: 100%;\n// 子元素\nbreak-inside: avoid;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const oldList = lists;\nconst newList = [].concat(\n  ...Array.from(\n    oldList.reduce(\n      (total, cur, index) =&amp;gt; {\n        total[index % 2].push(cur);\n        return total;\n      },\n      { 0: [], 1: [], length: 2 }\n    )\n  )\n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;22-mpvue的坑\&#34;&gt;22. mpvue的坑&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;一定要遵循mpvue官方文档建议，不要将v-for用在组件上面，或者在v-for内嵌套组件，这样成倍增加wx.setData的数据量&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在开发上拉加载更多的需求时不要使用小程序原生的scroll-view，直接使用page的onReachBottom事件&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;使用swiper时，不要嵌套过多swiper-item，不要在swiper-item中放入太多元素，有瀑布流等无限加载列表需求时，禁止使用swiper，会导致小程序卡死闪退&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;slot只能使用匿名，具名slot及scoped slot不能使用&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在定义组件data时，不要将与view无关的数据定义到data中，直接定义到外部，特别时监听scroll事件的时候&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;wx对象的方法全部都挂在mpvue对象下，不需要直接调用wx的方法，特别是在兼容h5的时候&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;button open-type是获取用户手机号等需要绑定事件的类型时，不要使用click.stop或catch:tap，这样会导致不会触发获取用户手机号的回调方法&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;所有组件的created生命周期只在小程序加载的时候统一执行，即使使用了v-if也不能在每次加载组件的时候触发&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;如果要自定义tabbar最好自己实现一个，不要使用原生的custom定义，原生custom限制太多且不能使用mpvue实现&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;23-taro-hooks子组件条件渲染\&#34;&gt;23. Taro hooks子组件条件渲染&lt;/h3&gt;\n&lt;p&gt;若是希望子组件props未被重新赋值的情况下不渲染，使用memo包裹，它实现了class中PureComponent的效果，浅比较了一次。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 子组件\nimport Taro, { memo } from &amp;quot;@tarojs/taro&amp;quot;;\nimport { View } from &amp;quot;@tarojs/components&amp;quot;;\n \nconst Index = ({ data }) =&amp;gt; {\n  return (\n    &amp;lt;View&amp;gt;\n      {console.log(&amp;quot;Test -- rander2&amp;quot;, data)}\n      {data.map((item, index) =&amp;gt; {\n        return &amp;lt;View key={index}&amp;gt;{item}&amp;lt;/View&amp;gt;;\n      })}\n    &amp;lt;/View&amp;gt;\n  );\n};\n \nexport default memo(Index);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;若是希望在某些特定的prop改变的时候更新子组件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// utils\nimport Taro from &amp;quot;@tarojs/taro&amp;quot;;\n \n/**\n  * 子组件条件渲染\n  * @param {Function} render - 要渲染的组件函数\n  * @param {Array}  observe - 渲染依据，从props接收的数据key，\n  */\nexport const compareRender = (render, observe=[]) =&amp;gt; {\n  const compare = (prevProps, nextProps) =&amp;gt; {\n    let keep = true;\n    for (let i = 0; i &amp;lt; observe.length; i++) {\n      if (prevProps[observe[i]] !== nextProps[observe[i]]) {\n        keep = false;\n        break;\n      }\n    }\n    return keep;\n  };\n  return Taro.memo(render, compare);\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;// 子组件\nimport Taro from &amp;quot;@tarojs/taro&amp;quot;;\nimport { View } from &amp;quot;@tarojs/components&amp;quot;;\n \nimport { compareRender } from &amp;quot;@utils&amp;quot;;\n \nconst Index = ({ data }) =&amp;gt; {\n  return (\n    &amp;lt;View&amp;gt;\n      {console.log(&amp;quot;Test -- rander&amp;quot;, data)}\n      {data.map((item, index) =&amp;gt; {\n        return &amp;lt;View key={index}&amp;gt;{item}&amp;lt;/View&amp;gt;;\n      })}\n    &amp;lt;/View&amp;gt;\n  );\n};\n \nexport default compareRender(Index, [&amp;quot;data&amp;quot;]);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;24-关于在dva副作用中多个请求同步执行的优化\&#34;&gt;24. 关于在dva副作用中多个请求同步执行的优化&lt;/h3&gt;\n&lt;p&gt;经测试：&lt;br&gt;\nconst res1 = yield call(req1); const res2 = yield call (req2); const res3 = yield call (req3);  三个请求同步执行，平均耗时大约为120ms，页面加载、数据等待时间较长。&lt;br&gt;\n优化：&lt;br&gt;\nconst [ res1, res2, res3] =  yield [ call(req1), call(req2), call(req3) ],  并发请求，平均耗时大约为20ms&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;C端H5或小程序常见问题总结&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;H5开发&#34;,&#34;slug&#34;:&#34;f3AJuGu9k&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/f3AJuGu9k&#34;}],&#34;date&#34;:&#34;2021-10-13 21:59:28&#34;,&#34;dateFormat&#34;:&#34;2021-10-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;12 min read&#34;,&#34;time&#34;:708000,&#34;words&#34;:2848,&#34;minutes&#34;:12},&#34;description&#34;:&#34;开发C端时遇到的一些问题与解决方法，都记录下来，希望对你也有帮助。\n1.部分机型拍照上传图片旋转问题：\n直接从图片后面加参数‘?x-oss-process=image/auto-orient,1/resize,m_fixed’（加上参数之后...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E9%83%A8%E5%88%86%E6%9C%BA%E5%9E%8B%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC%E9%97%AE%E9%A2%98\&#34;&gt;1.部分机型拍照上传图片旋转问题：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2swiper3d%E4%B8%A4%E8%BE%B9%E7%95%99%E7%99%BD%E6%95%88%E6%9E%9C\&#34;&gt;2.swiper3D两边留白效果：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B7%B3%E8%BD%AC%E5%8D%81%E5%B1%82%E9%99%90%E5%88%B6%E4%B8%8D%E8%A6%81%E4%B8%80%E7%9B%B4%E7%94%A8navigateto%E8%BF%99%E6%A0%B7%E5%B1%9E%E4%BA%8E%E4%B8%80%E7%9B%B4%E5%89%8D%E8%BF%9B%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E8%B7%B3%E8%BD%AC%E5%9B%9E%E9%A6%96%E9%A1%B5%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8relaunch%E9%80%BB%E8%BE%91%E5%A4%8D%E6%9D%82%E6%97%B6%E5%8F%AF%E8%87%AA%E5%B7%B1%E5%86%99%E9%A1%B6%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%8C%85%E6%8B%AC%E8%BF%94%E5%9B%9E%E6%8C%89%E9%92%AE\&#34;&gt;3.小程序的跳转十层限制，不要一直用navigateTo，这样属于一直前进，如果需要跳转回首页或者其他可以使用reLaunch，逻辑复杂时可自己写顶部导航栏包括返回按钮。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E4%BF%9D%E5%AD%98%E6%B5%B7%E6%8A%A5%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%8E%A8%E8%8D%90%E4%B8%80%E6%B3%A2%E7%94%9F%E6%88%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%B7%E6%8A%A5%E7%9A%84%E6%8F%92%E4%BB%B6%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%E6%96%B9%E4%BE%BF\&#34;&gt;4.保存海报到本地：推荐一波生成小程序海报的插件，非常简单方便&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5input%E5%85%89%E6%A0%87%E6%B0%B8%E8%BF%9C%E5%81%9C%E7%95%99%E5%9C%A8%E6%9C%80%E5%90%8E\&#34;&gt;5.input光标永远停留在最后：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%94%A8%E6%88%B7%E5%AE%9A%E4%BD%8D%E7%94%A8%E6%88%B7%E7%9B%B8%E5%86%8C%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%AD%89%E6%97%B6%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E6%8B%92%E7%BB%9D%E6%97%B6%E7%9A%84%E6%83%85%E5%86%B5-%E7%94%9F%E6%88%90%E6%B5%B7%E6%8A%A5%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9B%B8%E5%86%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A6%82%E6%9E%9C%E7%94%A8%E6%88%B7%E5%9C%A8%E6%8E%88%E6%9D%83%E7%9A%84%E6%97%B6%E5%80%99%E7%82%B9%E5%87%BB%E4%BA%86%E6%8B%92%E7%BB%9D%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%85%BC%E5%AE%B9%E6%8B%92%E7%BB%9D%E6%8E%88%E6%9D%83%E5%88%99%E7%9B%B4%E6%8E%A5%E7%94%9F%E6%88%90%E5%A4%B1%E8%B4%A5\&#34;&gt;6.小程序获取用户授权（用户信息/用户定位/用户相册访问权限等）时需要处理拒绝时的情况。生成海报到自己相册的时候如果用户在授权的时候点击了拒绝，如果不兼容拒绝授权则直接生成失败。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7%E7%9B%91%E5%90%AC%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E5%92%8C%E6%94%B6%E8%B5%B7%E4%BA%8B%E4%BB%B6\&#34;&gt;7.监听移动端键盘弹出和收起事件。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%BF%94%E5%9B%9E%E4%B8%8A%E4%B8%80%E9%A1%B5windowlocationback%E5%A4%B1%E6%95%88\&#34;&gt;8.移动端代码返回上一页（window.location.back()失效）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#9%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E8%B7%B3%E8%BD%AC%E8%B7%AF%E7%94%B1%E4%B9%8B%E5%90%8E%E5%86%8D%E6%AC%A1%E4%BD%BF%E7%94%A8echarts%E6%97%B6%E4%B8%8D%E5%B1%95%E7%A4%BA\&#34;&gt;9.单页面应用跳转路由之后再次使用echarts时不展示&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#10-%E8%A7%86%E9%A2%91%E9%BB%91%E8%BE%B9%E9%97%AE%E9%A2%98\&#34;&gt;10. 视频黑边问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#11-%E6%89%8B%E6%9C%BA%E9%94%81%E5%B1%8F%E6%97%B6%E5%80%92%E8%AE%A1%E6%97%B6%E5%81%9C%E6%AD%A2\&#34;&gt;11. 手机锁屏时倒计时停止&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#12%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0%E7%9C%81-%E5%B8%82-%E5%8C%BA-%E8%A1%97%E9%81%93%E5%9B%9B%E7%BA%A7%E8%81%94%E5%8A%A8\&#34;&gt;12.移动端实现省-市-区-街道四级联动&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#13ios%E5%86%85webview%E4%B8%ADvue%E9%A1%B9%E7%9B%AE%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%A4%A7%E5%9D%97%E7%99%BD%E8%89%B2%E9%81%AE%E7%BD%A9\&#34;&gt;13.ios内webview中vue项目会出现大块白色遮罩&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#14%E5%9C%A8ios%E4%B8%8Aa%E9%A1%B5%E9%9D%A2%E5%88%86%E4%BA%AB%E6%9C%8B%E5%8F%8B%E5%9C%88%E4%B9%8B%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0-b-%E9%A1%B5%E9%9D%A2%E6%88%96%E8%BF%9B%E8%A1%8C%E5%88%AB%E7%9A%84%E6%93%8D%E4%BD%9C\&#34;&gt;14.在ios上A页面分享朋友圈之后，跳转到 B 页面（或进行别的操作）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#15-%E4%BB%8Evue%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%88%B0%E9%9D%9Evue%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB%E8%BF%94%E5%9B%9Eios%E8%AE%BE%E5%A4%87%E4%B8%8A%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%88%B7%E6%96%B0\&#34;&gt;15. 从vue页面跳转到非vue页面，点击返回，ios设备上页面数据不刷新。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#16-app%E7%82%B9%E5%87%BB%E8%87%AA%E5%B8%A6%E8%BF%94%E5%9B%9E%E6%8C%89%E9%92%AE%E5%85%B3%E9%97%AD%E9%A1%B5%E9%9D%A2%E4%BB%A5%E5%8F%8A%E7%A6%81%E7%94%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95\&#34;&gt;16. app点击自带返回按钮关闭页面以及禁用返回的踩坑记录&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#17-wxchooseimage%E6%96%B9%E6%B3%95%E5%9C%A8%E5%AE%89%E5%8D%93%E4%B8%8Eios%E4%B8%8A%E5%8F%96%E5%88%B0%E7%9A%84base64%E6%A0%BC%E5%BC%8F%E4%B8%8D%E4%B8%80%E6%A0%B7%E5%AE%89%E5%8D%93%E6%B2%A1%E6%9C%89dataimagejpgbase64%E5%89%8D%E7%BC%80%E9%9C%80%E8%A6%81%E5%8D%95%E7%8B%AC%E5%A4%84%E7%90%86\&#34;&gt;17. wx.chooseImage方法在安卓与ios上取到的base64格式不一样，安卓没有data:image/jpg;base64前缀，需要单独处理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#18-%E6%89%8B%E6%9C%BA%E5%86%85h5%E7%82%B9%E5%87%BBinput%E6%97%A0%E6%B3%95%E5%94%A4%E8%B5%B7%E8%87%AA%E5%B8%A6%E9%94%AE%E7%9B%98%E5%8F%AF%E4%BB%A5%E7%BB%99input%E6%B7%BB%E5%8A%A0click%E4%BA%8B%E4%BB%B6%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91focus%E4%BA%8B%E4%BB%B6\&#34;&gt;18. 手机内h5点击input无法唤起自带键盘：可以给input添加click事件手动触发focus事件。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#19-canvas%E7%BB%98%E5%88%B6%E5%9C%86%E8%A7%92%E7%9F%A9%E5%BD%A2%E6%96%B9%E6%B3%95\&#34;&gt;19. canvas绘制圆角矩形方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#20-post%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86\&#34;&gt;20. POST导出文件处理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#21-%E8%A7%A3%E5%86%B3css%E7%80%91%E5%B8%83%E6%B5%81%E5%8F%AA%E8%83%BD%E7%AB%96%E5%90%91%E5%B1%95%E7%A4%BA%E9%97%AE%E9%A2%98%E9%9D%9E%E6%8E%92%E5%90%8D%E6%88%96%E6%8E%92%E5%BA%8F%E6%97%B6%E5%8F%AF%E7%94%A8\&#34;&gt;21. 解决css瀑布流只能竖向展示问题(非排名或排序时可用)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#22-mpvue%E7%9A%84%E5%9D%91\&#34;&gt;22. mpvue的坑&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#23-taro-hooks%E5%AD%90%E7%BB%84%E4%BB%B6%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93\&#34;&gt;23. Taro hooks子组件条件渲染&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#24-%E5%85%B3%E4%BA%8E%E5%9C%A8dva%E5%89%AF%E4%BD%9C%E7%94%A8%E4%B8%AD%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BC%98%E5%8C%96\&#34;&gt;24. 关于在dva副作用中多个请求同步执行的优化&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\&#34;&gt;MDN new&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;一-new的介绍\&#34;&gt;一、new的介绍&lt;/h3&gt;\n&lt;p&gt;new是干什么的：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;使用new可以少做四件事情：&lt;/p&gt;\n&lt;p&gt;不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；&lt;br&gt;\n不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；&lt;br&gt;\n不用 return 临时对象，因为 new 会帮你做；&lt;br&gt;\n不要给原型想名字了，因为 new 指定名字为 prototype。&lt;/p&gt;\n&lt;p&gt;new 关键字会进行如下的操作：&lt;/p&gt;\n&lt;p&gt;创建一个空的简单JavaScript对象（即{}）；&lt;br&gt;\n为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；&lt;br&gt;\n将步骤1新创建的对象作为this的上下文 ；&lt;br&gt;\n如果该函数没有返回对象，则返回this。&lt;br&gt;\n（译注：关于对象的 constructor，参见 Object.prototype.constructor）&lt;/p&gt;\n&lt;p&gt;创建一个用户自定义的对象需要两步：&lt;/p&gt;\n&lt;p&gt;通过编写函数来定义对象类型。&lt;br&gt;\n通过 new 来创建对象实例。&lt;br&gt;\n创建一个对象类型，需要创建一个指定其名称和属性的函数；对象的属性可以指向其他对象，看下面的例子：&lt;/p&gt;\n&lt;p&gt;当代码 new Foo(...) 执行时，会发生以下事情：&lt;/p&gt;\n&lt;p&gt;一个继承自 Foo.prototype 的新对象被创建。&lt;br&gt;\n使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。&lt;br&gt;\n由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）&lt;br&gt;\n你始终可以对已定义的对象添加新的属性。例如，car1.color = &amp;quot;black&amp;quot; 语句给 car1 添加了一个新的属性 color，并给这个属性赋值 &amp;quot;black&amp;quot;。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，你必须将该属性添加到 Car 对象类型的定义中。&lt;/p&gt;\n&lt;p&gt;你可以使用 Function.prototype 属性将共享属性添加到以前定义的对象类型。这定义了一个由该函数创建的所有对象共享的属性，而不仅仅是对象类型的其中一个实例。下面的代码将一个值为 null 的 color 属性添加到 car 类型的所有对象，然后仅在实例对象 car1 中用字符串 &amp;quot;black&amp;quot; 覆盖该值&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;function Car() {}\ncar1 = new Car();\ncar2 = new Car();\n\nconsole.log(car1.color);    // undefined\n\nCar.prototype.color = &amp;quot;original color&amp;quot;;\nconsole.log(car1.color);    // original color\n\ncar1.color = &#39;black&#39;;\nconsole.log(car1.color);   // black\n\nconsole.log(car1.__proto__.color) //original color\nconsole.log(car2.__proto__.color) //original color\nconsole.log(car1.color)  // black\nconsole.log(car2.color) // original color\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如果你没有使用 new 运算符， 构造函数会像其他的常规函数一样被调用， 并不会创建一个对象。在这种情况下， this 的指向也是不一样的。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;二-自定义一个new\&#34;&gt;二、自定义一个new&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;  // 构造器函数\n  let Parent = function (name, age) {\n    this.name = name;\n    this.age = age;\n  };\n  Parent.prototype.sayName = function () {\n    console.log(this.name);\n  };\n  //自己定义的new方法\n  let newMethod = function (Parent, ...rest) {\n    // 1.以构造器的prototype属性为原型，创建新对象；\n    let child = Object.create(Parent.prototype);\n    // 2.将this和调用参数传给构造器执行\n    Parent.apply(child, rest);\n    // 3.返回第一步的对象\n    return child;\n  };\n  //创建实例，将构造函数Parent与形参作为参数传入\n  const child = newMethod(Parent, &#39;echo&#39;, 26);\n  child.sayName() //&#39;echo&#39;;\n\n  //最后检验，与使用new的效果相同\n  child instanceof Parent//true\n  child.hasOwnProperty(&#39;name&#39;)//true\n  child.hasOwnProperty(&#39;age&#39;)//true\n  child.hasOwnProperty(&#39;sayName&#39;)//false\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;zi-ding-yi-yi-ge-new-fang-fa&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;自定义一个new方法&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;js&#34;,&#34;slug&#34;:&#34;3uoOai8za&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/3uoOai8za&#34;}],&#34;date&#34;:&#34;2021-10-07 20:36:51&#34;,&#34;dateFormat&#34;:&#34;2021-10-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:229000,&#34;words&#34;:981,&#34;minutes&#34;:4},&#34;description&#34;:&#34;MDN new\n一、new的介绍\nnew是干什么的：\n\nnew 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。\n\n使用new可以少做四件事情：\n不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80-new%E7%9A%84%E4%BB%8B%E7%BB%8D\&#34;&gt;一、new的介绍&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAnew\&#34;&gt;二、自定义一个new&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;首先得介绍一下深拷贝和浅拷贝\&#34;&gt;首先得介绍一下深拷贝和浅拷贝&lt;/h3&gt;\n&lt;p&gt;简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。&lt;/p&gt;\n&lt;p&gt;我们来举个浅拷贝例子:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;let a=[0,1,2,3,4],\n    b=a;\nconsole.log(a===b);\na[0]=1;\nconsole.log(a,b);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645179982030.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n嗯？明明b复制了a，为啥修改数组a，数组b也跟着变了，这里我不禁陷入了沉思。&lt;br&gt;\n那么这里，就得引入基本数据类型与引用数据类型的概念了。&lt;br&gt;\n面试常问，基本数据类型有哪些，number，string，boolean，null，undefined，symbol以及未来ES10新增的BigInt(任意精度整数)七类。&lt;/p&gt;\n&lt;p&gt;引用数据类型(Object类)有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等。&lt;/p&gt;\n&lt;p&gt;而这两类数据存储分别是这样的：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;基本类型--名值存储在栈内存中，例如let a=1;&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645180053377.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n当你b=a复制时，栈内存会新开辟一个内存，例如这样：&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645180068077.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;引用数据类型--名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值，我们以上面浅拷贝的例子画个图：&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645180120847.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645180132383.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645180430014.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645180475298.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;实现简单的深拷贝\&#34;&gt;实现简单的深拷贝&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;function deepClone(obj){\n    let objClone = Array.isArray(obj)?[]:{};\n    if(obj &amp;amp;&amp;amp; typeof obj===&amp;quot;object&amp;quot;){\n        for(key in obj){\n            if(obj.hasOwnProperty(key)){\n                //判断ojb子元素是否为对象，如果是，递归复制\n                if(obj[key]&amp;amp;&amp;amp;typeof obj[key] ===&amp;quot;object&amp;quot;){\n                    objClone[key] = deepClone(obj[key]);\n                }else{\n                    //如果不是，简单复制\n                    objClone[key] = obj[key];\n                }\n            }\n        }\n    }\n    return objClone;\n}    \nlet a=[1,2,3,4],\n    b=deepClone(a);\na[0]=2;\nconsole.log(a,b);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645180524777.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。&lt;/p&gt;\n&lt;h4 id=\&#34;这里再次强调深拷贝是拷贝对象各个层级的属性\&#34;&gt;这里再次强调，深拷贝，是拷贝对象各个层级的属性。&lt;/h4&gt;\n&lt;p&gt;那是不是说slice方法也是深拷贝了，毕竟b也没受a的影响，上面说了，深拷贝是会拷贝所有层级的属性，还是这个例子，我们把a改改&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;let a=[0,1,[2,3],4],\n        b=a.slice();\na[0]=1;\na[2][0]=1;\nconsole.log(a,b);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645180593582.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n拷贝的不彻底啊，b对象的一级属性确实不受影响了，但是二级属性还是没能拷贝成功，仍然脱离不了a的控制，说明slice根本不是真正的深拷贝。&lt;br&gt;\n第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。&lt;/p&gt;\n&lt;p&gt;同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。&lt;/p&gt;\n&lt;h3 id=\&#34;除了递归我们还可以借用json对象的parse和stringify\&#34;&gt;除了递归，我们还可以借用JSON对象的parse和stringify&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;function deepClone(obj){\n    let _obj = JSON.stringify(obj),\n        objClone = JSON.parse(_obj);\n    return objClone\n}    \nlet a=[0,1,[2,3],4],\n    b=deepClone(a);\na[0]=1;\na[2][0]=1;\nconsole.log(a,b);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1645180680861.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n说了这么多，了解深拷贝也不仅仅是为了应付面试题，在实际开发中也是非常有用的。例如后台返回了一堆数据，你需要对这堆数据做操作，但多人开发情况下，你是没办法明确这堆数据是否有其它功能也需要使用，直接修改可能会造成隐性问题，深拷贝能帮你更安全安心的去操作数据，根据实际情况来使用深拷贝，大概就是这个意思。&lt;/p&gt;\n&lt;h3 id=\&#34;问下大家objectassign属于浅拷贝还是深拷贝\&#34;&gt;问下大家object.assign属于浅拷贝还是深拷贝&lt;/h3&gt;\n&lt;p&gt;Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型，所以属于浅拷贝&lt;/p&gt;\n&lt;h3 id=\&#34;objectgetownpropertydescriptors方法配合-objectcreate-方法可以实现浅拷贝\&#34;&gt;Object.getOwnPropertyDescriptors方法配合 Object.create() 方法可以实现浅拷贝。&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;Object.create(\n  Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj)\n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;本文参考：https://www.cnblogs.com/echolun/p/7889848.html&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;如何用Object.create浅拷贝一个对象&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;js&#34;,&#34;slug&#34;:&#34;3uoOai8za&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/3uoOai8za&#34;}],&#34;date&#34;:&#34;2021-09-23 20:41:42&#34;,&#34;dateFormat&#34;:&#34;2021-09-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:280000,&#34;words&#34;:1209,&#34;minutes&#34;:5},&#34;description&#34;:&#34;首先得介绍一下深拷贝和浅拷贝\n简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。\n我们来举个浅拷贝例子:\nlet a=[0,1,2,3,4],\n ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A6%96%E5%85%88%E5%BE%97%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D\&#34;&gt;首先得介绍一下深拷贝和浅拷贝&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D\&#34;&gt;实现简单的深拷贝&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%99%E9%87%8C%E5%86%8D%E6%AC%A1%E5%BC%BA%E8%B0%83%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%98%AF%E6%8B%B7%E8%B4%9D%E5%AF%B9%E8%B1%A1%E5%90%84%E4%B8%AA%E5%B1%82%E7%BA%A7%E7%9A%84%E5%B1%9E%E6%80%A7\&#34;&gt;这里再次强调，深拷贝，是拷贝对象各个层级的属性。&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%99%A4%E4%BA%86%E9%80%92%E5%BD%92%E6%88%91%E4%BB%AC%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%80%9F%E7%94%A8json%E5%AF%B9%E8%B1%A1%E7%9A%84parse%E5%92%8Cstringify\&#34;&gt;除了递归，我们还可以借用JSON对象的parse和stringify&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E4%B8%8B%E5%A4%A7%E5%AE%B6objectassign%E5%B1%9E%E4%BA%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D\&#34;&gt;问下大家object.assign属于浅拷贝还是深拷贝&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#objectgetownpropertydescriptors%E6%96%B9%E6%B3%95%E9%85%8D%E5%90%88-objectcreate-%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D\&#34;&gt;Object.getOwnPropertyDescriptors方法配合 Object.create() 方法可以实现浅拷贝。&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;背景：今天 每周例行技术分享 的时候，有位同事说 js 获取不到文件大小：浏览器默认不允许js 执行IO操作。 举了个例子，比如想获取一个图片地址的文件大小，因为之前做过图片上传功能所以比较敏感，感觉应该是可以的，虽然他说网上找过很多资料但是都不行，但是这种东西 只有自己试试才安心嘛~~&lt;/p&gt;\n&lt;h3 id=\&#34;失败方案-canvastoblob\&#34;&gt;失败方案 canvas.toBlob&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;function loadImg(url){\n    return new Promise((res, rej) =&amp;gt; {\n        const img = new Image()\n        img.crossOrigin = &#39;&#39;   // 防止img 画在canvas上时报跨域错误\n        img.onload = function() {\n            res(this)\n        }\n        img.onerror = function() {\n            rej()\n        }\n        img.src = url\n    })\n}\n\nasync function getImgSize(url) {\n    const urlArr = url.split(&#39;.&#39;)\n    const mime = &amp;quot;image/&amp;quot; + urlArr[urlArr.length-1]\n    const img = await loadImg(url)\n    const {width,height} = img\n    const canvas = document.createElement(&#39;canvas&#39;)\n    const ctx = canvas.getContext(&#39;2d&#39;);\n    canvas.width = width;\n    canvas.height = height;\n    ctx.drawImage(img,0,0,width,height)\n    canvas.toBlob(\n        blob =&amp;gt; {\n            console.log(url,blob,(blob.size / 1000)+&#39;KB&#39;)\n        },\n        mime\n    );\n}\n\ngetImgSize(&#39;https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg&#39;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;看日志输出&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644227403808.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n看着成了，但实际.... 与 本地 和 Network 差 十万八千里&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644227440435.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644227452558.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n我尝试了几个图片,每个图片都比之前要大，而且增大程度不一定,这块估计是canvas画了一遍的原因。。。&lt;/p&gt;\n&lt;h3 id=\&#34;失败方法-canvastodataurl-dataurltoblob\&#34;&gt;失败方法 canvas.toDataURL + dataURLtoBlob&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;function loadImg(url){\n    return new Promise((res, rej) =&amp;gt; {\n        const img = new Image()\n        img.crossOrigin = &#39;&#39;   // 防止img 画在canvas上时报跨域错误\n        img.onload = function() {\n            res(this)\n        }\n        img.onerror = function() {\n            rej()\n        }\n        img.src = url\n    })\n}\n\nasync function getImgSize(url) {\n    const urlArr = url.split(&#39;.&#39;)\n    const mime = &amp;quot;image/&amp;quot; + urlArr[urlArr.length-1]\n    const img = await loadImg(url)\n    const {width,height} = img\n    const canvas = document.createElement(&#39;canvas&#39;)\n    const ctx = canvas.getContext(&#39;2d&#39;);\n    canvas.width = width;\n    canvas.height = height;\n    ctx.drawImage(img,0,0,width,height);\n    const blob =  dataURLtoBlob(canvas.toDataURL(mime));\n    console.log(url,blob,(blob.size / 1000)+&#39;KB&#39;)\n}\nfunction dataURLtoBlob(dataurl) {\n    var arr = dataurl.split(&#39;,&#39;);\n    var _arr = arr[1].substring(0,arr[1].length-2);\n    var mime = arr[0].match(/:(.*?);/)[1],\n        bstr =atob(_arr),\n        n = bstr.length,\n        u8arr = new Uint8Array(n);\n    while (n--) {\n        u8arr[n] = bstr.charCodeAt(n);\n    }\n    return new Blob([u8arr], {\n        type: mime\n    });\n}\n\ngetImgSize(&#39;https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg&#39;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;看结果⬇️&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644227621781.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n。。。看来不能走canvas这条路了&lt;/p&gt;\n&lt;h3 id=\&#34;成功方案-performance\&#34;&gt;成功方案 performance&lt;/h3&gt;\n&lt;p&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644227695711.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n难道真的没有办法了嘛？我盯着 浏览器Network 陷入沉思, 突然 Network 资源加载 的size在我眼里 越来越抢眼，貌似有个api可以获取到资源加载~~~~~ 走起&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;function getImgSize(url){\n    return new Promise((res, rej) =&amp;gt; {\n        var performance = window.performance || \n            window.msPerformance || \n            window.webkitPerformance;\n        if (performance) {\n            const img = new Image()\n            img.crossOrigin = &#39;&#39;\n            img.onload = function() {\n                let [imgEntries] = performance.getEntriesByName(url)\n                res(imgEntries)\n            }\n            img.onerror = function() {\n                rej(&#39;图片加载失败&#39;)\n            }\n            img.src = url\n        }else{\n            rej(&#39;浏览器不持支持performance&#39;)\n        }\n    })\n}\nlet url = &#39;https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg&#39;\ngetImgSize(url).then(v=&amp;gt;{\n    console.log(v)\n    console.log(v.decodedBodySize)\n    console.log((v.decodedBodySize / 1000),&#39;KB&#39;)\n    // transferSize  判断是否缓存\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;这块使用 decodedBodySize，因为 css js等资源 decodedBodySize 与本地大小一致&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644227863370.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;a href=\&#34;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/decodedBodySize\&#34;&gt;decodedBodySize-MDN文档&lt;/a&gt;&lt;br&gt;\n&lt;a href=\&#34;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/encodedBodySize\&#34;&gt;encodedBodySize-MDN 文档&lt;/a&gt;&lt;br&gt;\n&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/getEntriesByName\&#34;&gt;performance.getEntriesByName-MDN文档&lt;/a&gt;&lt;br&gt;\n哈哈哈哈，成了～&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;多组数据验证\&#34;&gt;多组数据验证&lt;/h3&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;图片地址&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;本地size&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;canvas.toBlob&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;canvas.toDataURL + dataURLtoBlob&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;performance&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;20519&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;36345&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;36343&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;20519&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;https://images.daojia.com/dop/custom/dda52b42212b6bdea3e12d03ac97ffbe.png&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;65511&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;164303&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;164302&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;65511&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;https://images.daojia.com/dop/custom/f8f0528c61e243699c309f5f25eab513.png&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;14638&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;36394&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;36391&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;14638&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h4 id=\&#34;没有看错-performance-与本地的完全一样\&#34;&gt;没有看错 performance 与本地的完全一样&lt;/h4&gt;\n&lt;h3 id=\&#34;不限制于图片\&#34;&gt;不限制于图片&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;function loadJSFile(source) {\n    return new Promise((res, rej) =&amp;gt; {\n        const node = document.createElement(&#39;script&#39;)\n        node.async = false\n        node.src = source\n\n        const supportOnload = &#39;onload&#39; in node\n        if (supportOnload) {\n            node.onload = function(){\n                res(this)\n            }\n            node.onerror = () =&amp;gt; {\n                rej(`${source}加载失败`)\n            }\n        } else {\n            node.onreadystatechange = function(){\n                if (/loaded|complete/i.test(node.readyState)) {\n                    res(this)\n                }\n            }\n        }\n        document.getElementsByTagName(&#39;head&#39;)[0].appendChild(node)\n    })\n}\nfunction loadImgFile(url){\n    return new Promise((res, rej) =&amp;gt; {\n        const img = new Image()\n        img.crossOrigin = &#39;&#39;\n        img.onload = function() {\n            res(this)\n        }\n        img.onerror = function() {\n            rej(&#39;图片加载失败&#39;)\n        }\n        img.src = url\n    })\n}\n\nfunction loadCSSFile(source) {\n    return new Promise((res, rej) =&amp;gt; {\n        var head = document.getElementsByTagName(&#39;head&#39;)[0];\n        var link = document.createElement(&#39;link&#39;);\n        link.type = &#39;text/css&#39;;\n        link.rel = &#39;stylesheet&#39;;\n        link.href = source;\n        const supportOnload = &#39;onload&#39; in link\n        if (supportOnload) {\n            link.onload = function(){\n                res(this)\n            }\n            link.onerror = () =&amp;gt; {\n                rej(`${source}加载失败`)\n            }\n        } else {\n            link.onreadystatechange = function(){\n                if (/loaded|complete/i.test(link.readyState)) {\n                    res(this)\n                }\n            }\n        }\n        head.appendChild(link);\n    })\n}\nfunction getFileSize(url){\n    return new Promise((res, rej) =&amp;gt; {\n    var performance = window.performance || \n        window.msPerformance || \n        window.webkitPerformance;\n    if (performance) {\n        let [imgEntries] = performance.getEntriesByName(url)\n        if(imgEntries){\n            console.log(imgEntries)\n            console.log(imgEntries.decodedBodySize)\n            console.log((imgEntries.decodedBodySize / 1000),&#39;KB&#39;)\n            res(imgEntries)\n        }else{\n            rej(&#39;资源加载有问题&#39;)\n        }\n    }else{\n        rej(&#39;浏览器不持支持performance&#39;)\n    }\n})\n}\n(async function (){\n    const css = &#39;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css&#39;;\n    await loadCSSFile(css)\n    await getFileSize(css)\n\n    const js = &#39;https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js&#39;;\n    await loadJSFile(js)\n    await getFileSize(js)\n\n    const img = &#39;https://images.daojia.com/dop/custom/f8f0528c61e243699c309f5f25eab513.png&#39;;\n    await loadImgFile(img)\n    await getFileSize(img)\n})()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644228526757.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;兼容性\&#34;&gt;兼容性&lt;/h3&gt;\n&lt;p&gt;最后记得使用&lt;a href=\&#34;https://caniuse.com/?search=encodedBodySize\&#34;&gt;caniuse - performance&lt;/a&gt;查看一下兼容性&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;js-huo-qu-wen-jian-da-xiao&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;js获取文件大小 window.performance&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;js&#34;,&#34;slug&#34;:&#34;3uoOai8za&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/3uoOai8za&#34;}],&#34;date&#34;:&#34;2021-09-22 21:49:49&#34;,&#34;dateFormat&#34;:&#34;2021-09-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/js-huo-qu-wen-jian-da-xiao&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:324000,&#34;words&#34;:1051,&#34;minutes&#34;:6},&#34;description&#34;:&#34;背景：今天 每周例行技术分享 的时候，有位同事说 js 获取不到文件大小：浏览器默认不允许js 执行IO操作。 举了个例子，比如想获取一个图片地址的文件大小，因为之前做过图片上传功能所以比较敏感，感觉应该是可以的，虽然他说网上找过很多资料但...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%B1%E8%B4%A5%E6%96%B9%E6%A1%88-canvastoblob\&#34;&gt;失败方案 canvas.toBlob&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%B1%E8%B4%A5%E6%96%B9%E6%B3%95-canvastodataurl-dataurltoblob\&#34;&gt;失败方法 canvas.toDataURL + dataURLtoBlob&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%90%E5%8A%9F%E6%96%B9%E6%A1%88-performance\&#34;&gt;成功方案 performance&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%9A%E7%BB%84%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81\&#34;&gt;多组数据验证&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B2%A1%E6%9C%89%E7%9C%8B%E9%94%99-performance-%E4%B8%8E%E6%9C%AC%E5%9C%B0%E7%9A%84%E5%AE%8C%E5%85%A8%E4%B8%80%E6%A0%B7\&#34;&gt;没有看错 performance 与本地的完全一样&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8D%E9%99%90%E5%88%B6%E4%BA%8E%E5%9B%BE%E7%89%87\&#34;&gt;不限制于图片&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%BC%E5%AE%B9%E6%80%A7\&#34;&gt;兼容性&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;docker attach :连接到正在运行中的容器。&lt;br&gt;\n要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。&lt;/p&gt;\n&lt;p&gt;官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了😨&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上--sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。&lt;br&gt;\nrunoob@runoob:~$ docker attach --sig-proxy=false mynginx&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-attach-ming-ling&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;docker attach :连接到正在运行中的容器。&lt;br&gt;\n要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。&lt;/p&gt;\n&lt;p&gt;官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了😨&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Docker attach 命令&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;docker&#34;,&#34;slug&#34;:&#34;r0XBmVMNv&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/r0XBmVMNv&#34;},{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-09-21 23:34:57&#34;,&#34;dateFormat&#34;:&#34;2021-09-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/docker-attach-ming-ling&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:44000,&#34;words&#34;:194,&#34;minutes&#34;:1},&#34;description&#34;:&#34;docker attach :连接到正在运行中的容器。\n要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。\n官方文档中说attach后可以通过CTRL-C来det...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;官网介绍：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。&lt;br&gt;\n&lt;a href=\&#34;https://nacos.io/zh-cn/docs/what-is-nacos.html\&#34;&gt;Nacos中文文档&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;概览&lt;br&gt;\n欢迎来到 Nacos 的世界！&lt;br&gt;\nNacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。&lt;br&gt;\nNacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;这个东西主要用于微服务，但我作为一个前端，只用了它的配置管理功能，虽然有点大材小用，但确实方便,而且还可以通过网页去直接查看数据结构。&lt;/p&gt;\n&lt;p&gt;假设前端要搞一个平台，但是并没有后端支持，那么权限管理以及一些必要的数据获取该怎么做呢，我们想到的肯定是node起服务，然后写接口，然后连接数据库。从而实现数据的增删改查。&lt;/p&gt;\n&lt;p&gt;但有一种更简单的方式，就是在服务器的docker中下载一个nacos,把数据放到nacos中管理，这样数据依然在我们的服务器上，并且不需要我们自己去写接口，nacos提供了openApi，我们直接调用接口就可以，是不是很方便呢。下面开始安装：&lt;/p&gt;\n&lt;h3 id=\&#34;nacos-docker-快速开始\&#34;&gt;Nacos Docker 快速开始&lt;/h3&gt;\n&lt;p&gt;操作步骤&lt;br&gt;\nClone 项目&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;git clone https://github.com/nacos-group/nacos-docker.git\ncd nacos-docker\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;单机模式 Derby&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-derby.yaml up\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;单机模式 MySQL&lt;/p&gt;\n&lt;p&gt;如果希望使用MySQL5.7&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-mysql-5.7.yaml up\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果希望使用MySQL8&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker-compose -f example/standalone-mysql-8.yaml up\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;集群模式&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker-compose -f example/cluster-hostname.yaml up \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;服务注册&lt;/p&gt;\n&lt;p&gt;curl -X POST &#39;http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;amp;ip=20.18.7.10&amp;amp;port=8080&#39;&lt;br&gt;\n服务发现&lt;/p&gt;\n&lt;p&gt;curl -X GET &#39;http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName&#39;&lt;br&gt;\n发布配置&lt;/p&gt;\n&lt;p&gt;curl -X POST &amp;quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;amp;group=test&amp;amp;content=helloWorld&amp;quot;&lt;br&gt;\n获取配置&lt;/p&gt;\n&lt;p&gt;curl -X GET &amp;quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;amp;group=test&amp;quot;&lt;br&gt;\nNacos 控制台&lt;/p&gt;\n&lt;p&gt;link：http://127.0.0.1:8848/nacos/（因为是在服务器上，所以可以直接使用对应的域名或者ip来访问）&lt;/p&gt;\n&lt;h3 id=\&#34;注意这里要用openapi提供的字段信息多了tenant字段-有哪里不明白的可以看下开头的官方文档哈\&#34;&gt;注意，这里要用openApi提供的字段信息，多了tenant字段。有哪里不明白的可以看下开头的官方文档哈。&lt;/h3&gt;\n&#34;,&#34;fileName&#34;:&#34;sequelize&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;前端使用Nacos&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-08-30 23:36:06&#34;,&#34;dateFormat&#34;:&#34;2021-08-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/sequelize&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:162000,&#34;words&#34;:664,&#34;minutes&#34;:3},&#34;description&#34;:&#34;官网介绍：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\nNacos中文文档\n\n概览\n欢迎来到 Nacos 的世界！\nNacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#nacos-docker-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B\&#34;&gt;Nacos Docker 快速开始&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F%E8%BF%99%E9%87%8C%E8%A6%81%E7%94%A8openapi%E6%8F%90%E4%BE%9B%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF%E5%A4%9A%E4%BA%86tenant%E5%AD%97%E6%AE%B5-%E6%9C%89%E5%93%AA%E9%87%8C%E4%B8%8D%E6%98%8E%E7%99%BD%E7%9A%84%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%B8%8B%E5%BC%80%E5%A4%B4%E7%9A%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%93%88\&#34;&gt;注意，这里要用openApi提供的字段信息，多了tenant字段。有哪里不明白的可以看下开头的官方文档哈。&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;https://www.itying.com/koa/article-index-id-90.html\&#34;&gt;koa2中文文档&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;一-什么是koa的中间件\&#34;&gt;一、什么是Koa的中间件&lt;/h3&gt;\n&lt;p&gt;通俗的讲：中间件就是匹配路由之前或者匹配路由完成做的一系列的操作，我们就可以把它叫做中间件。&lt;/p&gt;\n&lt;p&gt;在express中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处理请求-响应循环流程中的中间件，一般被命名为 next 的变量。在Koa中中间件和express有点类似。&lt;/p&gt;\n&lt;p&gt;中间件的功能包括：&lt;/p&gt;\n&lt;p&gt;执行任何代码。&lt;br&gt;\n修改请求和响应对象。&lt;br&gt;\n终结请求-响应循环。&lt;br&gt;\n调用堆栈中的下一个中间件。&lt;/p&gt;\n&lt;p&gt;如果我的get、post回调函数中，没有next参数，那么就匹配上第一个路由，就不会往下匹配了。如果想往下匹配的话，那么需要写next()&lt;/p&gt;\n&lt;h3 id=\&#34;二-koa应用可使用如下几种中间件\&#34;&gt;二、Koa应用可使用如下几种中间件：&lt;/h3&gt;\n&lt;p&gt;应用级中间件&lt;br&gt;\n路由级中间件&lt;br&gt;\n错误处理中间件&lt;br&gt;\n第三方中间件&lt;/p&gt;\n&lt;h3 id=\&#34;三-使用\&#34;&gt;三、使用&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ol&gt;\n&lt;li&gt;async和await&lt;br&gt;\n在koa中使用关键词 async 标记的函数是异步函数，&lt;br&gt;\n在异步函数中使用 await next(); 处理下一个异步函数。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;app.use(async func())&lt;br&gt;\nkoa的使用方法很简单，将一系列要处理的操作封装到一个个异步函数中，然后用Koa的实例app通过 app.use(async func()) 的形式调用&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;一个koa应用程序如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:\nconst Koa = require(&#39;koa&#39;);\nconst app = new Koa(); // 创建一个Koa对象表示web app本身:\n\n// 对于任何请求，app将调用该异步函数处理请求：\napp.use(async (ctx, next) =&amp;gt; {\n    await next();\n    ctx.response.type = &#39;text/html&#39;;\n    ctx.response.body = &#39;&amp;lt;h1&amp;gt;Hello, koa2!&amp;lt;/h1&amp;gt;&#39;;\n});\n\n// 在端口3000监听:\napp.listen(3000);\nconsole.log(&#39;app started at port 3000...&#39;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到 app.use() 括号里面的参数是一个函数。函数用了异步修饰符 async ，在这个函数内部，又通过关键字 await next() 调用下一个app.use的异步函数。如果这个函数是最后一个需要执行的函数，则内部不需要再写await next（）。&lt;/p&gt;\n&lt;h3 id=\&#34;四-koa中间件的执行顺序\&#34;&gt;四、koa中间件的执行顺序&lt;/h3&gt;\n&lt;p&gt;Express的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应。&lt;br&gt;\nKoa是从第一个中间件开始执行,遇到 await next() 就进入下一个中间件，一直到执行到最后一个中间件。然后再逆序执行上一个中间件 await next() 后面的代码，一直到第一个中间件 await next() 后面的代码执行完毕才发出响应。&lt;/p&gt;\n&lt;p&gt;koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。&lt;/p&gt;\n&lt;p&gt;例子：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;app.use(async (ctx, next) =&amp;gt; {\n    console.log(&#39;1&#39;); \n    await next(); // 调用下一个middleware\n    console.log(&#39;5&#39;)\n});\n\napp.use(async (ctx, next) =&amp;gt; {\n    console.log(&#39;2&#39;);\n    await next(); // 调用下一个middleware\n    console.log(&#39;4&#39;);\n});\n\napp.use(async (ctx, next) =&amp;gt; {\n    console.log(&#39;3&#39;);\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出结果： 12345&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;koa-zhong-jian-jian-yu-zhi-xing-shun-xu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;KOA中间件与执行顺序&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-08-23 20:59:26&#34;,&#34;dateFormat&#34;:&#34;2021-08-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/koa-zhong-jian-jian-yu-zhi-xing-shun-xu&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:188000,&#34;words&#34;:808,&#34;minutes&#34;:4},&#34;description&#34;:&#34;koa2中文文档\n一、什么是Koa的中间件\n通俗的讲：中间件就是匹配路由之前或者匹配路由完成做的一系列的操作，我们就可以把它叫做中间件。\n在express中间件（Middleware） 是一个函数，它可以访问请求对象（request obj...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AFkoa%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6\&#34;&gt;一、什么是Koa的中间件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C-koa%E5%BA%94%E7%94%A8%E5%8F%AF%E4%BD%BF%E7%94%A8%E5%A6%82%E4%B8%8B%E5%87%A0%E7%A7%8D%E4%B8%AD%E9%97%B4%E4%BB%B6\&#34;&gt;二、Koa应用可使用如下几种中间件：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89-%E4%BD%BF%E7%94%A8\&#34;&gt;三、使用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B-koa%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\&#34;&gt;四、koa中间件的执行顺序&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;https://github.com/node-modules/parameter\&#34;&gt;parameter地址&lt;/a&gt;&lt;br&gt;\n// Koa接口参数校验与返回值统一处理  将参数校验变成一个路由中间件，正确的话继续执行，错误的话抛出错误异常。&lt;br&gt;\n// 在第一个中间件中自定义返回格式这里叫ctx.DATA（ctx上自定义一个对象，对象包含code默认200,msg默认‘成功’,data默认空对象）&lt;br&gt;\n// 这里对错误异常做了处理，抛出的是带code码以及与code码对应的msg和错误原因data的对象，此时我们将错误信息赋值给ctx.DATA.data。app中先写一个捕获错误的中间件，这样抛出的错误我们能够捕获到，然后从这里我们给body赋值，这样错误时返回的就是code码和message都有的返回值&lt;br&gt;\n// 当成功查找到数据库中的数据时，我们只需要将数据给ctx.DATA.data，那么返回值就是code码为200，msg为成功，data为正确数据的对象了。万一出现了登陆失败，我们也可以改变ctx.DATA.message为登陆失败，改变code码等&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * 数据校验\n * wiki：https://github.com/node-modules/parameter/blob/master/example.js\n * @type {Parameter}\n */\n// const { HttpError } = require(&#39;../../utils/tool/error&#39;)\nconst util = require(&#39;util&#39;)\n// const ERROR_MSG = require(&#39;./errorMsg&#39;)\nconst ERROR_MSG = Object.freeze({\n  // en\n  // 0: &#39;fail&#39;,\n  // 1: &#39;validation error&#39;,\n  // 200: &#39;ok&#39;,\n  // 400: &#39;invalid param&#39;,\n  // 401: &#39;unauthorized&#39;,\n  // 403: &#39;forbidden&#39;,\n  // 404: &#39;not found&#39;,\n  // 500: &#39;internal server error&#39;,\n  // 503: &#39;service busy&#39;,\n\n  // zh-cn\n  0: &#39;失败&#39;,\n  1: &#39;验证码错误&#39;,\n  200: &#39;成功&#39;,\n  400: &#39;请求出错&#39;,\n  401: &#39;未授权的请求&#39;,\n  403: &#39;禁止：禁止执行访问&#39;,\n  404: &#39;找不到：请检查URL以确保路径正确&#39;,\n  500: &#39;服务器的内部错误&#39;,\n  503: &#39;服务不可用&#39;\n})\n\nfunction CustomError(code, msg) {\n  Error.call(this, &#39;&#39;)\n\n  this.code = code\n  this.msg = msg || ERROR_MSG[code] || &#39;unknown error&#39;\n\n  this.getCodeMsg = function() {\n    return {\n      code: this.code,\n      msg: this.msg\n    }\n  }\n}\n\nutil.inherits(CustomError, Error)\n\nfunction HttpError(code, msg) {\n  if ([0, 1, 200, 400, 401, 403, 404, 500, 503].indexOf(code) &amp;lt; 0) {\n    throw Error(&#39;not an invalid http code&#39;)\n  }\n\n  CustomError.call(this, code, msg)\n}\n\nutil.inherits(HttpError, CustomError)\n\nconst Parameter = require(&#39;parameter&#39;)\nconst parm = new Parameter()\n\n// 自定义校验\nparm.addRule(&#39;name&#39;, function(e, v) {\n  let sta = /^[a-z]$/.test(v)\n  return sta || &#39;只能输入一个字母&#39;\n})\n\n// 路由校验列表\nconst ruleList = {\n  // 登录\n  &#39;post/api/login&#39;: {\n    mobile: { type: &#39;string&#39;, required: true },\n    password: { type: &#39;string&#39;, required: true }\n  },\n  // 获取配置\n  &#39;get/api/setting&#39;: {\n    id: { type: &#39;string&#39;, required: true }\n  },\n  // 保存配置\n  &#39;post/api/setting&#39;: {\n    id: { type: &#39;number&#39;, required: true },\n    title: { type: &#39;string&#39;, required: false },\n    report_fix_id: { type: &#39;string&#39;, required: false },\n    fix_url: { type: &#39;string&#39;, required: false },\n    env: { type: &#39;string&#39;, required: false },\n    report: { type: &#39;number&#39;, required: false },\n    report_interval: { type: &#39;number&#39;, required: false }\n  },\n  // CICD\n  &#39;post/api/deploy&#39;: {\n    name: { type: &#39;string&#39;, required: true },\n    branch: { type: &#39;string&#39;, required: false },\n    env: { type: &#39;string&#39;, required: false }\n  },\n  // 用户详情\n  &#39;get/api/user-details&#39;: {\n    user_id: { type: &#39;string&#39;, required: true }\n  }\n}\n\n/**\n * 校验方法\n * @param ctx\n * @param next\n * @returns {Promise&amp;lt;void&amp;gt;}\n */\nconst parameter = async (ctx, next) =&amp;gt; {\n  let errors, data\n  let method = &#39;get&#39;\n  if (ctx.request.method === &#39;GET&#39;) {\n    data = ctx.query\n  } else {\n    method = &#39;post&#39;\n    data = ctx.request.body\n  }\n  console.log(method, data)\n  try {\n    let name = ctx.req._parsedUrl.pathname\n    errors = parm.validate(ruleList[method + name], data)\n  } catch (e) {\n    throw new HttpError(0, e.toString())\n  }\n  if (errors &amp;amp;&amp;amp; errors.length) {\n    ctx.DATA.data = errors\n    throw new HttpError(0, &#39;数据校验未通过&#39;)\n  }\n  await next()\n}\nmodule.exports = parameter\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;router.js&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 数据校验\nconst router = require(&#39;koa-router&#39;)()\nconst parameter = require(&#39;../utils/parameter&#39;)\n// project\nrouter.get(&#39;/api/user-details&#39;, parameter, userDetail)\nrouter.get(&#39;/api/setting&#39;, parameter, getSetting)\nrouter.post(&#39;/api/setting&#39;, parameter, setSetting)\n// common\nrouter.post(&#39;/api/login&#39;, parameter, login)\n// devops\nrouter.post(&#39;/api/deploy&#39;, parameter, checkToken, deploy)\n// swagger\nrouter.get(&#39;/api/swagger.json&#39;, async function (ctx) {\n  ctx.set(&#39;Content-Type&#39;, &#39;application/json&#39;)\n  ctx.body = openapiSpecification\n})\n// index\nrouter.get(&#39;/&#39;, index)\n\nmodule.exports = router\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;app.js&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\nconst views = require(&#39;koa-views&#39;)\nconst json = require(&#39;koa-json&#39;)\nconst favicon = require(&#39;koa-favicon&#39;)\nconst koaBody = require(&#39;koa-body&#39;)\nconst logger = require(&#39;koa-logger&#39;)\nconst colors = require(&#39;colors&#39;)\nconst { resolve } = require(&#39;path&#39;)\nconst { koaSwagger } = require(&#39;koa2-swagger-ui&#39;)\nconst mysql = require(&#39;mysql2&#39;)\n\nconst conf = require(&#39;./config&#39;)\nconst index = require(&#39;./routes&#39;)\n\n// 允许上传文件\napp.use(\n  koaBody({\n    multipart: true,\n    formidable: {\n      maxFileSize: 1000 * 1024 * 1024 // 设置上传文件大小最大限制\n    }\n  })\n)\n\n// 网站图标\napp.use(favicon(resolve(__dirname, &#39;./public&#39;, &#39;favicon.ico&#39;)))\n\n// 返回美化json\napp.use(json())\n\n// koa-logger\napp.use(logger())\n\n// 资源文件\napp.use(require(&#39;koa-static&#39;)(resolve(__dirname, &#39;./public&#39;)))\n\n// 模板引擎\napp.use(views(resolve(__dirname, &#39;./views&#39;), { map: { html: &#39;nunjucks&#39; } }))\n\n// sql特殊字符处理\nconst toEscapeString = val =&amp;gt; {\n  return mysql.escape(val)\n}\nconst toEscapeObject = dat =&amp;gt; {\n  for (let key in dat) {\n    typeof dat[key] === &#39;string&#39; &amp;amp;&amp;amp; (dat[key] = toEscapeString(dat[key]))\n    typeof dat[key] === &#39;object&#39; &amp;amp;&amp;amp; toEscapeObject(dat[key])\n  }\n  return dat\n}\n\n// 加入cookie.get、set及自定义返回格式\napp.use(async (ctx, next) =&amp;gt; {\n  ctx.cookie = {\n    set: (k, v, opt) =&amp;gt; {\n      opt = Object.assign({}, conf.cookieOptions, opt)\n      return ctx.cookies.set(k, v, opt)\n    },\n    get: (k, opt) =&amp;gt; {\n      opt = Object.assign({}, conf.cookieOptions, opt)\n      return ctx.cookies.get(k, opt)\n    }\n  }\n\n  let msg = {\n    0: &#39;失败&#39;,\n    1: &#39;验证码错误&#39;,\n    200: &#39;成功&#39;,\n    400: &#39;请求出错&#39;,\n    401: &#39;未授权的请求&#39;,\n    403: &#39;禁止：禁止执行访问&#39;,\n    404: &#39;找不到：请检查URL以确保路径正确&#39;,\n    500: &#39;服务器的内部错误&#39;,\n    503: &#39;服务不可用&#39;\n  }\n  ctx.json = dat =&amp;gt; {\n    !dat.message &amp;amp;&amp;amp; (dat.message = msg[dat.code])\n    return dat\n  }\n\n  // 自定义返回格式\n  ctx.DATA = {\n    data: {},\n    message: &#39;&#39;,\n    code: 200\n  }\n\n  // 状态统一判断\n  ctx.state = res =&amp;gt; {\n    return !(res &amp;amp;&amp;amp; res.length ? res[0] : res)\n  }\n  await next()\n})\n\n// swagger\napp.use(\n  koaSwagger({\n    routePrefix: &#39;/swagger&#39;, // host at /swagger instead of default /docs\n    swaggerOptions: {\n      url: &#39;/api/swagger.json&#39; // example path to json 其实就是之后swagger-jsdoc生成的文档地址\n    }\n  })\n)\n// 错误捕获\napp.use((ctx, next) =&amp;gt; {\n  return next().catch(err =&amp;gt; {\n    console.log(err)\n    let msg = err ? err.msg || err.toString() : &#39;unknown error&#39;\n    let code = err ? (err.code &amp;gt;= 0 ? err.code : 500) : 500\n    ctx.DATA.code = code\n    ctx.DATA.message = msg\n    ctx.body = ctx.DATA\n    ctx.status =\n      [200, 400, 401, 403, 404, 500, 503].indexOf(code) &amp;gt;= 0 ? code : 200\n  })\n})\n// routes\napp.use(index.routes(), index.allowedMethods())\n\napp.proxy = true\n\n// koa error-handling 服务端、http错误\napp.on(&#39;error&#39;, (err, ctx) =&amp;gt; {\n  console.error(&#39;server error&#39;, err, ctx)\n})\n\nmodule.exports = app\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;controller层的接口文件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const resData = {\n    os_type_data,\n    ip_data,\n    browser_data,\n    channel_group_data,\n    client_id_group_data,\n    sortArrFormat,\n    userActions\n  }\n  // 正常返回写法，一个个的定义很麻烦\n  // const successData = {\n  //   code: 0,\n  //   data: resData,\n  //   status: &#39;请求成功&#39;\n  // }\n  // ctx.body = successData\n  \n  // 直接把结果赋值，code码和message不用管\n  ctx.DATA.data = resData\n  ctx.body = ctx.json(ctx.DATA)\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;koa-jie-kou-can-shu-xiao-yan-yu-fan-hui-zhi-tong-yi-chu-li&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Koa接口参数校验与返回值统一处理&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-08-20 19:03:04&#34;,&#34;dateFormat&#34;:&#34;2021-08-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/koa-jie-kou-can-shu-xiao-yan-yu-fan-hui-zhi-tong-yi-chu-li&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:408000,&#34;words&#34;:1341,&#34;minutes&#34;:7},&#34;description&#34;:&#34;parameter地址\n// Koa接口参数校验与返回值统一处理  将参数校验变成一个路由中间件，正确的话继续执行，错误的话抛出错误异常。\n// 在第一个中间件中自定义返回格式这里叫ctx.DATA（ctx上自定义一个对象，对象包含code...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;先看下效果&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642391805862.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n这里我用的是koa2+swagger&lt;/p&gt;\n&lt;h3 id=\&#34;安装\&#34;&gt;安装&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;// koa2-swagger-ui UI视图组件  swagger-jsdoc 识别写的 /***/ 转 json\nnpm install koa2-swagger-ui swagger-jsdoc --save\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.npmjs.com/package/koa2-swagger-ui\&#34;&gt;koa2-swagger-ui npm地址&lt;/a&gt; （创建接口文档）&lt;br&gt;\n&lt;a href=\&#34;https://www.npmjs.com/package/swagger-jsdoc\&#34;&gt;swagger-jsdoc npm地址&lt;/a&gt; （这个库读取带有jsdoc注释的源代码，并生成OpenAPI (Swagger)规范。）&lt;br&gt;\n&lt;a href=\&#34;https://www.jianshu.com/p/5365ef83252a\&#34;&gt;OpenAPI 规范摘要&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;配置\&#34;&gt;配置&lt;/h3&gt;\n&lt;p&gt;router.js&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const router = require(&#39;koa-router&#39;)() //引入路由函数\nconst swaggerJSDoc = require(&#39;swagger-jsdoc&#39;)\nconst path = require(&#39;path&#39;)\nconst swaggerDefinition = {\n  openapi: &#39;3.0.1&#39;,\n    info: {\n        title: &#39;blog项目访问地址&#39;,\n        version: &#39;1.0.0&#39;,\n        description: &#39;API&#39;,\n    },\n    basePath: &#39;/&#39;, // Base path (optional)\n    tags: [\n      {\n        name: &#39;manage&#39;,\n        description: &#39;管理系统&#39;\n      },\n      {\n        name: &#39;client&#39;,\n        description: &#39;日志上报&#39;\n      }\n    ],\n    schemes: [&#39;http&#39;, &#39;https&#39;],\n    securityDefinitions: {\n    server_auth: {\n      type: &#39;oauth2&#39;,\n      description: &#39;登录账号密码鉴权&#39;,\n      tokenUrl: &#39;&#39;,\n      flow: &#39;password&#39;,\n      scopes: {\n        token: &#39;modify pets in your account&#39;\n      }\n    },\n    token: {\n      type: &#39;apiKey&#39;,\n      name: &#39;token&#39;,\n      in: &#39;header&#39;\n    }\n  }\n};\nconst options = {\n    swaggerDefinition,\n    apis: [path.join(__dirname, &#39;./controllers/*.js&#39;)], // 包含上述注释的文件（）\n};\nconst swaggerSpec = swaggerJSDoc(options)\n// 通过路由获取生成的注解文件\nrouter.get(&#39;/swagger.json&#39;, async function (ctx) {\n    ctx.set(&#39;Content-Type&#39;, &#39;application/json&#39;);\n    ctx.body = swaggerSpec;\n})\nmodule.exports = router\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;app.js 入口文件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const swagger = require(&#39;./router&#39;)  // router中做了swagger配置\nconst { koaSwagger } = require(&#39;koa2-swagger-ui&#39;)\n\n// 接口文档配置\napp.use(swagger.routes(), swagger.allowedMethods())\napp.use(koaSwagger({\n  routePrefix: &#39;/swagger&#39;, // 接口文档访问地址\n  swaggerOptions: {\n    url: &#39;/swagger.json&#39;, // example path to json 其实就是之后swagger-jsdoc生成的文档地址\n  }\n}))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;启动项目，访问项目接口地址 + swagger ，我的地址是 http://localhost:4002/swagger&lt;/p&gt;\n&lt;h3 id=\&#34;注释生成文档\&#34;&gt;注释生成文档&lt;/h3&gt;\n&lt;p&gt;在controller层文件每个接口上写注释，注释是以@swagger开头的，swagger-jsdoc 会识别@swagger，然后解析下面的注释，解析完给koa2-swagger-ui显示成页面，总的流程就是这样。&lt;br&gt;\nget方式&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 获取博客列表\n/**\n * @swagger\n * /api/blog/list:\n *   get:\n *     summary: 获取博客列表\n *     description: 获取博客列表\n *     tags:\n *       - blogs\n *     parameters:\n *       - name: author\n *         in: query\n *         required: false\n *         description: 作者\n *         type: string\n *       - name: keyword\n *         in: query\n *         required: false\n *         description: 搜索关键字\n *         type: string\n *     responses:\n *       200:\n *         description: 成功获取\n */\nrouter.get(&#39;/list&#39;, async (ctx, next) =&amp;gt; {\n  const query = ctx.query\n  let author = query.author || &#39;&#39;\n  const keyword = query.keyword || &#39;&#39;\n\n  const listData = await getList(author, keyword)\n  ctx.body = new SuccessModel(listData)\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;post方式&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;/**\n * @swagger\n * definitions:\n *  loginparam:\n *    properties:\n *      username:\n *        type: &amp;quot;string&amp;quot;\n *        default: &amp;quot;shangsan&amp;quot;\n *        description: 用户名\n *      password:\n *        type: &amp;quot;string&amp;quot;\n *        default: &amp;quot;123&amp;quot;\n *        description: 密码\n */\n\n/**\n * @swagger\n * components:\n *   schemas:\n *     ProjectDetail:\n *       type: object\n *       properties:\n *         id:\n *           type: integer\n *           format: int64\n *         petId:\n *           type: integer\n *           format: int64\n *         quantity:\n *           type: integer\n *           format: int32\n *         shipDate:\n *           type: string\n *           format: date-time\n */\n\n/**\n * @swagger\n * /api/user/login:\n *   post:\n *     summary: 登录\n *     description: 登录\n *     tags:\n *       - user\n *     consumes:\n *      - application/json\n *      - application/xml\n *     produces:\n *      - application/json\n *      - application/xml\n *     parameters:\n *       - name: body\n *         in: body\n *         schema:\n *          $ref: &#39;#/definitions/loginparam&#39; （请求参数这里单独抽出，在上面定义）\n *     responses:\n *       200:\n *         description: 发布成功\n *          content:\n *           application/json:\n *             schema:\n *               $ref: &#39;#/components/schemas/ProjectDetail&#39;（返回参数也是单独抽出定义，这里是随便举个例子）\n *       402:\n *          description: 信息填写不全\n *       403:\n *          description: 参数类型错误\n */\n\nrouter.post(&#39;/login&#39;, async (ctx, next) =&amp;gt; {\n    // 业务逻辑\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;返回示例&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642412213197.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n基本的接口文档就生成啦，快试一下吧～&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;node-jie-kou-sheng-cheng-jie-kou-wen-dang&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;node接口生成接口文档&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-08-12 19:21:22&#34;,&#34;dateFormat&#34;:&#34;2021-08-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/node-jie-kou-sheng-cheng-jie-kou-wen-dang&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:193000,&#34;words&#34;:670,&#34;minutes&#34;:4},&#34;description&#34;:&#34;先看下效果\n\n这里我用的是koa2+swagger\n安装\n// koa2-swagger-ui UI视图组件  swagger-jsdoc 识别写的 /***/ 转 json\nnpm install koa2-swagger-ui swag...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85\&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE\&#34;&gt;配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E9%87%8A%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3\&#34;&gt;注释生成文档&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;可选链操作符\&#34;&gt;可选链操作符（?.）&lt;/h3&gt;\n&lt;p&gt;以前写代码做判断一般这样写或者三目运算：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;let nestedProp = obj.first &amp;amp;&amp;amp; obj.first.second;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;现在只需要这样写：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const adventurer = {\n  name: &#39;Alice&#39;,\n  cat: {\n    name: &#39;Dinah&#39;\n  }\n};\n\nconst dogName = adventurer.dog?.name;\nconsole.log(dogName);\n// expected output: undefined\n\nconsole.log(adventurer.someNonExistentMethod?.());\n// expected output: undefined\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;空值合并操作符\&#34;&gt;空值合并操作符（??）&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;只有当左侧为null和undefined时，才会返回右侧的数&lt;br&gt;\n空值合并操作符（??）是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。&lt;br&gt;\n与逻辑或操作符（||）不同，逻辑或操作符会在左侧操作数为假值时返回右侧操作数。也就是说，如果使用 ?? 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，&#39;&#39; 或 0）时。见下面的例子。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const foo = null ?? &#39;default string&#39;;\nconsole.log(foo);\n// expected output: &amp;quot;default string&amp;quot;\n\nconst baz = 0 ?? 42;\nconsole.log(baz);\n// expected output: 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const nullValue = null;\nconst emptyText = &amp;quot;&amp;quot;; // 空字符串，是一个假值，Boolean(&amp;quot;&amp;quot;) === false\nconst someNumber = 42;\n\nconst valA = nullValue ?? &amp;quot;valA 的默认值&amp;quot;;\nconst valB = emptyText ?? &amp;quot;valB 的默认值&amp;quot;;\nconst valC = someNumber ?? 0;\n\nconsole.log(valA); // &amp;quot;valA 的默认值&amp;quot;\nconsole.log(valB); // &amp;quot;&amp;quot;（空字符串虽然是假值，但不是 null 或者 undefined）\nconsole.log(valC); // 42\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;与结合使用\&#34;&gt;?.与??结合使用&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 空值合并操作符可以在使用可选链时设置一个默认值：\n\nlet customer = {\nname: &amp;quot;Carl&amp;quot;,\ndetails: { age: 82 }\n};\n\nlet customerCity = customer?.city ?? &amp;quot;暗之城&amp;quot;;\nconsole.log(customerCity);  // “暗之城”\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;工程中怎样使用\&#34;&gt;工程中怎样使用&lt;/h4&gt;\n&lt;p&gt;babel7以上版本支持，可以添加以下2个devDependencies依赖：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@babel/plugin-proposal-optional-chaining // 可选链\n@babel/plugin-proposal-nullish-coalescing-operator // 双问号\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在.babelrc或者babel.config.js中这加入2个插件(plugins属性放在JSON顶层)：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;{\n  &amp;quot;plugins&amp;quot;: [\n      &amp;quot;@babel/plugin-proposal-nullish-coalescing-operator&amp;quot;,\n      &amp;quot;@babel/plugin-proposal-optional-chaining&amp;quot;\n  ]\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;运算\&#34;&gt;!!运算&lt;/h3&gt;\n&lt;p&gt;两个叹号表示把目标值转化为布尔值，相当于使用Boolean()方法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;!!&amp;quot;123&amp;quot;  相当于是   Boolean(&amp;quot;123&amp;quot;)    //结果为true\n!!{a:1}  相当于是    Boolean({a:1})    //结果为true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在if语句中,表达式的结果将被强制为布尔值，通过双重否定（!!）或强制转换为布尔值Boolean是不必要的。&lt;/p&gt;\n&lt;h3 id=\&#34;~~运算\&#34;&gt;~~运算&lt;/h3&gt;\n&lt;p&gt;~~ 会把后面的表达式强行变成int&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;var n = ~~5; // 5\nvar m = ~~-8; // -8\nvar j = ~~true; // 将true转换为int，也就是1，然后再计算。结果为1\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;cao-zuo-fu&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;js中的一些操作符 ?./??/!!/~~&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;js&#34;,&#34;slug&#34;:&#34;3uoOai8za&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/3uoOai8za&#34;}],&#34;date&#34;:&#34;2021-07-29 20:04:04&#34;,&#34;dateFormat&#34;:&#34;2021-07-29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/cao-zuo-fu&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:170000,&#34;words&#34;:682,&#34;minutes&#34;:3},&#34;description&#34;:&#34;可选链操作符（?.）\n以前写代码做判断一般这样写或者三目运算：\nlet nestedProp = obj.first &amp;amp;&amp;amp; obj.first.second;\n\n现在只需要这样写：\nconst adventurer = {\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6\&#34;&gt;可选链操作符（?.）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6\&#34;&gt;空值合并操作符（??）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8E%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8\&#34;&gt;?.与??结合使用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A5%E7%A8%8B%E4%B8%AD%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8\&#34;&gt;工程中怎样使用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%90%E7%AE%97\&#34;&gt;!!运算&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#~~%E8%BF%90%E7%AE%97\&#34;&gt;~~运算&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;https://www.mysqlzh.com/doc/124.html\&#34;&gt;mysql中文文档&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;1查询记录\&#34;&gt;1.查询记录&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select*from 表名 [where 条件];\n\neg:select*from students;//查询 students 表中所有记录，所有字段的值都显示出来\n\nselect field1,field2,...fieldn... from 表名 [where 条件];\n\neg:select id,name,age from students;//查询 students 表中所有记录, 只显示出 id，name，age三个字段的值\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;1.“*”表示将所有的字段都显示出来&lt;/p&gt;\n&lt;p&gt;2.用逗号分割，列出需要显示的字段&lt;/p&gt;\n&lt;h3 id=\&#34;2查询不重复的记录\&#34;&gt;2.查询不重复的记录&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select distinct 字段 from 表名;\n\neg: select distinct name from students;//查询名字不相同的学生;\n　　select distinct name,age from students;//查询名字和年龄同时不同的学生\n　　\n　　1.distinct必须放在最开头\n　　2.distinct只能使用需要去重的字段进行操作。  ----也就是说我sidtinct了name,age两个字段，我后面想根据id进行排序，是不可以的，因为只能name,age两个字段进行操作.\n　　3.distinct去重多个字段时，含义是：几个字段 同时重复 时才会被 过滤。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;3条件查询\&#34;&gt;3.条件查询&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select 字段 from 表名 where 条件;\n\neg:select * from student where sex=&#39;男&#39; and age&amp;gt;20; //查询性别是男，并且年龄大于20岁的人。\n\nwhere后面的条件可以用&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、!=等多种比较运算符，多个条件之间可以用or、and等逻辑运算符\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;4排序和限制\&#34;&gt;4.排序和限制&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;排序\nselect * from 表名 [where 条件] [ order by  field1 [desc/asc],field2 [desc/asc]... ];\n\neg:select *from student order by age desc;//查询学生表并按年龄降序排列。\n\n1.desc 降序排列，asc 升序排列\n2.order by 后面可以跟多个不同的排序字段，每个排序字段都可以有不同的排序顺序。\n3.如果排序字段的值一样，则相同的字段按照第二个排序字段进行排序。\n4.如果只有一个排序字段，则字段相同的记录将会无序排列。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;限制\nselect ... [limit 起始偏移量,行数];\n\neg:select * from student order by mark desc limit 5;//取出成绩前五名的学生(省略了起始偏移量，此时默认为0)\n\n1.默认情况下，起始偏移量为0，只写记录行数就可以。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;5聚合\&#34;&gt;5.聚合&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;select 字段 fun_name from 表名 [where 条件] [group by field1,field2...] [with rollup] [having 条件];\n\neg:\n\n1.fun_name 表示要做的聚合操作，也就是说聚合函数，常用的有 : sum(求和)、count(*)(记录数)、max(最大值)、min(最小值)。\n2.group by关键字 表示要进行分类聚合的字段。比如要按照部门分类统计员工数量，部门就应该写在group by 后面。\n3.with rollup 是可选语法，表明是否对分类聚合后的结果进行再汇总\n4.having 关键字表示对分类后的结果再进行条件过滤。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;公司员工表A如下 (编号，姓，名，薪水) ：&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143111386.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;统计总人数\nselect count(1) from A;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143169839.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code&gt;统计各个姓的人数\nselect xing,count(1) from A group by xing;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143194061.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code&gt;既要统计各个姓的人数，又统计总人数\nselect xing,count(1) from A group by xing with rollup;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143250933.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code&gt;统计人数大4的姓\nselect xing,count(1) from A group by xing having count(1)&amp;gt;4;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143298558.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code&gt;统计薪水总额，最低薪资，最高薪资\nselect count(1),min(salary),max(salary) from A;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642143319528.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;6为表和字段取别名\&#34;&gt;6.为表和字段取别名&lt;/h3&gt;\n&lt;p&gt;在查询数据时，可以为表和字段取别名，这个别名可以代替指定的表和字段。如果表名很长，用起来不方便，则可以用一个别名来代替，语法如下：(as关键字可省略)&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;select * from 表名 [as] 别名  （为表取别名）\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;SELECT 字段名 [AS] 别名[,字段名 [AS] 别名,……] FROM 表名; (为字段取别名)\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;mysql-cha-xun-yu-ju&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;mysql查询语句&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;mysql&#34;,&#34;slug&#34;:&#34;pzYATVrka&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/pzYATVrka&#34;},{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-07-22 20:46:38&#34;,&#34;dateFormat&#34;:&#34;2021-07-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/mysql-cha-xun-yu-ju&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:220000,&#34;words&#34;:918,&#34;minutes&#34;:4},&#34;description&#34;:&#34;mysql中文文档\n1.查询记录\nselect*from 表名 [where 条件];\n\neg:select*from students;//查询 students 表中所有记录，所有字段的值都显示出来\n\nselect field1,fie...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95\&#34;&gt;1.查询记录&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E6%9F%A5%E8%AF%A2%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E8%AE%B0%E5%BD%95\&#34;&gt;2.查询不重复的记录&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2\&#34;&gt;3.条件查询&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E6%8E%92%E5%BA%8F%E5%92%8C%E9%99%90%E5%88%B6\&#34;&gt;4.排序和限制&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5%E8%81%9A%E5%90%88\&#34;&gt;5.聚合&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6%E4%B8%BA%E8%A1%A8%E5%92%8C%E5%AD%97%E6%AE%B5%E5%8F%96%E5%88%AB%E5%90%8D\&#34;&gt;6.为表和字段取别名&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;http://www.dockerinfo.net/document\&#34;&gt;docker中文文档&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;最近Docker突然火得不得了，到处都是谈论Docker的声音，相信大家和小编一样的心情，看这个东西有点高大上，但尝试去阅读Docker文章时又发现概念很模糊、不接地气、难以理解、无从下手…于是三天打鱼两天晒网，最终不了了之，反正公司也没要求用这玩意儿，不费劲了… 这不，当前几天项目要求快速上线并且部署多台服务器环境时，小编一台一台服务器的yum install、vim、restart…想屎的心都有，那时小编心里想要是有一个这么一个U盘，能把整个环境一台一台的Ctrl+V过去，那该多好啊。那时脑子一下子闪过一个念头：Docker不就是我想拥有的那个U盘吗。&lt;/p&gt;\n&lt;p&gt;怀着这样的一个念头，小编花了一些时间去查阅Docker相关的书籍、看视频、逛论坛，刚开始学习时非常难受，搞不懂什么是容器什么是镜像什么是鲸鱼船…而涉及到一些原理底层的知识，书籍里的那些概念比代码都能懂，小编硬啃了一段时间并且实操了几次之后，再回过头来，才豁然开朗。念及许多想要学Docker却苦于难以入门的开发者们，正在学习却很挣扎的初学者们，故而把小编这段时间的学习成果，以一个初学者的角度，遵循循序渐进的原则，编成一份通俗易懂的文章，希望能以此引导入门，早日成Docker大神。&lt;/p&gt;\n&lt;p&gt;文章提纲：&lt;/p&gt;\n&lt;p&gt;1、什么是Docker&lt;/p&gt;\n&lt;p&gt;2、Docker对我们有什么用处&lt;/p&gt;\n&lt;p&gt;3、Docker安装和使用&lt;/p&gt;\n&lt;p&gt;4、彩蛋&lt;/p&gt;\n&lt;p&gt;1、什么是Docker&lt;br&gt;\n什么是docker？恐怕90%的人脑子一闪而过的都是那张图：一条鲸鱼背上扛着一堆箱子，图片下方是大大的“docker”。&lt;/p&gt;\n&lt;p&gt;docker是什么？&lt;/p&gt;\n&lt;p&gt;是鲸鱼？&lt;/p&gt;\n&lt;p&gt;还是一堆箱子？&lt;/p&gt;\n&lt;p&gt;或者说是载着箱子的鲸鱼？&lt;br&gt;\n这里小编不做解释，先引用一下官方的解释：&lt;/p&gt;\n&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;\n&lt;p&gt;顾名思义，docker是一个容器引擎，容器且不说，什么是引擎？&lt;/p&gt;\n&lt;p&gt;我们知道：&lt;/p&gt;\n&lt;p&gt;汽车的引擎是发动机，有了发动起，汽车才能跑起来&lt;/p&gt;\n&lt;p&gt;游戏需要游戏引擎（如Unity3D..），基于引擎的开发，能让游戏动起来。&lt;/p&gt;\n&lt;p&gt;如官言，docker也是一种引擎，基于这个引擎，开发者能让他们开发的应用处于一个有隔离性的、可移植性的容器中，以便于发布于各种机器中而无需考虑兼容性问题。&lt;/p&gt;\n&lt;p&gt;因此就不难解释，为什么docker的logo是一条装着一堆箱子的鲸鱼.&lt;/p&gt;\n&lt;p&gt;这是因为：docker扮演的是图中鲸鱼的角色，而鲸鱼之上的集装箱就是一个个容器，容器中是我们开发的应用程序（不仅限于web应用），每个容器都有自己独立的环境（环境设置、网络、文件系统…），互不干扰。而每个箱子，又可以打包成一个新的镜像，放到其它服务器的docker环境中直接运行，不再需要重复安装程序运行环境。&lt;/p&gt;\n&lt;p&gt;上面的解释插入了两个生疏的概念：&lt;/p&gt;\n&lt;p&gt;1、镜像&lt;/p&gt;\n&lt;p&gt;2、容器&lt;/p&gt;\n&lt;p&gt;我们先讲容器&lt;/p&gt;\n&lt;p&gt;容器，顾名思义：就是装东西的器皿，在docker中，容器就是装载我们的应用程序的器皿，在docker的logo中，容器就是一个个箱子。我们知道，运行JavaWeb应用程序需要有Tomcat，那么我们就需要创建一个Tomcat的容器，才能把我们的程序放进去运行。&lt;/p&gt;\n&lt;p&gt;那么，容器哪里来的呢&lt;/p&gt;\n&lt;p&gt;我们知道，给电脑安装Windows系统需要有Windows镜像，因此给docker安装容器也是需要镜像的，所以，通俗一点，镜像就类似于我们日常中的安装软件，甚至说是操作系统镜像更为形象点。&lt;/p&gt;\n&lt;p&gt;那容器和镜像有什么关系？&lt;/p&gt;\n&lt;p&gt;网上说是类和对象的关系，没错，但是这样的比喻没什么实际卵用。&lt;/p&gt;\n&lt;p&gt;我们知道:要运行一个web程序，需要有个Tomcat环境，需要Tomcat环境，那就下载一个Tomcat解压出来，然后把web程序放入Tomcat的webapps中启动即可，&lt;/p&gt;\n&lt;p&gt;那么在docker中要运行一个web程序，就需要有Tomcat容器，需要Tomcat容器，就得去下载Tomcat镜像（也可以自己构建），把镜像pull下来之后，运行起来，就是一个Tomcat容器，此时把web程序至于Tomcat挂载的数据目录webapps中既可以运行。&lt;/p&gt;\n&lt;p&gt;所以docker中，容器和镜像的关系更像是一种动静的关系，也就是说，存于仓库中的镜像是一个死的软件，而运行起来的容器则像是一个正在运行的程序（进程）。&lt;/p&gt;\n&lt;p&gt;2、Docker有什么用&lt;br&gt;\n对docker有了清晰的了解之后，我们心里可能在想： 这玩儿对我有什么用？ 我在哪里能用得上？ 怎么用才对？&lt;/p&gt;\n&lt;p&gt;这里引用几个案例来让大家体会体会。&lt;/p&gt;\n&lt;p&gt;1、案例一 前几天，公司一批服务器就要到期了，由于服务器是15年购买的，硬件的性能远比现在新出的云主机低，因此决定把所有服务器都换成新一代服务器，但是小编整准备动手迁移服务器时，内心一阵阵崩溃感涌上心头，仔细一算，每台服务器都要做同样的事情：&lt;/p&gt;\n&lt;p&gt;1、安装jdk、Tomcat、nginx 2、配置jdk环境变量和系统变量 3、配置Tomcat 4、配置nginx 5、安装项目所需的视频解码组件 6、导入项目所需的一些特殊字体&lt;/p&gt;\n&lt;p&gt;后来决定用docker部署的办法，在每台服务器都把docker安装之后，只需要在其中一台服务器中把Tomcat镜像从镜像仓库拉取下来，把这些配置都设置好，做成一个自己的镜像上传到镜像仓库中，之后在其他几台服务器都下载自己做的镜像，运行于docker中，把代码上传，就万事大吉了。&lt;/p&gt;\n&lt;p&gt;2、案例二&lt;/p&gt;\n&lt;p&gt;前不久的圣诞活动中，公司临时的活动方案在程序员的加班加点中终于上线，但是一上线之后发现推广海报中的中文名字乱码，领导问责测试人员怎么没做好测试，测试很委屈的说我已经测试无数遍并且测试报告都提交了，解决了所有问题才上线的；没办法只能让服务器同事查看正式服务器中的tomcat配置，发现原来 tomcat用了默认编码方式：iso8859-1，而测试环境中是UTF-8。针对这个问题，项目组决定把开发环境迁移到docker中，在测试环境中测试无误后，把镜像打包发布到正式环境中，解决了环境不同导致的问题。&lt;/p&gt;\n&lt;p&gt;3、docker的安装&lt;br&gt;\n感知到docker对我们开发者的好处之后，相信大家也跃跃欲试了吧，下面 就Linux centOS（版本大于等于7.0）系统进行演示docker的安装步骤：&lt;/p&gt;\n&lt;p&gt;1、删除可能存在的旧版本&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;1 sudo yum remove docker\n2 docker-client\n3 docker-client-latest\n4 docker-common\n5 docker-latest\n6 docker-latest-logrotate\n7 docker-logrotate\n8 docker-selinux\n9 docker-engine-selinux\n10 docker-engine\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;2、安装一些必备工具：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;yum install -y yum-utils device-mapper-persistent-data lvm2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;3、添加Docker源：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;yum-config-manager\n--add-repo\nhttps://download.docker.com/linux/centos/docker-ce.repo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;4、更新yum缓存&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;yum makecache fast\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;5、安装&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;yum install docker-ce\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;6、创建docker用户&lt;/p&gt;\n&lt;p&gt;温馨提示：以下操作不是必备，但是为了养成一个Linux用户的使用的良好习惯，小编不建议直接使用root操作，因此创建一个用户用来操作docker。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;useradd docker_manager\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;docker_manager是用户名，可以根据喜好起名，创建完用户之后，设置密码&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;passwd docker_manager\ndocker_manager_wsdt\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;会提示输入密码和确认密码,按照提示操作即可&lt;/p&gt;\n&lt;p&gt;7、配置docker用户的权限&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;visudo\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;visudo是配置用户权限的文件，在命令行中输入visudo回车之后，会进入文件操作，找到“# %wheel ALL=(ALL) NOPASSWD: ALL”这一行，把前面的“#”去掉，保存文件&lt;/p&gt;\n&lt;p&gt;8、授权&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;usermod -aG wheel,docker docker_manager\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;9、启动 Docker CE&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt; sudo systemctl enable docker\n sudo systemctl start docker\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;此时在命令行中输入“docker info”之后，能够展示docker相关信息，就表示docker安装成功。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker info\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;10、镜像加速：&lt;/p&gt;\n&lt;p&gt;编辑daemon.json文件（首次安装daemon.json是个新文件，不要惊讶）&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;vim /etc/docker/daemon.json\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;加入以下内容：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;    {\n        &amp;quot;registry-mirrors&amp;quot;: [\n            &amp;quot;https://registry.docker-cn.com&amp;quot;\n        ]\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;保存，sudo systemctl restart docker重启即可。&lt;/p&gt;\n&lt;p&gt;4、总结&lt;br&gt;\n上面针对docker使用了一种比较通俗诙谐的语言来讲述，也是为了方便读者能容易的解读和理解，理解并且成功安装docker之后，你们就会想方设法的要把自己的web项目部署到docker了，这我没说错吧，大家可以网上查找一些资料去学习这一块。&lt;/p&gt;\n&lt;p&gt;学习转载：https://www.cnblogs.com/myprogramer/p/10288634.html&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-de-an-zhuang-yu-shi-yong&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;docker的安装与使用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;docker&#34;,&#34;slug&#34;:&#34;r0XBmVMNv&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/r0XBmVMNv&#34;},{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-07-14 20:14:24&#34;,&#34;dateFormat&#34;:&#34;2021-07-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/docker-de-an-zhuang-yu-shi-yong&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:526000,&#34;words&#34;:2414,&#34;minutes&#34;:9},&#34;description&#34;:&#34;docker中文文档\n最近Docker突然火得不得了，到处都是谈论Docker的声音，相信大家和小编一样的心情，看这个东西有点高大上，但尝试去阅读Docker文章时又发现概念很模糊、不接地气、难以理解、无从下手…于是三天打鱼两天晒网，最终不...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。&lt;/p&gt;\n&lt;p&gt;util.inherits&lt;br&gt;\nutil.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。&lt;/p&gt;\n&lt;p&gt;JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。&lt;/p&gt;\n&lt;p&gt;在这里我们只介绍util.inherits 的用法，示例如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;var util = require(&#39;util&#39;); \nfunction Base() { \n    this.name = &#39;base&#39;; \n    this.base = 1991; \n    this.sayHello = function() { \n    console.log(&#39;Hello &#39; + this.name); \n    }; \n} \nBase.prototype.showName = function() { \n    console.log(this.name);\n}; \nfunction Sub() { \n    this.name = &#39;sub&#39;; \n} \nutil.inherits(Sub, Base); \nvar objBase = new Base(); \nobjBase.showName(); \nobjBase.sayHello(); \nconsole.log(objBase); \nvar objSub = new Sub(); \nobjSub.showName(); \n//objSub.sayHello(); \nconsole.log(objSub);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;base \nHello base \n{ name: &#39;base&#39;, base: 1991, sayHello: [Function] } \nsub \n{ name: &#39;sub&#39; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。&lt;/p&gt;\n&lt;p&gt;同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;node.js:201 \nthrow e; // process.nextTick error, or &#39;error&#39; event on first tick \n^ \nTypeError: Object #&amp;lt;Sub&amp;gt; has no method &#39;sayHello&#39; \nat Object.&amp;lt;anonymous&amp;gt; (/home/byvoid/utilinherits.js:29:8) \nat Module._compile (module.js:441:26) \nat Object..js (module.js:459:10) \nat Module.load (module.js:348:31) \nat Function._load (module.js:308:12) \nat Array.0 (module.js:479:10) \nat EventEmitter._tickCallback (node.js:192:40)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;转载自https://www.cnblogs.com/yuwenjing0727/p/8135608.html&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;nodejs-chang-yong-gong-ju-utilinherits&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Node.js 常用工具 （util.inherits）&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-06-13 21:27:23&#34;,&#34;dateFormat&#34;:&#34;2021-06-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/nodejs-chang-yong-gong-ju-utilinherits&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:118000,&#34;words&#34;:429,&#34;minutes&#34;:2},&#34;description&#34;:&#34;util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。\nutil.inherits\nutil.inherits(constructor, superConstructor)是...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;nuxt分spa和非spa，预渲染直接nuxt generate打好的静态页面放在服务器就能访问(也是服务端渲染)， 服务端渲染需要先build完，把打出来的项目放到服务器，然后允许start，还要配置nginx转发&lt;br&gt;\n使用nuxt的服务端渲染插件在node中可以直接返回&lt;br&gt;\n预渲染不像服务器渲染那样即时编译 HTML，它只在构建时为了特定的路由生成特定的几个静态页面，等于我们可以通过 Webpack 插件将一些特定页面组件 build 时就编译为 html 文件，直接以静态资源的形式输出给搜索引擎。预渲染不执行js的，只适应于纯静态页面&lt;br&gt;\n先说结论，都必然会优化SEO，原因如下：&lt;/p&gt;\n&lt;p&gt;1、seo的本质是爬虫动态抓取根html里面的关键标签关键字；&lt;br&gt;\n2、现代主流前端开发框架基本都是html拉回来之后，异步执行js动态挂载dom，根html在渲染之前里面提供给爬虫的信息极少；&lt;/p&gt;\n&lt;p&gt;综上，如果不做服务器渲染或预渲染，seo只能抓到手动配置的顶级标签的关键字，效率与效果非常差&lt;br&gt;\n不论是服务器渲染还是预渲染，它们都能“加速浏览器显示页面的速度”和seo优化。首先客户端程序只有js。现代网页出现以后这些js程度越来越复杂，于是必须有一些类似react、angular这样的东西。但这些东西全都有一个问题：第一次渲染结束前，页面是白的。于是有了服务端渲染：如果服务器恰好是nodejs，那么可以让服务器提前运行“第一次渲染”。浏览器只需要显示就好了，如果需要，再进行以后的渲染。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;nuxt-fu-wu-duan-xuan-ran-he-yu-xuan-ran-de-qu-bie&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;nuxt 服务端渲染和预渲染的区别&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ssr&#34;,&#34;slug&#34;:&#34;t5kOXmKL1&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/t5kOXmKL1&#34;},{&#34;name&#34;:&#34;nuxt&#34;,&#34;slug&#34;:&#34;9_NS-0FCYj&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/9_NS-0FCYj&#34;}],&#34;date&#34;:&#34;2021-06-02 19:38:15&#34;,&#34;dateFormat&#34;:&#34;2021-06-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/nuxt-fu-wu-duan-xuan-ran-he-yu-xuan-ran-de-qu-bie&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:100000,&#34;words&#34;:479,&#34;minutes&#34;:2},&#34;description&#34;:&#34;nuxt分spa和非spa，预渲染直接nuxt generate打好的静态页面放在服务器就能访问(也是服务端渲染)， 服务端渲染需要先build完，把打出来的项目放到服务器，然后允许start，还要配置nginx转发\n使用nuxt的服务端渲...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;a href=\&#34;https://www.sequelize.com.cn/\&#34;&gt;Sequelize 中文文档&lt;/a&gt;&lt;br&gt;\n可以先看文档，文档很全，它的语句帮我们做了很多处理，而且很精简，让我们不用死记硬背sql语句，也不用去库里建表。&lt;/p&gt;\n&lt;h3 id=\&#34;连接数据库\&#34;&gt;连接数据库&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;连接到数据库\n要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将连接参数分别传递到 Sequelize 构造函数或通过传递一个连接 URI 来完成：\n\nconst { Sequelize } = require(&#39;sequelize&#39;);\n\n// 方法 1: 传递一个连接 URI\nconst sequelize = new Sequelize(&#39;sqlite::memory:&#39;) // Sqlite 示例\nconst sequelize = new Sequelize(&#39;postgres://user:pass@example.com:5432/dbname&#39;) // Postgres 示例\n\n// 方法 2: 分别传递参数 (sqlite)\nconst sequelize = new Sequelize({\n  dialect: &#39;sqlite&#39;,\n  storage: &#39;path/to/database.sqlite&#39;\n});\n\n// 方法 3: 分别传递参数 (其它数据库)\nconst sequelize = new Sequelize(&#39;database&#39;, &#39;username&#39;, &#39;password&#39;, {\n  host: &#39;localhost&#39;,\n  dialect: /* 选择 &#39;mysql&#39; | &#39;mariadb&#39; | &#39;postgres&#39; | &#39;mssql&#39; 其一 */\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;定义模型-定义表结构\&#34;&gt;定义模型 （定义表结构）&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;module.exports = function(sequelize, DataTypes) {\n  return sequelize.define(\n    &#39;project&#39;,\n    {\n      id: {\n        type: DataTypes.INTEGER(11),\n        allowNull: false,\n        primaryKey: true,\n        autoIncrement: true\n      },\n      name: { type: DataTypes.STRING(255), allowNull: true },\n      title: { type: DataTypes.STRING(255), allowNull: true },\n      report_fix_id: { type: DataTypes.STRING(1000), allowNull: true },\n      fix_url: { type: DataTypes.STRING(2000), allowNull: true },\n      ignore_key: {\n        type: DataTypes.STRING(2000),\n        allowNull: true,\n        comment: &#39;简化打印对象中比较大的对象&#39;\n      },\n      env: {\n        type: DataTypes.STRING(255),\n        allowNull: true,\n        comment: &#39;哪些环境能上报日志&#39;\n      },\n      report_interval: {\n        type: DataTypes.INTEGER(11),\n        allowNull: true,\n        comment: &#39;上报时间间隔&#39;\n      },\n      ctime: {\n        type: DataTypes.INTEGER(10),\n        allowNull: true,\n        get() {\n          return moment\n            .unix(this.getDataValue(&#39;ctime&#39;))\n            .format(&#39;YYYY/MM/DD HH:mm:ss&#39;)\n        }\n      },\n      del: { type: DataTypes.INTEGER(1), allowNull: true, defaultValue: &#39;0&#39; }\n    },\n    {\n      tableName: &#39;project&#39;\n    }\n  )\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;模型同步-真正从数据库创建\&#34;&gt;模型同步 （真正从数据库创建）&lt;/h3&gt;\n&lt;p&gt;定义模型时,你要告诉 Sequelize 有关数据库中表的一些信息. 但是,如果该表实际上不存在于数据库中怎么办？ 如果存在,但具有不同的列,较少的列或任何其他差异,该怎么办？&lt;/p&gt;\n&lt;p&gt;这就是模型同步的来源.可以通过调用一个异步函数(返回一个Promise)model.sync(options). 通过此调用,Sequelize 将自动对数据库执行 SQL 查询. 请注意,这仅更改数据库中的表,而不更改 JavaScript 端的模型.&lt;/p&gt;\n&lt;p&gt;User.sync() - 如果表不存在,则创建该表(如果已经存在,则不执行任何操作)&lt;/p&gt;\n&lt;h4 id=\&#34;usersync-force-true-将创建表如果表已经存在则将其首先删除-这个不要用也最好别试\&#34;&gt;User.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除 （这个不要用，也最好别试）&lt;/h4&gt;\n&lt;p&gt;User.sync({ alter: true }) - 这将检查数据库中表的当前状态(它具有哪些列,它们的数据类型等),然后在表中进行必要的更改以使其与模型匹配.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;sequelize\n  .authenticate()\n  .then(() =&amp;gt; {\n    console.log(&#39;数据库连接成功&#39;.green)\n    // sequelize.sync({ alter: true })\n  })\n  .catch(err =&amp;gt; {\n    console.log(&#39;数据库连接失败&#39;.red)\n  })\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;创建实例修改内容insert\&#34;&gt;创建实例（修改内容INSERT）&lt;/h3&gt;\n&lt;p&gt;尽管模型是一个类,但是你不应直接使用 new 运算符来创建实例. 相反,应该使用 build 方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const jane = User.build({ name: &amp;quot;Jane&amp;quot; });\nconsole.log(jane instanceof User); // true\nconsole.log(jane.name); // &amp;quot;Jane&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是,以上代码根本无法与数据库通信(请注意,它甚至不是异步的)！ 这是因为 build 方法仅创建一个对象,该对象 表示 可以 映射到数据库的数据. 为了将这个实例真正保存(即持久保存)在数据库中,应使用 save 方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;await jane.save();\nconsole.log(&#39;Jane 已保存到数据库!&#39;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;请注意,从上面代码段中的 await 用法来看,save 是一种异步方法. 实际上,几乎每个 Sequelize 方法都是异步的. build 是极少数例外之一.&lt;/p&gt;\n&lt;p&gt;非常有用的捷径: create 方法&lt;br&gt;\nSequelize提供了 create 方法,该方法将上述的 build 方法和 save 方法合并为一个方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const jane = await User.create({ name: &amp;quot;Jane&amp;quot; });\n// Jane 现在存在于数据库中！\nconsole.log(jane instanceof User); // true\nconsole.log(jane.name); // &amp;quot;Jane&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;简单-select-查询\&#34;&gt;简单 SELECT 查询&lt;/h3&gt;\n&lt;p&gt;你可以使用 findAll 方法从数据库中读取整个表：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;// 查询所有用户\nconst users = await User.findAll();\nconsole.log(users.every(user =&amp;gt; user instanceof User)); // true\nconsole.log(&amp;quot;All users:&amp;quot;, JSON.stringify(users, null, 2));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;相当于sql语句&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;SELECT * FROM ...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;嗯，写一些建表与查询的流程，照着官网抄也没什么意思。使用这个我们可以很轻松的操作数据库，使我们写node接口的时候效率翻倍～&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;sequelize-node-lian-jie-shu-ju-ku-de-orm&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Sequelize node连接数据库的ORM&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-05-20 20:36:06&#34;,&#34;dateFormat&#34;:&#34;2021-05-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:257000,&#34;words&#34;:1033,&#34;minutes&#34;:5},&#34;description&#34;:&#34;Sequelize 中文文档\n可以先看文档，文档很全，它的语句帮我们做了很多处理，而且很精简，让我们不用死记硬背sql语句，也不用去库里建表。\n连接数据库\n连接到数据库\n要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93\&#34;&gt;连接数据库&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B-%E5%AE%9A%E4%B9%89%E8%A1%A8%E7%BB%93%E6%9E%84\&#34;&gt;定义模型 （定义表结构）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A8%A1%E5%9E%8B%E5%90%8C%E6%AD%A5-%E7%9C%9F%E6%AD%A3%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA\&#34;&gt;模型同步 （真正从数据库创建）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#usersync-force-true-%E5%B0%86%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%A6%82%E6%9E%9C%E8%A1%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E5%88%99%E5%B0%86%E5%85%B6%E9%A6%96%E5%85%88%E5%88%A0%E9%99%A4-%E8%BF%99%E4%B8%AA%E4%B8%8D%E8%A6%81%E7%94%A8%E4%B9%9F%E6%9C%80%E5%A5%BD%E5%88%AB%E8%AF%95\&#34;&gt;User.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除 （这个不要用，也最好别试）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9insert\&#34;&gt;创建实例（修改内容INSERT）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E5%8D%95-select-%E6%9F%A5%E8%AF%A2\&#34;&gt;简单 SELECT 查询&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;?&lt;/mo&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;否&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;标&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;志&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;如&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;果&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;成&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;功&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;则&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;? 是上一个程序执行是否成功的标志，如果执行成功则&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.69444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;?&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;是&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;上&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;一&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;个&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;程&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;序&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;执&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;行&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;是&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;否&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;成&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;功&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;标&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;志&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;，&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;如&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;果&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;执&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;行&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;成&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;功&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;? 为0，否则 不为0。&lt;br&gt;\n比如判断一个node服务是该启动还是该重启，则可以执行pm2 info ***&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1644843836198.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;shell-dollar-huo-qu-han-shu-fan-hui-zhi-huo-zhe-shang-yi-ge-ming-ling-de-tui-chu-zhuang-tai&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;shell $? 获取函数返回值或者上一个命令的退出状态&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;shell&#34;,&#34;slug&#34;:&#34;qt4i7BiKQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/qt4i7BiKQ&#34;}],&#34;date&#34;:&#34;2021-05-17 18:08:58&#34;,&#34;dateFormat&#34;:&#34;2021-05-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/shell-dollar-huo-qu-han-shu-fan-hui-zhi-huo-zhe-shang-yi-ge-ming-ling-de-tui-chu-zhuang-tai&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:20000,&#34;words&#34;:98,&#34;minutes&#34;:1},&#34;description&#34;:&#34;?是上一个程序执行是否成功的标志，如果执行成功则? 是上一个程序执行是否成功的标志，如果执行成功则?是上一个程序执行是否成功的标志，如果执行成功则? 为0，否则 不为0。\n比如判断一个node服务是该启动还是该重启，则可以执行pm2 inf...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;项目中频繁使用Redis，为了不用每次打开Redis目录去启动Redis想到了Docker可以作为Redis的容器 直接下载使用就行 把Docker使用Redis的过程分享下：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;拉取redis    （如果想直接运行也可以直接执行第二步省略第一步）\n   docker pull redis\n\n   拉取完成后可使用 docker images 查看镜像列表检查\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;后台运行redis server\n   \n   docker run --name redis-test -p 6379:6379 -d redis\n   或者 docker run --name redis-test -p 6379:6379  --rm -d redis\n\n   -d表示后台运行 \n   -p表示本机端口映射到运行的容积端口  第一个是本机端口 第二个是容器端口\n   --rm表示用完自动删除 容器停止运行后自动删除  一般不用\n   --name表示指定名称 之后会用到\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt; 客户端连接redis \n   \n   docker run -it --rm  redis redis-cli -h 192.168.1.99\n   或者 完整 docker run -it --rm redis redis-cli -h 192.168.1.99 -p 6379 -a 123123\n   \n   -it表示运行后进入容器内部命令模式\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;启动已关闭的redis服务\n   步骤二指定了redis的名称为redis-test 执行命令 redis start redis-test 启动redis服务\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;不小心关掉了正在连接的客户端界面redis-cli \n  - 查找当前运行的容器 docker ps  \n  - 直接进入容器中 docker attach 容器标识\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;删除容器\n   - docker rm [containerName||ID] 或者强制删除加-f参数\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;推荐一个好用的redis可视化软件，免费的，“Another Redis Desktop Manager” 地址：https://github.com/qishibo/AnotherRedisDesktopManager/&lt;/p&gt;\n&lt;!-- more --&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-zhong-shi-yong-redis&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;项目中频繁使用Redis，为了不用每次打开Redis目录去启动Redis想到了Docker可以作为Redis的容器 直接下载使用就行 把Docker使用Redis的过程分享下：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;拉取redis    （如果想直接运行也可以直接执行第二步省略第一步）\n   docker pull redis\n\n   拉取完成后可使用 docker images 查看镜像列表检查\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;后台运行redis server\n   \n   docker run --name redis-test -p 6379:6379 -d redis\n   或者 docker run --name redis-test -p 6379:6379  --rm -d redis\n\n   -d表示后台运行 \n   -p表示本机端口映射到运行的容积端口  第一个是本机端口 第二个是容器端口\n   --rm表示用完自动删除 容器停止运行后自动删除  一般不用\n   --name表示指定名称 之后会用到\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt; 客户端连接redis \n   \n   docker run -it --rm  redis redis-cli -h 192.168.1.99\n   或者 完整 docker run -it --rm redis redis-cli -h 192.168.1.99 -p 6379 -a 123123\n   \n   -it表示运行后进入容器内部命令模式\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;启动已关闭的redis服务\n   步骤二指定了redis的名称为redis-test 执行命令 redis start redis-test 启动redis服务\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;不小心关掉了正在连接的客户端界面redis-cli \n  - 查找当前运行的容器 docker ps  \n  - 直接进入容器中 docker attach 容器标识\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;pre&gt;&lt;code&gt;删除容器\n   - docker rm [containerName||ID] 或者强制删除加-f参数\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;推荐一个好用的redis可视化软件，免费的，“Another Redis Desktop Manager” 地址：https://github.com/qishibo/AnotherRedisDesktopManager/&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;docker中使用redis&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;redis&#34;,&#34;slug&#34;:&#34;54JMWgB6H&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/54JMWgB6H&#34;},{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-04-21 21:08:41&#34;,&#34;dateFormat&#34;:&#34;2021-04-21&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/docker-zhong-shi-yong-redis&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:91000,&#34;words&#34;:376,&#34;minutes&#34;:2},&#34;description&#34;:&#34;项目中频繁使用Redis，为了不用每次打开Redis目录去启动Redis想到了Docker可以作为Redis的容器 直接下载使用就行 把Docker使用Redis的过程分享下：\n\n\n拉取redis    （如果想直接运行也可以直接执行第二步...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;作用：时间戳转化个格式&lt;/p&gt;\n&lt;p&gt;原因：数据库中为了快速查询，一般保持日期是int(1415873634479),但是这样查询的时候很难知道确切的日期&lt;/p&gt;\n&lt;p&gt;格式：select from_unixtime(1459338786);2016-03-30 19:53:06&lt;/p&gt;\n&lt;p&gt;select from_unixtime(1459338786, &#39;%Y-%m-%d %H:%i:%s&#39;);2016-03-30 19:53:06&lt;/p&gt;\n&lt;p&gt;SELECT id ,FROM_UNIXTIME(&#39;last_update_time&#39;) FROM current_inventory WHERE seat_code = &#39;hk2-i0302c03&#39; //字段要加引号&lt;/p&gt;\n&lt;p&gt;备注：默认转化格式是%Y-%m-%d %H:%i:%s&lt;/p&gt;\n&lt;p&gt;格式说明：&lt;/p&gt;\n&lt;p&gt;%M 月名字(January～December)&lt;br&gt;\n%W 星期名字(Sunday～Saturday)&lt;br&gt;\n%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。）&lt;br&gt;\n%Y 年, 数字, 4 位&lt;br&gt;\n%y 年, 数字, 2 位&lt;br&gt;\n%a 缩写的星期名字(Sun～Sat)&lt;br&gt;\n%d 月份中的天数, 数字(00～31)&lt;br&gt;\n%e 月份中的天数, 数字(0～31)&lt;br&gt;\n%m 月, 数字(01～12)&lt;br&gt;\n%c 月, 数字(1～12)&lt;br&gt;\n%b 缩写的月份名字(Jan～Dec)&lt;br&gt;\n%j 一年中的天数(001～366)&lt;br&gt;\n%H 小时(00～23)&lt;br&gt;\n%k 小时(0～23)&lt;br&gt;\n%h 小时(01～12)&lt;br&gt;\n%I 小时(01～12)&lt;br&gt;\n%l 小时(1～12)&lt;br&gt;\n%i 分钟, 数字(00～59)&lt;br&gt;\n%r 时间,12 小时(hh:mm:ss [AP]M)&lt;br&gt;\n%T 时间,24 小时(hh:mm:ss)&lt;br&gt;\n%S 秒(00～59)&lt;br&gt;\n%s 秒(00～59)&lt;br&gt;\n%p AM或PM&lt;br&gt;\n%w 一个星期中的天数(0=Sunday ～6=Saturday ）&lt;br&gt;\n%U 星期(0～52), 这里星期天是星期的第一天&lt;br&gt;\n%u 星期(0～52), 这里星期一是星期的第一天&lt;br&gt;\n%% 一个文字%&lt;/p&gt;\n&lt;p&gt;原文链接：https://blog.csdn.net/yangliu4683/article/details/78340939&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;wo-shi-ce-shi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;mysql 时间戳格式化函数from_unixtime&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-04-06 11:01:44&#34;,&#34;dateFormat&#34;:&#34;2021-04-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/wo-shi-ce-shi&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:91000,&#34;words&#34;:341,&#34;minutes&#34;:2},&#34;description&#34;:&#34;作用：时间戳转化个格式\n原因：数据库中为了快速查询，一般保持日期是int(1415873634479),但是这样查询的时候很难知道确切的日期\n格式：select from_unixtime(1459338786);2016-03-30 19...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;pre&gt;&lt;code class=\&#34;language-nginx\&#34;&gt;server {\n  listen 9003;\n  server_name *****.com;\n  index index.html index.htm;\n  location / {\n    proxy_pass http://127.0.0.1:4001;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-for $remote_addr;\n    proxy_set_header X-Forwarded-Proto $scheme;\n    proxy_set_header X-Forwarded-Port $server_port;\n    proxy_connect_timeout 300;\n\n    # 指定允许跨域的方法，*代表所有\n    add_header Access-Control-Allow-Methods *;\n\n    # 预检命令的缓存，如果不缓存每次会发送两次请求\n    add_header Access-Control-Max-Age 3600;\n\n    # 带cookie请求需要加上这个字段，并设置为true\n    add_header Access-Control-Allow-Credentials true;\n\n    # 表示允许这个域跨域调用（客户端发送请求的域名和端口）\n    # $http_origin动态获取请求客户端请求的域   不用*的原因是带cookie的请求不支持*号\n    add_header Access-Control-Allow-Origin $http_origin;\n\n    # 表示请求头的字段 动态获取\n    add_header Access-Control-Allow-Headers $http_access_control_request_headers;\n\n    # OPTIONS预检命令，预检命令通过时才发送请求\n    # 检查请求的类型是不是预检命令\n    if ($request_method = OPTIONS){\n      return 200;\n    }\n\n  }\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;nginx-dai-cookie-yun-xu-kua-yu-pei-zhi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;nginx带cookie允许跨域配置&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;nginx&#34;,&#34;slug&#34;:&#34;lUaTxyOe3&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lUaTxyOe3&#34;},{&#34;name&#34;:&#34;服务端&#34;,&#34;slug&#34;:&#34;lTeQHqjnC&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/lTeQHqjnC&#34;}],&#34;date&#34;:&#34;2021-02-10 19:11:56&#34;,&#34;dateFormat&#34;:&#34;2021-02-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/nginx-dai-cookie-yun-xu-kua-yu-pei-zhi&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:59000,&#34;words&#34;:224,&#34;minutes&#34;:1},&#34;description&#34;:&#34;server {\n  listen 9003;\n  server_name *****.com;\n  index index.html index.htm;\n  location / {\n    proxy_pass http://127....&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;强制commit规范常用的有两种，一种是在package项目中的gitHooks选项下的&amp;quot;commit-msg&amp;quot;设置自己的commit规则脚本。比如我要强制commit内容为feat:加空格xxx或者fix:加空格xxx，如果不符合给出相应提示，则我应该这么写：&lt;br&gt;\n&lt;img src=\&#34;https://note.youdao.com/yws/public/resource/d60e09a825bba46e1719f2dc06a2f7e3/xmlnote/302F691AA217499EA4DC783EA5E361B8/3538\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\nverify-commit-msg.js中代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;const chalk = require(&amp;quot;chalk&amp;quot;);\nconst msgPath = process.env.GIT_PARAMS;\nconst msg = require(&amp;quot;fs&amp;quot;)\n  .readFileSync(msgPath, &amp;quot;utf-8&amp;quot;)\n  .trim();\n\nconst commitRE = /^(revert: )?(feat|fix|polish|docs|style|refactor|perf|test|workflow|ci|chore|types|build|Merge)(\\(.+\\))?: .{1,50}|Merge /;\n\nif (!commitRE.test(msg)) {\n  console.error(\n    `  ${chalk.bgRed.white(&amp;quot; ERROR &amp;quot;)} ${chalk.red(\n      `invalid commit message format.`\n    )}\\n\\n` +\n      chalk.red(\n        `  Proper commit message format is required for automated changelog generation. Examples:\\n\\n`\n      ) +\n      `    ${chalk.green(`feat: add &#39;comments&#39; option`)}\\n` +\n      `    ${chalk.green(`fix: handle events on blur (close #28)`)}\\n\\n` +\n      chalk.red(\n        `  You can also use ${chalk.cyan(\n          `yarn commit`\n        )} to interactively generate a commit message.\\n`\n      )\n  );\n  process.exit(1);\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;另一种是也可以使用&lt;a href=\&#34;https://www.npmjs.com/package/git-cz/v/4.2.0\&#34;&gt;git-cz&lt;/a&gt; 通过交互的方式生成更专业的commit，效果如下&lt;br&gt;\n&lt;img src=\&#34;https://weidadeda.github.io/post-images/1642390440510.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;hello-gridea&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;如何自定义commit规范&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;工程化&#34;,&#34;slug&#34;:&#34;_l9fydARk&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/_l9fydARk&#34;},{&#34;name&#34;:&#34;commit规范&#34;,&#34;slug&#34;:&#34;Z8QV8E2Pt&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/Z8QV8E2Pt&#34;}],&#34;date&#34;:&#34;2020-10-23 21:00:00&#34;,&#34;dateFormat&#34;:&#34;2020-10-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/hello-gridea&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:69000,&#34;words&#34;:229,&#34;minutes&#34;:2},&#34;description&#34;:&#34;强制commit规范常用的有两种，一种是在package项目中的gitHooks选项下的&amp;quot;commit-msg&amp;quot;设置自己的commit规则脚本。比如我要强制commit内容为feat:加空格xxx或者fix:加空格xxx...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;一个对象没有某些属性和方法，另一个对象有，拿过来使用，就是继承&lt;/p&gt;\n&lt;h3 id=\&#34;继承的实现方式\&#34;&gt;继承的实现方式&lt;/h3&gt;\n&lt;h4 id=\&#34;混入式继承\&#34;&gt;混入式继承&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;var obj = {};\nvar obj1 = {\n    money : 10000000,\n    car : 100,\n    brand: &amp;quot;布加迪威航&amp;quot;,\n    huaqian: function(){\n        console.log(&amp;quot;不差钱，随便花&amp;quot;);\n    }\n};\nconsole.log(obj);\nfor(var k in obj1){\n    //money\n    //car\n    //brand\n    //huaqian\n    obj[k] = obj1[k];\n}\n\nconsole.log(obj);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;原型继承的方式\&#34;&gt;原型继承的方式&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;通过修改原型实现的继承 就是原型继承&lt;/li&gt;\n&lt;li&gt;通过构造函数创建出来的对象继承自构造函数的原型对象&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;//Person.prototype\nvar human = {\n    gender:&amp;quot;female&amp;quot;,\n    height: 170,\n    weight: 50\n}\nfunction Person(){\n}\nPerson.prototype.name = &amp;quot;王莉莉&amp;quot;;\n\nfor(var k in human){\n    Person.prototype[k] = human[k];\n}\nvar p = new Person();\nconsole.log(p.name,p.gender,p.height,p.weight);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;修改原型对象&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;Person.prototype.maimeng = function (){\n    console.log(&amp;quot;感觉自己萌萌哒&amp;quot;);\n}\n\np.maimeng();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;替换原型对象&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;Person.prototype = human;\nvar p = new Person();\nconsole.log(p.gender);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;经典继承\&#34;&gt;经典继承&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;调用一个方法，就能实现继承&lt;/li&gt;\n&lt;li&gt;var obj1 = Object.create(obj)&lt;/li&gt;\n&lt;li&gt;创建出来一个新的继承自参数 obj 的对象 obj1&lt;/li&gt;\n&lt;li&gt;其实内部使用的就是原型继承&lt;/li&gt;\n&lt;li&gt;ES5才支持的这个方法 需要考虑兼容性问题&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;var human = {\n    name: &amp;quot;王莉莉&amp;quot;,\n    gender: &amp;quot;female&amp;quot;,\n    dance :function(){\n        console.log(&amp;quot;二人转，转转转&amp;quot;)\n    }\n}\nvar obj = Object.create(human);\n\nconsole.log(obj);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;处理经典继承的兼容性问题\&#34;&gt;处理经典继承的兼容性问题&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;if(Object.create){\n    var obj = Object.create({name:&amp;quot;李狗二&amp;quot;,age:18});\n}else{\n    Object.create = function(obj){\n\t\t//在这个函数中要实现的功能\n\t\t//就是，创建一个对象，将obj设置为该对象的原型\n\n\t\t//要设置原型，只能通过两种方式，\n\t\t// 一种是 对象.__proto__  另外一种是 构造函数.prototype\n\t\t//由于__proto__这个属性有兼容性问题，所以不使用\n\t\t//就只能使用 构造函数.prototype 去替换原型对象了\n\n        function F(){}\n        F.prototype = obj;\n        var result = new F();\n        return result;\n    }\n}\n\n//不推荐直接修改内置对象，因为在多人开发的时候，会产生冲突\n\nObject.creat = function () {\n    console.log(&amp;quot;我是李二狗，我的create方法就是用来输出这句话的，哈哈哈&amp;quot;);\n}\n\nfunction hanyingxinCreate(obj){\n    if(Object.create){\n        return Object.creat(obj);\n    }else{\n        function F(){}\n        F.prototype = obj;\n        var result = new F();\n        return result;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;内容转载自：https://blog.ihoey.com/posts/javascript/2016-06-15-javascript-inherit.html&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;js-dui-xiang-ji-cheng&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;js对象继承&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;js&#34;,&#34;slug&#34;:&#34;3uoOai8za&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/3uoOai8za&#34;}],&#34;date&#34;:&#34;2020-01-16 15:21:48&#34;,&#34;dateFormat&#34;:&#34;2020-01-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/js-dui-xiang-ji-cheng&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:147000,&#34;words&#34;:558,&#34;minutes&#34;:3},&#34;description&#34;:&#34;一个对象没有某些属性和方法，另一个对象有，拿过来使用，就是继承\n继承的实现方式\n混入式继承\nvar obj = {};\nvar obj1 = {\n    money : 10000000,\n    car : 100,\n    brand:...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\&#34;&gt;继承的实现方式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B7%B7%E5%85%A5%E5%BC%8F%E7%BB%A7%E6%89%BF\&#34;&gt;混入式继承&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F\&#34;&gt;原型继承的方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%8F%E5%85%B8%E7%BB%A7%E6%89%BF\&#34;&gt;经典继承&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%84%E7%90%86%E7%BB%8F%E5%85%B8%E7%BB%A7%E6%89%BF%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98\&#34;&gt;处理经典继承的兼容性问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;prototype显示原型是类的原型指向该方法的原型对象-proto隐式原型是对象的原型指向该对象的构造函数的原型对象\&#34;&gt;prototype（显示原型）是“类”的原型，指向该方法的原型对象。&lt;strong&gt;proto&lt;/strong&gt;（隐式原型）是对象的原型，指向该对象的构造函数的原型对象。&lt;/h3&gt;\n&lt;p&gt;JS当然没有“类”，只有constructor。&lt;br&gt;\nconstructor就是当你new fn()时的那个“fn”。&lt;br&gt;\nfn的时候，产生的实例的__proto__指向fn.prototype，两者是同一个东西。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;function Foo(){}\nvar foo = new Foo()\nFoo.prototype.__proto__ === Object.prototype //true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;prototype：每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;proto&lt;/strong&gt;：JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过__proto__来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf().&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Note: Object.prototype 这个对象是个例外，它的__proto__值为null&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;隐式原型指向创建这个对象的函数constructor的prototype\&#34;&gt;隐式原型指向创建这个对象的函数(constructor)的prototype&lt;/h4&gt;\n&lt;p&gt;__proto__的指向到底如何判断呢？根据ECMA定义 &#39;to the value of its constructor’s &amp;quot;prototype&amp;quot; &#39; ----指向创建这个对象的函数（也就是构造函数）的显式原型。所以关键的点在于找到创建这个对象的构造函数，接下来就来看一下JS中对象被创建的方式，一眼看过去似乎有三种方式：（1）对象字面量的方式 （2）new 的方式 （3）ES5中的Object.create() 但是我认为本质上只有一种方式，也就是通过new来创建。为什么这么说呢，首先字面量的方式是一种为了开发人员更方便创建对象的一个语法糖，本质就是 var o = new Object(); o.xx = xx;o.yy=yy; 再来看看Object.create(),这是ES5中新增的方法，在这之前这被称为原型式继承。&lt;/p&gt;\n&lt;p&gt;下面看几个例子练习一下：&lt;/p&gt;\n&lt;p&gt;内建对象(built-in object)：比如Array()，Array.prototype.__proto__指向什么？Array.prototype也是一个对象，对象就是由 Object() 这个构造函数创建的，因此Array.prototype.&lt;strong&gt;proto&lt;/strong&gt; === Object.prototype //true，或者也可以这么理解，所有的内建对象都是由Object()创建而来。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;自定义对象&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;function Foo(){}\nvar foo = new Foo()\nFoo.prototype.__proto__ === Object.prototype //true 理由同上\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;//这时我们想让Foo继承Bar\nfunction Bar(){}\nFoo.prototype = new Bar()\n Foo.prototype.__proto__ === Bar.prototype //true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;//我们不想让Foo继承谁，但是我们要自己重新定义Foo.prototype\nFoo.prototype = {\n  a:10,\n  b:-10\n}\n//这种方式就是用了对象字面量的方式来创建一个对象，根据前文所述 \nFoo.prototype.__proto__ === Object.prototype\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;以上情况都等于完全重写了Foo.prototype，所以Foo.prototype.constructor也跟着改变了，于是乎constructor这个属性和原来的构造函数Foo（）也就切断了联系。&lt;/p&gt;\n&lt;h4 id=\&#34;此外\&#34;&gt;此外：&lt;/h4&gt;\n&lt;p&gt;构造函数Foo()除了是方法，也是对象啊，它也有__proto__属性，指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。其实除了Foo()，Function(), Object()也是一样的道理。原型对象也是对象啊，它的__proto__属性，又指向谁呢？同理，指向它的构造函数的原型对象呗。这里是Object.prototype.最后，Object.prototype的__proto__属性指向null。&lt;/p&gt;\n&lt;h4 id=\&#34;构造函数的隐式原型\&#34;&gt;构造函数的隐式原型&lt;/h4&gt;\n&lt;p&gt;既然是构造函数那么它就是Function（）的实例，因此也就指向Function.prototype,比如 Object.&lt;strong&gt;proto&lt;/strong&gt; === Function.prototype&lt;/p&gt;\n&lt;h3 id=\&#34;instanceof\&#34;&gt;instanceof&lt;/h3&gt;\n&lt;p&gt;instanceof 操作符的内部实现机制和隐式原型、显式原型有直接的关系。instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。它的内部实现原理是这样的：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;//设 L instanceof R \n//通过判断\n L.__proto__.__proto__ ..... === R.prototype ？\n//最终返回true or false\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;也就是沿着L的__proto__一直寻找到原型链末端，直到等于R.prototype为止。知道了这个也就知道为什么以下这些奇怪的表达式为什么会得到相应的值了&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;Function instanceof Object // true \n Object instanceof Function // true \n Function instanceof Function //true\n Object instanceof Object // true\n Number instanceof Number //false\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;guanxi&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;__proto__和prototype的区别和关系？&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;js&#34;,&#34;slug&#34;:&#34;3uoOai8za&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://weidadeda.github.io/tag/3uoOai8za&#34;}],&#34;date&#34;:&#34;2020-01-14 15:39:57&#34;,&#34;dateFormat&#34;:&#34;2020-01-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/guanxi&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:239000,&#34;words&#34;:1034,&#34;minutes&#34;:4},&#34;description&#34;:&#34;prototype（显示原型）是“类”的原型，指向该方法的原型对象。proto（隐式原型）是对象的原型，指向该对象的构造函数的原型对象。\nJS当然没有“类”，只有constructor。\nconstructor就是当你new fn()时的那...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#prototype%E6%98%BE%E7%A4%BA%E5%8E%9F%E5%9E%8B%E6%98%AF%E7%B1%BB%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%8C%87%E5%90%91%E8%AF%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1-proto%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%8C%87%E5%90%91%E8%AF%A5%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1\&#34;&gt;prototype（显示原型）是“类”的原型，指向该方法的原型对象。&lt;strong&gt;proto&lt;/strong&gt;（隐式原型）是对象的原型，指向该对象的构造函数的原型对象。&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B%E6%8C%87%E5%90%91%E5%88%9B%E5%BB%BA%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0constructor%E7%9A%84prototype\&#34;&gt;隐式原型指向创建这个对象的函数(constructor)的prototype&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%AD%A4%E5%A4%96\&#34;&gt;此外：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B\&#34;&gt;构造函数的隐式原型&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#instanceof\&#34;&gt;instanceof&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你嘿嘿！🤝&lt;/p&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;关于这个站呢,就是记录下平时记不太住的还有一些自己感兴趣喜欢的一些东西\n顺便也分享给大家吧!\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;关于我\&#34;&gt;👨‍💻 关于我&lt;/h2&gt;\n&lt;p&gt;一名前端开发，95后，现居北京，养了两只猫，喜欢健身💪喜欢研究历史📒&lt;/p&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;邮箱：18310536322@163.com&lt;/li&gt;\n&lt;li&gt;微信：18310536322&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-06-13 19:09:48&#34;,&#34;dateFormat&#34;:&#34;2019-06-13&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://weidadeda.github.io/post/about&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:22000,&#34;words&#34;:106,&#34;minutes&#34;:1},&#34;description&#34;:&#34;欢迎来到我的小站呀，很高兴遇见你嘿嘿！🤝\n🏠 关于本站\n关于这个站呢,就是记录下平时记不太住的还有一些自己感兴趣喜欢的一些东西\n顺便也分享给大家吧!\n\n👨‍💻 关于我\n一名前端开发，95后，现居北京，养了两只猫，喜欢健身💪喜欢研究...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%88%91\&#34;&gt;👨‍💻 关于我&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/peace.js"></script>


</html>