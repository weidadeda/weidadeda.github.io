<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://weidadeda.github.io</id>
    <title>大伟的博客</title>
    <updated>2022-03-22T06:25:20.332Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://weidadeda.github.io"/>
    <link rel="self" href="https://weidadeda.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://weidadeda.github.io/images/avatar.png</logo>
    <icon>https://weidadeda.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 大伟的博客</rights>
    <entry>
        <title type="html"><![CDATA[利用 ImageData 实现图片翻转和视频镜像]]></title>
        <id>https://weidadeda.github.io/post/li-yong-imagedata-shi-xian-tu-pian-fan-zhuan-he-shi-pin-jing-xiang</id>
        <link href="https://weidadeda.github.io/post/li-yong-imagedata-shi-xian-tu-pian-fan-zhuan-he-shi-pin-jing-xiang">
        </link>
        <updated>2022-03-09T11:21:10.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在搞视频直播，其中有一个功能是视频镜像，那么有两种实现方式。</p>
<ul>
<li>一种是老师端点击镜像，通过css把自己的video标签镜像，然后发送信令给学生端，学生端收到消息之后也通过css去实现镜像</li>
<li>第二种就是老师端对视频流做一个镜像处理，学生端无需操作，很显然第二种方法比较好</li>
</ul>
<p>怎么实现对视频流的镜像呢，首先要知道的就是视频是由一帧帧的图片组合而成，我们要对视频流镜像，首先要对图片进行镜像。</p>
<p>对图片镜像的话，就要对ImageData做处理<br>
首先了解一下什么是ImageData：</p>
<blockquote>
<p>ImageData 接口描述 canvas 元素的一个隐含像素数据的区域。使用 ImageData() 构造函数创建或者使用和 canvas 在一起的 CanvasRenderingContext2D 对象的创建方法： createImageData() 和 getImageData()。也可以使用 putImageData() 设置 canvas 的一部分。</p>
</blockquote>
<h2 id="我们先以旋转图片为例子做个说明">我们先以旋转图片为例子做个说明</h2>
<h3 id="基本原理1像素矩阵变换">基本原理1——像素矩阵变换</h3>
<p>ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：</p>
<ul>
<li>width  图片宽度，单位是像素</li>
<li>height  图片高度，单位是像素</li>
<li>data  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray">Uint8ClampedArray</a>类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。<br>
data属性返回一个 Uint8ClampedArray，它可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是&quot;RGBA&quot;格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。</li>
</ul>
<p>具体请看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas">像素操作</a></p>
<p>我们通过ImageData可以对图片的每个像素点做操作。比如我们现在要将图片向右旋转90度</p>
<p>一个 4 × 3 像素的原始图片，可以看作如下形式的像素矩阵 A：<br>
<img src="https://weidadeda.github.io/post-images/1647858122464.png" alt="" loading="lazy"><br>
图片向右旋转 90°，实质就是设法将 A 变为 A’ ——<br>
<img src="https://weidadeda.github.io/post-images/1647858132107.png" alt="" loading="lazy"><br>
这可以通过原矩阵一次 转置、与多次初等 列 变换（逆序排列各列）得到：<br>
<img src="https://weidadeda.github.io/post-images/1647858162556.png" alt="" loading="lazy"><br>
同理，图片向左旋转 90°，实际上就是得到矩阵 A’' ：<br>
<img src="https://weidadeda.github.io/post-images/1647858170777.png" alt="" loading="lazy"><br>
这可以通过原矩阵一次 转置、与多次初等 行 变换（逆序排列各行）得到——<br>
<img src="https://weidadeda.github.io/post-images/1647858177575.png" alt="" loading="lazy"></p>
<h3 id="基本原理2像素数组与矩阵的对应关系">基本原理2——像素数组与矩阵的对应关系</h3>
<p>由于 ImageData.data 对应一个数组，对于 4 × 3 的图片而言，ImageData.data 就是一个具有 48 个元素的数组 D，不妨每个元素的值就是其下标值，则：</p>
<pre><code class="language-js">D=[0,1,2,3,4,5,6,7...44,45,46,47]
</code></pre>
<p>其中：<br>
元组 (0, 1, 2, 3) 表示第 1(= 0 / 4 + 1) 个像素的颜色为 rgba(0, 1, 2, 3/255)；<br>
元组 (4, 5, 6, 7) 表示第 2(= 4 / 4 + 1) 个像素的颜色为 rgba(4, 5, 6, 7/255)；<br>
元组 (8, 9, 10, 11) 表示第 3(= 8 / 4 + 1) 个像素的颜色为 rgba(8, 9, 10, 11/255)；<br>
…</p>
<p>元组 (i, i+1, i+2, i+3) 表示第 (i / 4 + 1) 个像素的颜色为 rgba(i, i+1, i+2, (i+3)/255)；<br>
…<br>
元组 (44, 45, 46, 47) 表示第 12(= 44 / 4 + 1) 个像素的颜色为 rgba(44, 45, 46, 47/255)。</p>
<p>可见从 0 开始遍历 D 数组，每次递增 4 个单位，即可依次得到各个像素的红色值 R，再依次加1、加2、加3，即得到对应的绿色值 G、蓝色值 B、等效 α 通道值 A。</p>
<p>反之，如果知道图片的像素尺寸为 4 × 3，则可以通过下图找到数组 D 的各个元素：<br>
<img src="https://weidadeda.github.io/post-images/1647858189293.png" alt="" loading="lazy"></p>
<p>可见各像素点是按照 从左至右、从上至下 的顺序排列的。设图片总宽度像素为 W，总高度像素为 H，任一像素点 P 的坐标为 (x, y)，P 的红色值在数组 D 的下标为 R(x, y)，则：</p>
<pre><code class="language-js">R(x,y)=(x+W*y)×4
</code></pre>
<p>验证：（x 与 y 均从 0 开始计数）</p>
<p>R(2, 1) = (2 + 1 × 4) × 4 = 24<br>
R(1, 2) = (1 + 2 × 4) × 4 = 36<br>
R(3, 1) = (3 + 1 × 4) × 4 = 28</p>
<p>拿到了 R(x, y)，不难求出该像素的纵向中心对称像素 Rh(x, y)、横向中心对称像素 Rw(x, y)、以及主对角线对称像素 Rd(x, y)：</p>
<pre><code class="language-js">Rh(x,y)=[x+W*(H−1−y)]*4 // 初等行变换
Rw(x,y)=[(W−1−x)+W*y]*4 // 初等列变换
Rd(x,y)=(y+H*x)*4
</code></pre>
<h3 id="具体实现">具体实现</h3>
<p>基本思路：</p>
<ul>
<li>通过 canvas 获取目标图片的 ImageData 对象；</li>
<li>转置原图片数组，得到数组 AT；</li>
<li>对 AT 执行一组初等行变换，使各行逆序排列，得到左旋 90° 效果；</li>
<li>对 AT 执行一组初等列变换，使各列逆序排列，得到右旋 90° 效果；</li>
<li>将新的像素数组写回图片源标签。</li>
</ul>
<p>HTML：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Rotate by ImageData&lt;/title&gt;
    &lt;style&gt;
        .image{ margin-top: 5px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;btns&quot;&gt;
        &lt;input type=&quot;button&quot; value=&quot;左转 90°&quot; id=&quot;turnLeft&quot; /&gt;
        &lt;input type=&quot;button&quot; value=&quot;右转 90°&quot; id=&quot;turnRight&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;image&quot;&gt;
        &lt;img id=&quot;fruit&quot; src=&quot;fruit.jpg&quot; class=&quot;image&quot; alt=&quot;fruit&quot; title=&quot;fruit&quot; /&gt;
    &lt;/div&gt;
    &lt;script src=&quot;imageRotate.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>imageRotate.js：</p>
<pre><code class="language-js">document.querySelector('#turnLeft' ).addEventListener('click', e =&gt; rotateImage('l'))
document.querySelector('#turnRight').addEventListener('click', e =&gt; rotateImage('r'))

function rotateImage(direction = 'l') {
    // 1. Prepare ImageData
    let img = document.querySelector('#fruit')
    const { width: W, height: H } = img
    let cvs = document.createElement('canvas')
    cvs.width = W
    cvs.height = H
    let ctx = cvs.getContext('2d')
    ctx.drawImage(img, 0, 0)
    let imgDt0 = ctx.getImageData(0, 0, W, H)
    let imgDt1 = new ImageData(H, W)
    let imgDt2 = new ImageData(H, W)
    let dt0 = imgDt0.data
    let dt1 = imgDt1.data
    let dt2 = imgDt2.data

    // 2. Transpose
    let r = r1 = 0  // index of red pixel in old and new ImageData, respectively
    for (let y = 0, lenH = H; y &lt; lenH; y++) {
        for (let x = 0, lenW = W; x &lt; lenW; x++) {
            r  = (x + lenW * y) * 4
            r1 = (y + lenH * x) * 4
            dt1[r1 + 0] = dt0[r + 0]
            dt1[r1 + 1] = dt0[r + 1]
            dt1[r1 + 2] = dt0[r + 2]
            dt1[r1 + 3] = dt0[r + 3]
        }
    }
    
    // 3. Reverse width / height
    for (let y = 0, lenH = W; y &lt; lenH; y++) {
        for (let x = 0, lenW = H; x &lt; lenW; x++) {
            r  = (x + lenW * y) * 4
            r1 = direction === 'l'
                ? (x + lenW * (lenH - 1 - y)) * 4
                : ((lenW - 1 - x) + lenW * y) * 4
            dt2[r1 + 0] = dt1[r + 0]
            dt2[r1 + 1] = dt1[r + 1]
            dt2[r1 + 2] = dt1[r + 2]
            dt2[r1 + 3] = dt1[r + 3]
        }
    }
    
    // 4. Redraw image
    cvs.width = H
    cvs.height = W
    ctx.clearRect(0, 0, W, H)
    ctx.putImageData(imgDt2, 0, 0, 0, 0, H, W)
    img.src = cvs.toDataURL('image/jpeg', 1)
}
</code></pre>
<p>运行结果：<br>
原始图片<br>
<img src="https://weidadeda.github.io/post-images/1647858200595.png" alt="" loading="lazy"><br>
左转90度<br>
<img src="https://weidadeda.github.io/post-images/1647858207477.png" alt="" loading="lazy"><br>
右转90度<br>
<img src="https://weidadeda.github.io/post-images/1647858214763.png" alt="" loading="lazy"></p>
<p>好了，现在实现了图片旋转，那么我们接着套用公式实现图片镜像和视频镜像</p>
<p>html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;
    &lt;title&gt;js通过浏览器调用摄像头&lt;/title&gt;
    &lt;style&gt;
      #video {
        /* transform: rotate3d(1, 1, 1, 45deg); */
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;banner&quot;&gt;
      &lt;video id=&quot;video&quot; width=&quot;500px&quot; height=&quot;500px&quot; autoplay=&quot;autoplay&quot; /&gt;
    &lt;/div&gt;
    &lt;canvas width=&quot;500&quot; height=&quot;500&quot; id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
    &lt;video
      id=&quot;video2&quot;
      width=&quot;500px&quot;
      height=&quot;500px&quot;
      autoplay=&quot;autoplay&quot;
      controls=&quot;controls&quot;
    /&gt;
  &lt;/body&gt;
  &lt;!-- &lt;script src=&quot;./test.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;script&gt;
    function getMedia() {
      let video = document.getElementById(&quot;video&quot;);
      let constraints = {
        video: { width: 500, height: 500 },
        audio: false,
      };
      navigator.getUserMedia =
        navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.msGetUserMedia;
      let promise = navigator.mediaDevices.getUserMedia(
        constraints,
        function (stream) {
          video.src = stream;
          video.play();
        },
        function (error) {
          console.log(error);
        }
      );
      promise.then(function (MediaStream) {
        video.srcObject = MediaStream;
        video.play();
      });
    }

    getMedia();
    window.onload = () =&gt; {
      const data = [];
      var recorder;
      // 获取视频流之后，用canvas对视频进行反转，然后使用captureStream获取视频流，此时可以通过声网自定义流获取视频轨道getVideoTracks。代码中为了测试canvas转视频可用，调用了MediaRecorder录制
      function imageDataHRevert(sourceData, newData) {
        for (var i = 0, h = sourceData.height; i &lt; h; i++) {
          for (j = 0, w = sourceData.width; j &lt; w; j++) {
            newData.data[i * w * 4 + j * 4 + 0] =
              // (y*W+x)*4
              sourceData.data[i * w * 4 + (w - j) * 4  -4+ 0];
            // (y*W+(W-x-1))*4
            newData.data[i * w * 4 + j * 4 + 1] =
              sourceData.data[i * w * 4 + (w - j) * 4 -4+ 1];

            newData.data[i * w * 4 + j * 4 + 2] =
              sourceData.data[i * w * 4 + (w - j) * 4 -4+ 2];

            newData.data[i * w * 4 + j * 4 + 3] =
              sourceData.data[i * w * 4 + (w - j) * 4-4 + 3];
          }
        }
        return newData;
      }
      function imageDataVRevert(sourceData, newData) {
        for (var i = 0, h = sourceData.height; i &lt; h; i++) {
          for (var j = 0, w = sourceData.width; j &lt; w; j++) {
            newData.data[i * w * 4 + j * 4 + 0] =
              sourceData.data[(h - i) * w * 4 + j * 4 + 0];

            newData.data[i * w * 4 + j * 4 + 1] =
              sourceData.data[(h - i) * w * 4 + j * 4 + 1];

            newData.data[i * w * 4 + j * 4 + 2] =
              sourceData.data[(h - i) * w * 4 + j * 4 + 2];

            newData.data[i * w * 4 + j * 4 + 3] =
              sourceData.data[(h - i) * w * 4 + j * 4 + 3];
          }
        }

        return newData;
      }

      function render() {
        var canvas = document.getElementById(&quot;canvas&quot;);
        var video = document.getElementById(&quot;video&quot;);
        var ctx1 = canvas.getContext(&quot;2d&quot;);
        ctx1.drawImage(video, 0, 0, 500, 500);
        var imgData = ctx1.getImageData(0, 0, 500, 500);
        var newImgData = ctx1.getImageData(0, 0, 500, 500);
        const HRevet = imageDataHRevert(newImgData, imgData);
        console.error(HRevet, &quot;HRevet&quot;);
        // 亮一点
        for (var i = 0; i &lt; HRevet.data.length; i += 4) {
          HRevet.data[i] += 5;
          HRevet.data[i + 1] += 5;
          HRevet.data[i + 2] += 5;
        }
        ctx1.putImageData(HRevet, 0, 0);
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
      const stream = canvas.captureStream(30);
      // todo 自定义视频 canvas.captureStream(30).getVideoTracks()[0]
      console.error(stream, &quot;stream&quot;);
      // 自己测试录制视频的，可以不用看
      recorder = new MediaRecorder(stream, { mimeType: &quot;video/webm&quot; });
      recorder.ondataavailable = function (event) {
        if (event.data &amp;&amp; event.data.size) {
          data.push(event.data);
        }
      };
      recorder.onstop = () =&gt; {
        const url = URL.createObjectURL(new Blob(data, { type: &quot;video/webm&quot; }));
        document.getElementById(&quot;video2&quot;).src = url;
      };
      recorder.start();
      setTimeout(() =&gt; {
        recorder.stop();
      }, 6000);
    };
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>结果：<br>
<img src="https://weidadeda.github.io/post-images/1647859629847.png" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在搞视频直播，其中有一个功能是视频镜像，那么有两种实现方式。</p>
<ul>
<li>一种是老师端点击镜像，通过css把自己的video标签镜像，然后发送信令给学生端，学生端收到消息之后也通过css去实现镜像</li>
<li>第二种就是老师端对视频流做一个镜像处理，学生端无需操作，很显然第二种方法比较好</li>
</ul>
<p>怎么实现对视频流的镜像呢，首先要知道的就是视频是由一帧帧的图片组合而成，我们要对视频流镜像，首先要对图片进行镜像。</p>
<p>对图片镜像的话，就要对ImageData做处理<br>
首先了解一下什么是ImageData：</p>
<blockquote>
<p>ImageData 接口描述 canvas 元素的一个隐含像素数据的区域。使用 ImageData() 构造函数创建或者使用和 canvas 在一起的 CanvasRenderingContext2D 对象的创建方法： createImageData() 和 getImageData()。也可以使用 putImageData() 设置 canvas 的一部分。</p>
</blockquote>
<h2 id="我们先以旋转图片为例子做个说明">我们先以旋转图片为例子做个说明</h2>
<h3 id="基本原理1像素矩阵变换">基本原理1——像素矩阵变换</h3>
<p>ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：</p>
<ul>
<li>width  图片宽度，单位是像素</li>
<li>height  图片高度，单位是像素</li>
<li>data  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray">Uint8ClampedArray</a>类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。<br>
data属性返回一个 Uint8ClampedArray，它可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是&quot;RGBA&quot;格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。</li>
</ul>
<p>具体请看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas">像素操作</a></p>
<p>我们通过ImageData可以对图片的每个像素点做操作。比如我们现在要将图片向右旋转90度</p>
<p>一个 4 × 3 像素的原始图片，可以看作如下形式的像素矩阵 A：<br>
<img src="https://weidadeda.github.io/post-images/1647858122464.png" alt="" loading="lazy"><br>
图片向右旋转 90°，实质就是设法将 A 变为 A’ ——<br>
<img src="https://weidadeda.github.io/post-images/1647858132107.png" alt="" loading="lazy"><br>
这可以通过原矩阵一次 转置、与多次初等 列 变换（逆序排列各列）得到：<br>
<img src="https://weidadeda.github.io/post-images/1647858162556.png" alt="" loading="lazy"><br>
同理，图片向左旋转 90°，实际上就是得到矩阵 A’' ：<br>
<img src="https://weidadeda.github.io/post-images/1647858170777.png" alt="" loading="lazy"><br>
这可以通过原矩阵一次 转置、与多次初等 行 变换（逆序排列各行）得到——<br>
<img src="https://weidadeda.github.io/post-images/1647858177575.png" alt="" loading="lazy"></p>
<h3 id="基本原理2像素数组与矩阵的对应关系">基本原理2——像素数组与矩阵的对应关系</h3>
<p>由于 ImageData.data 对应一个数组，对于 4 × 3 的图片而言，ImageData.data 就是一个具有 48 个元素的数组 D，不妨每个元素的值就是其下标值，则：</p>
<pre><code class="language-js">D=[0,1,2,3,4,5,6,7...44,45,46,47]
</code></pre>
<p>其中：<br>
元组 (0, 1, 2, 3) 表示第 1(= 0 / 4 + 1) 个像素的颜色为 rgba(0, 1, 2, 3/255)；<br>
元组 (4, 5, 6, 7) 表示第 2(= 4 / 4 + 1) 个像素的颜色为 rgba(4, 5, 6, 7/255)；<br>
元组 (8, 9, 10, 11) 表示第 3(= 8 / 4 + 1) 个像素的颜色为 rgba(8, 9, 10, 11/255)；<br>
…</p>
<p>元组 (i, i+1, i+2, i+3) 表示第 (i / 4 + 1) 个像素的颜色为 rgba(i, i+1, i+2, (i+3)/255)；<br>
…<br>
元组 (44, 45, 46, 47) 表示第 12(= 44 / 4 + 1) 个像素的颜色为 rgba(44, 45, 46, 47/255)。</p>
<p>可见从 0 开始遍历 D 数组，每次递增 4 个单位，即可依次得到各个像素的红色值 R，再依次加1、加2、加3，即得到对应的绿色值 G、蓝色值 B、等效 α 通道值 A。</p>
<p>反之，如果知道图片的像素尺寸为 4 × 3，则可以通过下图找到数组 D 的各个元素：<br>
<img src="https://weidadeda.github.io/post-images/1647858189293.png" alt="" loading="lazy"></p>
<p>可见各像素点是按照 从左至右、从上至下 的顺序排列的。设图片总宽度像素为 W，总高度像素为 H，任一像素点 P 的坐标为 (x, y)，P 的红色值在数组 D 的下标为 R(x, y)，则：</p>
<pre><code class="language-js">R(x,y)=(x+W*y)×4
</code></pre>
<p>验证：（x 与 y 均从 0 开始计数）</p>
<p>R(2, 1) = (2 + 1 × 4) × 4 = 24<br>
R(1, 2) = (1 + 2 × 4) × 4 = 36<br>
R(3, 1) = (3 + 1 × 4) × 4 = 28</p>
<p>拿到了 R(x, y)，不难求出该像素的纵向中心对称像素 Rh(x, y)、横向中心对称像素 Rw(x, y)、以及主对角线对称像素 Rd(x, y)：</p>
<pre><code class="language-js">Rh(x,y)=[x+W*(H−1−y)]*4 // 初等行变换
Rw(x,y)=[(W−1−x)+W*y]*4 // 初等列变换
Rd(x,y)=(y+H*x)*4
</code></pre>
<h3 id="具体实现">具体实现</h3>
<p>基本思路：</p>
<ul>
<li>通过 canvas 获取目标图片的 ImageData 对象；</li>
<li>转置原图片数组，得到数组 AT；</li>
<li>对 AT 执行一组初等行变换，使各行逆序排列，得到左旋 90° 效果；</li>
<li>对 AT 执行一组初等列变换，使各列逆序排列，得到右旋 90° 效果；</li>
<li>将新的像素数组写回图片源标签。</li>
</ul>
<p>HTML：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Rotate by ImageData&lt;/title&gt;
    &lt;style&gt;
        .image{ margin-top: 5px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;btns&quot;&gt;
        &lt;input type=&quot;button&quot; value=&quot;左转 90°&quot; id=&quot;turnLeft&quot; /&gt;
        &lt;input type=&quot;button&quot; value=&quot;右转 90°&quot; id=&quot;turnRight&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;image&quot;&gt;
        &lt;img id=&quot;fruit&quot; src=&quot;fruit.jpg&quot; class=&quot;image&quot; alt=&quot;fruit&quot; title=&quot;fruit&quot; /&gt;
    &lt;/div&gt;
    &lt;script src=&quot;imageRotate.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>imageRotate.js：</p>
<pre><code class="language-js">document.querySelector('#turnLeft' ).addEventListener('click', e =&gt; rotateImage('l'))
document.querySelector('#turnRight').addEventListener('click', e =&gt; rotateImage('r'))

function rotateImage(direction = 'l') {
    // 1. Prepare ImageData
    let img = document.querySelector('#fruit')
    const { width: W, height: H } = img
    let cvs = document.createElement('canvas')
    cvs.width = W
    cvs.height = H
    let ctx = cvs.getContext('2d')
    ctx.drawImage(img, 0, 0)
    let imgDt0 = ctx.getImageData(0, 0, W, H)
    let imgDt1 = new ImageData(H, W)
    let imgDt2 = new ImageData(H, W)
    let dt0 = imgDt0.data
    let dt1 = imgDt1.data
    let dt2 = imgDt2.data

    // 2. Transpose
    let r = r1 = 0  // index of red pixel in old and new ImageData, respectively
    for (let y = 0, lenH = H; y &lt; lenH; y++) {
        for (let x = 0, lenW = W; x &lt; lenW; x++) {
            r  = (x + lenW * y) * 4
            r1 = (y + lenH * x) * 4
            dt1[r1 + 0] = dt0[r + 0]
            dt1[r1 + 1] = dt0[r + 1]
            dt1[r1 + 2] = dt0[r + 2]
            dt1[r1 + 3] = dt0[r + 3]
        }
    }
    
    // 3. Reverse width / height
    for (let y = 0, lenH = W; y &lt; lenH; y++) {
        for (let x = 0, lenW = H; x &lt; lenW; x++) {
            r  = (x + lenW * y) * 4
            r1 = direction === 'l'
                ? (x + lenW * (lenH - 1 - y)) * 4
                : ((lenW - 1 - x) + lenW * y) * 4
            dt2[r1 + 0] = dt1[r + 0]
            dt2[r1 + 1] = dt1[r + 1]
            dt2[r1 + 2] = dt1[r + 2]
            dt2[r1 + 3] = dt1[r + 3]
        }
    }
    
    // 4. Redraw image
    cvs.width = H
    cvs.height = W
    ctx.clearRect(0, 0, W, H)
    ctx.putImageData(imgDt2, 0, 0, 0, 0, H, W)
    img.src = cvs.toDataURL('image/jpeg', 1)
}
</code></pre>
<p>运行结果：<br>
原始图片<br>
<img src="https://weidadeda.github.io/post-images/1647858200595.png" alt="" loading="lazy"><br>
左转90度<br>
<img src="https://weidadeda.github.io/post-images/1647858207477.png" alt="" loading="lazy"><br>
右转90度<br>
<img src="https://weidadeda.github.io/post-images/1647858214763.png" alt="" loading="lazy"></p>
<p>好了，现在实现了图片旋转，那么我们接着套用公式实现图片镜像和视频镜像</p>
<p>html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;
    &lt;title&gt;js通过浏览器调用摄像头&lt;/title&gt;
    &lt;style&gt;
      #video {
        /* transform: rotate3d(1, 1, 1, 45deg); */
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;banner&quot;&gt;
      &lt;video id=&quot;video&quot; width=&quot;500px&quot; height=&quot;500px&quot; autoplay=&quot;autoplay&quot; /&gt;
    &lt;/div&gt;
    &lt;canvas width=&quot;500&quot; height=&quot;500&quot; id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
    &lt;video
      id=&quot;video2&quot;
      width=&quot;500px&quot;
      height=&quot;500px&quot;
      autoplay=&quot;autoplay&quot;
      controls=&quot;controls&quot;
    /&gt;
  &lt;/body&gt;
  &lt;!-- &lt;script src=&quot;./test.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;script&gt;
    function getMedia() {
      let video = document.getElementById(&quot;video&quot;);
      let constraints = {
        video: { width: 500, height: 500 },
        audio: false,
      };
      navigator.getUserMedia =
        navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.msGetUserMedia;
      let promise = navigator.mediaDevices.getUserMedia(
        constraints,
        function (stream) {
          video.src = stream;
          video.play();
        },
        function (error) {
          console.log(error);
        }
      );
      promise.then(function (MediaStream) {
        video.srcObject = MediaStream;
        video.play();
      });
    }

    getMedia();
    window.onload = () =&gt; {
      const data = [];
      var recorder;
      // 获取视频流之后，用canvas对视频进行反转，然后使用captureStream获取视频流，此时可以通过声网自定义流获取视频轨道getVideoTracks。代码中为了测试canvas转视频可用，调用了MediaRecorder录制
      function imageDataHRevert(sourceData, newData) {
        for (var i = 0, h = sourceData.height; i &lt; h; i++) {
          for (j = 0, w = sourceData.width; j &lt; w; j++) {
            newData.data[i * w * 4 + j * 4 + 0] =
              // (y*W+x)*4
              sourceData.data[i * w * 4 + (w - j) * 4  -4+ 0];
            // (y*W+(W-x-1))*4
            newData.data[i * w * 4 + j * 4 + 1] =
              sourceData.data[i * w * 4 + (w - j) * 4 -4+ 1];

            newData.data[i * w * 4 + j * 4 + 2] =
              sourceData.data[i * w * 4 + (w - j) * 4 -4+ 2];

            newData.data[i * w * 4 + j * 4 + 3] =
              sourceData.data[i * w * 4 + (w - j) * 4-4 + 3];
          }
        }
        return newData;
      }
      function imageDataVRevert(sourceData, newData) {
        for (var i = 0, h = sourceData.height; i &lt; h; i++) {
          for (var j = 0, w = sourceData.width; j &lt; w; j++) {
            newData.data[i * w * 4 + j * 4 + 0] =
              sourceData.data[(h - i) * w * 4 + j * 4 + 0];

            newData.data[i * w * 4 + j * 4 + 1] =
              sourceData.data[(h - i) * w * 4 + j * 4 + 1];

            newData.data[i * w * 4 + j * 4 + 2] =
              sourceData.data[(h - i) * w * 4 + j * 4 + 2];

            newData.data[i * w * 4 + j * 4 + 3] =
              sourceData.data[(h - i) * w * 4 + j * 4 + 3];
          }
        }

        return newData;
      }

      function render() {
        var canvas = document.getElementById(&quot;canvas&quot;);
        var video = document.getElementById(&quot;video&quot;);
        var ctx1 = canvas.getContext(&quot;2d&quot;);
        ctx1.drawImage(video, 0, 0, 500, 500);
        var imgData = ctx1.getImageData(0, 0, 500, 500);
        var newImgData = ctx1.getImageData(0, 0, 500, 500);
        const HRevet = imageDataHRevert(newImgData, imgData);
        console.error(HRevet, &quot;HRevet&quot;);
        // 亮一点
        for (var i = 0; i &lt; HRevet.data.length; i += 4) {
          HRevet.data[i] += 5;
          HRevet.data[i + 1] += 5;
          HRevet.data[i + 2] += 5;
        }
        ctx1.putImageData(HRevet, 0, 0);
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
      const stream = canvas.captureStream(30);
      // todo 自定义视频 canvas.captureStream(30).getVideoTracks()[0]
      console.error(stream, &quot;stream&quot;);
      // 自己测试录制视频的，可以不用看
      recorder = new MediaRecorder(stream, { mimeType: &quot;video/webm&quot; });
      recorder.ondataavailable = function (event) {
        if (event.data &amp;&amp; event.data.size) {
          data.push(event.data);
        }
      };
      recorder.onstop = () =&gt; {
        const url = URL.createObjectURL(new Blob(data, { type: &quot;video/webm&quot; }));
        document.getElementById(&quot;video2&quot;).src = url;
      };
      recorder.start();
      setTimeout(() =&gt; {
        recorder.stop();
      }, 6000);
    };
  &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>结果：<br>
<img src="https://weidadeda.github.io/post-images/1647859629847.png" alt="" loading="lazy"></p>
<!-- more -->
<h4 id="大家看的可能有点懵没关系拿个纸画一下然后去套用公式就好了一次不懂就多试几次-看不懂一定要拿张纸画一下">大家看的可能有点懵，没关系，拿个纸画一下，然后去套用公式就好了，一次不懂就多试几次。看不懂一定要拿张纸画一下！</h4>
<p>简单的增加美白效果（亮度），可给每个rgb通道加特定值。</p>
<pre><code class="language-js"> r1 = (x + W * y) * 4;
 r1 = (x + W * (H - 1 - y)) * 4;
</code></pre>
<p>推荐一个美颜库：opencvjs<br>
推荐一个人脸识别库：face-api.js https://www.cnblogs.com/neozhu/p/11771148.html</p>
<p>部分内容参考自 https://blog.csdn.net/frgod/article/details/106055830</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Taro解决小程序包体积过大的问题]]></title>
        <id>https://weidadeda.github.io/post/taro-jie-jue-xiao-cheng-xu-bao-ti-ji-guo-da-de-wen-ti</id>
        <link href="https://weidadeda.github.io/post/taro-jie-jue-xiao-cheng-xu-bao-ti-ji-guo-da-de-wen-ti">
        </link>
        <updated>2022-03-01T12:27:38.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1646137679298.png" alt="" loading="lazy"></figure>
<blockquote>
<p>目前小程序分包大小有以下限制：<br>
整个小程序所有分包大小不超过 8M<br>
单个分包/主包大小不能超过 2M</p>
</blockquote>
<p>所以说8M的限制是要分包至少4个包，单个分包上限其实还是2M</p>
<h3 id="解决这个问题一种是分包">解决这个问题一种是分包</h3>
<p>官方给出的分包<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html">官网文档</a></p>
<h3 id="另一种是减少包中的图片">另一种是减少包中的图片</h3>
<p>其实造成包体积过大的因素，很大原因是因为包里有图片，那体积就会变得很大。那我们可以将图片上传到CDN上，变成网络链接，这样的话就不会把图片打包进去了。但是这样又有一个不足，比如说我们一开始开发项目的时候，UI同学给了我们设计图，那我们要将图片一张张的上传到CDN上去吗？如果后期UI走查的时候要换图片呢？而且万一CDN上的图片被人误删了或者服务到期了呢（当然这种可能性很小，但也可以考虑进去），这时候我们的原图都会找不到，只能干着急。。。</p>
<h4 id="那么最好的方式就是将图片放在项目中本地开发的时候引用的就是本地的增删改找起来也方便但是打包构建的时候将图片压缩并上传cdn同时将项目中的图片引用路径改成网络链接然后删除dist中的所有图片-那么接下来我们就写个脚本实现一下">那么最好的方式就是将图片放在项目中，本地开发的时候引用的就是本地的，增删改找起来也方便，但是打包构建的时候将图片压缩并上传CDN，同时将项目中的图片引用路径改成网络链接，然后删除dist中的所有图片。那么接下来我们就写个脚本实现一下。</h4>
<p>直接上代码吧</p>
<h4 id="先写上传方法用于打包完上传先压缩再上传到阿里oss">先写上传方法，用于打包完上传，先压缩再上传到阿里oss</h4>
<pre><code class="language-js">// config/upload.js
const OSS = require(&quot;ali-oss&quot;);
const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const rimraf = require(&quot;rimraf&quot;);
const imagemin = require('imagemin')
const imageminJpegtran = require('imagemin-jpegtran')
const imageminPngquant = require('imagemin-pngquant')
const imageminSvgo = require('imagemin-svgo')
const imageminGifsicle = require('imagemin-gifsicle')

const client = new OSS({
  region: &quot;&quot;,
  endpoint: &quot;&quot;,
  accessKeyId: &quot;&quot;,
  accessKeySecret: &quot;&quot;,
  bucket: &quot;&quot;
});
async function compress() {
  const files = await imagemin(['../dist/**/*.{jpg,jpeg,png,svg,gif}'], {
    destination: '../dist/assets',
    plugins: [
      imageminJpegtran({
        progressive: true,
        quality: 80,
      }),
      imageminPngquant({
        quality: [0.6, 0.8],
      }),
      imageminSvgo({
        plugins: [{ removeViewBox: false }],
      }),
      imageminGifsicle(),
    ],
  })
  console.log('compress all images success!'.info)
  return files
}
const putOSS = async function(src, dist) {
  try {
    let result = await client.put(dist, src);
    console.log(&quot;oss上传成功: &quot; + result.name);
  } catch (e) {
    console.log(e);
  }
};

const workList = [];

/**
 *
 * @param {string} src 需要上传的文件夹
 * @param {string} dist oss文件夹
 */

const addFileToOSSSync = function(src, dist) {
  try {
    await compress()
    var docs = fs.readdirSync(src);
  } catch (error) {
    console.log(src + &quot;不存在&quot;);
    return;
  }

  docs.forEach(function(doc) {
    const _src = src + &quot;/&quot; + doc;
    const _dist = dist + &quot;/&quot; + doc;
    const st = fs.statSync(_src);
    // 判断是否为文件
    if (st.isFile() &amp;&amp; doc !== &quot;.DS_Store&quot;) {
      workList.push(putOSS(_src, _dist));
      // console.log(_src + '是文件', _dist);
    } else if (st.isDirectory()) {
      addFileToOSSSync(_src, _dist);
    }
  });
};

addFileToOSSSync(&quot;dist/assets&quot;, &quot;weixin/gongyi/sdg/images&quot;);

Promise.all(workList).then(res =&gt; {
  rimraf(path.join(__dirname, &quot;../dist/assets&quot;), error =&gt; {
    if (error) {
      throw error;
    }
    console.log(&quot;done!&quot;);
  });
});

</code></pre>
<h4 id="上传方法写完了什么时候调用呢应该在构建完之后调用因为上传完要删除包中dist下的图片那么我们应该packagejson中更改命令">上传方法写完了，什么时候调用呢，应该在构建完之后调用，因为上传完要删除包中dist下的图片，那么我们应该package.json中更改命令</h4>
<pre><code class="language-js">// package.json
&quot;build:weapp&quot;: &quot;NODE_ENV=online taro build --type weapp &amp;&amp; node config/upload.js&quot;
</code></pre>
<h4 id="还有设置一个全局变量">还有设置一个全局变量</h4>
<pre><code class="language-js">// Taro打包入口处
const ossPath = '你的cdn域名'
let projectPublicPath = '/'

if (process.env.NODE_ENV !== 'development') {
  // 你上传的cdn路径
  projectPublicPath = `${ossPath}/1v1mp/${process.env.TARO_ENV}/${process.env.NODE_ENV}`
}

let assetsPre =
  process.env.TARO_ENV === 'weapp'
    ? process.env.NODE_ENV === 'development'
      ? ''
      : projectPublicPath
    : ''
var config = {
  // ...其他配置正常写，主要是注意这两项
  alias: {
    '@': path.resolve(__dirname, '..', 'src'),
  },
  defineConstants: {
    assetsPre: `&quot;${assetsPre}&quot;`,
  },
}
</code></pre>
<h4 id="最后使用需要注意">最后使用需要注意：</h4>
<ul>
<li>
<p>所有图片文件放入<code>src/assets</code>目录下，可以在<code>assets</code>目录下创建各模块目录</p>
</li>
<li>
<p>使用 <code>import</code> 引入后在<code>src</code>处使用 <code>${assetsPre}${pic}</code>的方式使用, <code>assetsPre</code>是全局定义好的常量，可以直接使用。</p>
<p>例如：</p>
<pre><code class="language-jsx">import pic from '@/assets/defualt.jpg'

export default function Index() {
  // do some logic

  return &lt;Image src={`${assetsPre}${pic}`} /&gt;
}
</code></pre>
</li>
</ul>
<blockquote>
<p>tip: 有一点要说一下，虽然import引入了，但其实是个pic是个路径，webpack5以前会把它通过loader转为路径，webpack5通过内置Asset Modules转为路径。具体文档可见：<a href="https://webpack.docschina.org/guides/asset-management/#loading-images">加载images图像</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[createjs 创建图片位图并设置中心点为图片中心]]></title>
        <id>https://weidadeda.github.io/post/createjs-chuang-jian-tu-pian-wei-tu-bing-she-zhi-zhong-xin-dian-wei-tu-pian-zhong-xin</id>
        <link href="https://weidadeda.github.io/post/createjs-chuang-jian-tu-pian-wei-tu-bing-she-zhi-zhong-xin-dian-wei-tu-pian-zhong-xin">
        </link>
        <updated>2022-02-22T03:38:28.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-js">public static createBitmap(imgUrl: string): Promise&lt;any&gt; {
    return new Promise&lt;object | number&gt;((resolve, reject) =&gt; {
      const image: any = new Image()
      image.src = imgUrl || ''
      image.onload = () =&gt; {
        const Bitmap = new createjs.Bitmap(image)
        const { width, height } = Bitmap.image
        // Bitmap.setBounds(0, 0, width, height);
        Bitmap.regX = width / 2
        Bitmap.regY = height / 2
        resolve(Bitmap)
      }
      image.onerror = (error: any) =&gt; {
        console.warn(`&quot;image load fail&quot;${imgUrl}`, error)
      }
    })
  }
</code></pre>
<h4 id="注意默认注册中心点旋转时围绕的点是在左上角regxregy并不是改变注册中心点而是向左上方向偏移宽高的一半但只是偏移物体这个物体的注册中心点是不变的-想改变注册中心点只能靠xy来设置位置注册中心点永远都在左上角但通过regxregy可以把物体本身往反方向平移一半但注册中心点还在之前的位置这样的话我们的旋转位置看起来就是围着中间点旋转了-这么说大家可能有点懵没关系这里确实有点难理解~有个博客写的很好大家可以结合我总结的看一下">注意：默认注册中心点（旋转时围绕的点）是在左上角，regX，regY并不是改变注册中心点，而是向左上方向偏移宽高的一半，但只是偏移物体，这个物体的注册中心点是不变的。想改变注册中心点，只能靠x,y来设置位置，注册中心点永远都在左上角，但通过regX，regY可以把物体本身往反方向平移一半（但注册中心点还在之前的位置），这样的话，我们的旋转位置看起来就是围着中间点旋转了。这么说大家可能有点懵，没关系，这里确实有点难理解～有个博客写的很好，大家可以结合我总结的看一下：</h4>
<p><a href="https://segmentfault.com/a/1190000016445744">Easeljs之regX/regY详解</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vite自定义上传插件]]></title>
        <id>https://weidadeda.github.io/post/vite-zi-ding-yi-cha-jian</id>
        <link href="https://weidadeda.github.io/post/vite-zi-ding-yi-cha-jian">
        </link>
        <updated>2022-02-15T11:53:23.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://vitejs.cn/guide/api-plugin.html">vite官网自定义插件</a></p>
<p>Vite 插件扩展了设计出色的 Rollup 接口，带有一些 Vite 独有的配置项。因为vite是使用rollup打包的所以最好你能了解<a href="https://rollupjs.org/guide/en/#plugin-development">Rollup 插件文档</a></p>
<blockquote>
<p>下面的都是按照官网介绍写的，因为毕竟你看到我这了，直接给你个链接再让你跳转到官网去看有点不负责任，如果你已经从官网看过了，并且对自定义插件很熟悉了，那么请直接到最下面看 <a href="#test">项目实战部分</a></p>
</blockquote>
<h3 id="约定">约定</h3>
<p>如果插件不使用 Vite 特有的钩子，可以作为 <a href="https://vitejs.cn/guide/api-plugin.html#rollup-plugin-compatibility">兼容 Rollup 的插件</a> 来实现，推荐使用 <a href="https://rollupjs.org/guide/en/#conventions">Rollup 插件名称约定</a>。</p>
<ul>
<li>Rollup 插件应该有一个带 rollup-plugin- 前缀、语义清晰的名称。</li>
<li>在 package.json 中包含 rollup-plugin 和 vite-plugin 关键字。</li>
</ul>
<p>这样，插件也可以用于纯 Rollup 或基于 WMR 的项目。</p>
<p>对于 Vite 专属的插件：</p>
<ul>
<li>Vite 插件应该有一个带 vite-plugin- 前缀、语义清晰的名称。</li>
<li>在 package.json 中包含 vite-plugin 关键字。</li>
<li>在插件文档增加一部分关于为什么本插件是一个 Vite 专属插件的详细说明（如，本插件使用了 Vite 特有的插件钩子）。</li>
</ul>
<p>如果你的插件只适用于特定的框架，它的名字应该遵循以下前缀格式：</p>
<ul>
<li>vite-plugin-vue- 前缀作为 Vue 插件</li>
<li>vite-plugin-react- 前缀作为 React 插件</li>
<li>vite-plugin-svelte- 前缀作为 Svelte 插件</li>
</ul>
<h3 id="插件配置">插件配置</h3>
<p>用户会将插件添加到项目的 devDependencies 中并使用数组形式的 plugins 选项配置它们。</p>
<pre><code class="language-js">// vite.config.js
import vitePlugin from 'vite-plugin-feature'
import rollupPlugin from 'rollup-plugin-feature'

export default defineConfig({
  plugins: [vitePlugin(), rollupPlugin()]
})
</code></pre>
<p>假值的插件将被忽略，可以用来轻松地启用或停用插件。</p>
<p>plugins 也可以接受将多个插件作为单个元素的预设。这对于使用多个插件实现的复杂特性（如框架集成）很有用。该数组将在内部被扁平化（flatten）。</p>
<pre><code class="language-js">// 框架插件
import frameworkRefresh from 'vite-plugin-framework-refresh'
import frameworkDevtools from 'vite-plugin-framework-devtools'

export default function framework(config) {
  return [frameworkRefresh(config), frameworkDevTools(config)]
}
</code></pre>
<pre><code class="language-js">// vite.config.js
import { defineConfig } from 'vite'
import framework from 'vite-plugin-framework'

export default defineConfig({
  plugins: [framework()]
})
</code></pre>
<h3 id="简单示例">简单示例</h3>
<blockquote>
<p>TIP<br>
通常的惯例是创建一个 Vite/Rollup 插件作为一个返回实际插件对象的工厂函数。该函数可以接受允许用户自定义插件行为的选项。</p>
</blockquote>
<h4 id="转换自定义文件类型">转换自定义文件类型</h4>
<pre><code class="language-js">const fileRegex = /\.(my-file-ext)$/

export default function myPlugin() {
  return {
    name: 'transform-file',

    transform(src, id) {
      if (fileRegex.test(id)) {
        return {
          code: compileFileToJS(src),
          map: null // 如果可行将提供 source map
        }
      }
    }
  }
}
</code></pre>
<h3 id="通用钩子">通用钩子</h3>
<p>在开发中，Vite 开发服务器会创建一个插件容器来调用 <a href="https://rollupjs.org/guide/en/#build-hooks">Rollup 构建钩子</a>，与 Rollup 如出一辙。</p>
<p>以下钩子在服务器启动时被调用：</p>
<ul>
<li>
<p>options</p>
</li>
<li>
<p>buildStart<br>
以下钩子会在每个传入模块请求时被调用：</p>
</li>
<li>
<p>resolveId</p>
</li>
<li>
<p>load</p>
</li>
<li>
<p>transform<br>
以下钩子在服务器关闭时被调用：</p>
</li>
<li>
<p>buildEnd</p>
</li>
<li>
<p>closeBundle<br>
请注意 moduleParsed 钩子在开发中是 不会 被调用的，因为 Vite 为了性能会避免完整的 AST 解析。<br>
Output Generation Hooks（除了 closeBundle) 在开发中是 不会 被调用的。你可以认为 Vite 的开发服务器只调用了 rollup.rollup() 而没有调用 bundle.generate()。<br>
<img src="https://weidadeda.github.io/post-images/1645006280268.jpeg" alt="" loading="lazy"></p>
</li>
</ul>
<h3 id="vite-独有钩子">Vite 独有钩子</h3>
<p>Vite 插件也可以提供钩子来服务于特定的 Vite 目标。这些钩子会被 Rollup 忽略。</p>
<h4 id="config">config</h4>
<ul>
<li>
<p>类型： (config: UserConfig, env: { mode: string, command: string }) =&gt; UserConfig | null | void</p>
</li>
<li>
<p>种类： async, sequential</p>
</li>
</ul>
<p>在解析 Vite 配置前调用。钩子接收原始用户配置（命令行选项指定的会与配置文件合并）和一个描述配置环境的变量，包含正在使用的 mode 和 command。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置（如果默认的合并不能达到预期的结果）。</p>
<p>示例：</p>
<pre><code class="language-js">// 返回部分配置（推荐）
const partialConfigPlugin = () =&gt; ({
  name: 'return-partial',
  config: () =&gt; ({
    alias: {
      foo: 'bar'
    }
  })
})

// 直接改变配置（应仅在合并不起作用时使用）
const mutateConfigPlugin = () =&gt; ({
  name: 'mutate-config',
  config(config, { command }) {
    if (command === 'build') {
      config.root = __dirname
    }
  }
})
</code></pre>
<blockquote>
<p>注意<br>
用户插件在运行这个钩子之前会被解析，因此在 config 钩子中注入其他插件不会有任何效果。</p>
</blockquote>
<h4 id="configresolved">configResolved</h4>
<ul>
<li>
<p>类型： (config: ResolvedConfig) =&gt; void | Promise<void></p>
</li>
<li>
<p>种类： async, parallel</p>
</li>
</ul>
<p>在解析 Vite 配置后调用。使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。</p>
<p>示例：</p>
<pre><code class="language-js">const exmaplePlugin = () =&gt; {
  let config

  return {
    name: 'read-config',

    configResolved(resolvedConfig) {
      // 存储最终解析的配置
      config = resolvedConfig
    },

    // 在其他钩子中使用存储的配置
    transform(code, id) {
      if (config.command === 'serve') {
        // dev: 由开发服务器调用的插件
      } else {
        // build: 由 Rollup 调用的插件
      }
    }
  }
}
</code></pre>
<blockquote>
<p>注意，在开发环境下，command 的值为 serve（在 CLI 中，vite 和 vite dev 是 vite serve 的别名）。</p>
</blockquote>
<h4 id="configureserver">configureServer</h4>
<ul>
<li>
<p>类型： (server: ViteDevServer) =&gt; (() =&gt; void) | void | Promise&lt;(() =&gt; void) | void&gt;</p>
</li>
<li>
<p>种类： async, sequential</p>
</li>
<li>
<p>此外请看 <a href="https://vitejs.cn/guide/api-javascript.html#vitedevserver">ViteDevServer</a></p>
</li>
</ul>
<p>是用于配置开发服务器的钩子。最常见的用例是在内部 connect 应用程序中添加自定义中间件:</p>
<pre><code class="language-js">const myPlugin = () =&gt; ({
  name: 'configure-server',
  configureServer(server) {
    server.middlewares.use((req, res, next) =&gt; {
      // 自定义请求处理...
    })
  }
})
</code></pre>
<p>注入后置中间件</p>
<p>configureServer 钩子将在内部中间件被安装前调用，所以自定义的中间件将会默认会比内部中间件早运行。如果你想注入一个在内部中间件 之后 运行的中间件，你可以从 configureServer 返回一个函数，将会在内部中间件安装后被调用：</p>
<pre><code class="language-js">const myPlugin = () =&gt; ({
  name: 'configure-server',
  configureServer(server) {
    // 返回一个在内部中间件安装后
    // 被调用的后置钩子
    return () =&gt; {
      server.middlewares.use((req, res, next) =&gt; {
        // 自定义请求处理...
      })
    }
  }
})
</code></pre>
<p>存储服务器访问</p>
<p>在某些情况下，其他插件钩子可能需要访问开发服务器实例（例如访问 websocket 服务器、文件系统监视程序或模块图）。这个钩子也可以用来存储服务器实例以供其他钩子访问:</p>
<pre><code class="language-js">const myPlugin = () =&gt; {
  let server
  return {
    name: 'configure-server',
    configureServer(_server) {
      server = _server
    },
    transform(code, id) {
      if (server) {
        // 使用 server...
      }
    }
  }
}
</code></pre>
<p>注意 configureServer 在运行生产版本时不会被调用，所以其他钩子需要防范它缺失。</p>
<h4 id="transformindexhtml">transformIndexHtml</h4>
<ul>
<li>
<p>类型： IndexHtmlTransformHook | { enforce?: 'pre' | 'post', transform: IndexHtmlTransformHook }</p>
</li>
<li>
<p>种类： async, sequential</p>
</li>
</ul>
<p>转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文。上下文在开发期间暴露ViteDevServer实例，在构建期间暴露 Rollup 输出的包。<br>
这个钩子可以是异步的，并且可以返回以下其中之一:</p>
<ul>
<li>经过转换的 HTML 字符串</li>
<li>注入到现有 HTML 中的标签描述符对象数组（{ tag, attrs, children }）。每个标签也可以指定它应该被注入到哪里（默认是在 <head> 之前）</li>
<li>一个包含 { html, tags } 的对象</li>
</ul>
<p>基础示例：</p>
<pre><code class="language-js">const htmlPlugin = () =&gt; {
  return {
    name: 'html-transform',
    transformIndexHtml(html) {
      return html.replace(
        /&lt;title&gt;(.*?)&lt;\/title&gt;/,
        `&lt;title&gt;Title replaced!&lt;/title&gt;`
      )
    }
  }
}
</code></pre>
<h4 id="handlehotupdate">handleHotUpdate</h4>
<ul>
<li>类型： (ctx: HmrContext) =&gt; Array<ModuleNode> | void | Promise&lt;Array<ModuleNode> | void&gt;</li>
</ul>
<p>执行自定义 HMR 更新处理。钩子接收一个带有以下签名的上下文对象：</p>
<pre><code class="language-js">interface HmrContext {
  file: string
  timestamp: number
  modules: Array&lt;ModuleNode&gt;
  read: () =&gt; string | Promise&lt;string&gt;
  server: ViteDevServer
}
</code></pre>
<ul>
<li>
<p>modules 是受更改文件影响的模块数组。它是一个数组，因为单个文件可能映射到多个服务模块（例如 Vue 单文件组件）。</p>
</li>
<li>
<p>read 这是一个异步读函数，它返回文件的内容。之所以这样做，是因为在某些系统上，文件更改的回调函数可能会在编辑器完成文件更新之前过快地触发，并 fs.readFile 直接会返回空内容。传入的 read 函数规范了这种行为。</p>
</li>
</ul>
<p>钩子可以选择:</p>
<ul>
<li>
<p>过滤和缩小受影响的模块列表，使 HMR 更准确。</p>
</li>
<li>
<p>返回一个空数组，并通过向客户端发送自定义事件来执行完整的自定义 HMR 处理:</p>
</li>
</ul>
<pre><code class="language-js">handleHotUpdate({ server }) {
  server.ws.send({
    type: 'custom',
    event: 'special-update',
    data: {}
  })
  return []
}
</code></pre>
<p>客户端代码应该使用 <a href="https://vitejs.cn/guide/api-hmr.html">HMR API</a> 注册相应的处理器（这应该被相同插件的 transform 钩子注入）：</p>
<pre><code class="language-js">if (import.meta.hot) {
  import.meta.hot.on('special-update', (data) =&gt; {
    // 执行自定义更新
  })
}
</code></pre>
<h3 id="插件顺序">插件顺序</h3>
<p>一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。解析后的插件将按照以下顺序排列：</p>
<ul>
<li>Alias</li>
<li>带有 enforce: 'pre' 的用户插件</li>
<li>Vite 核心插件</li>
<li>没有 enforce 值的用户插件</li>
<li>Vite 构建用的插件</li>
<li>带有 enforce: 'post' 的用户插件</li>
<li>Vite 后置构建插件（最小化，manifest，报告）</li>
</ul>
<h3 id="情景应用">情景应用</h3>
<p>默认情况下插件在开发（serve）和构建（build）模式中都会调用。如果插件只需要在预览或构建期间有条件地应用，请使用 apply 属性指明它们仅在 'build' 或 'serve' 模式时调用：</p>
<pre><code class="language-js">function myPlugin() {
  return {
    name: 'build-only',
    apply: 'build' // 或 'serve'
  }
}
</code></pre>
<p>同时，还可以使用函数来进行更精准的控制：</p>
<pre><code class="language-js">apply(config, { command }) {
  // 非 SSR 情况下的 build
  return command === 'build' &amp;&amp; !config.build.ssr
}
</code></pre>
<h3 id="rollup-插件兼容性">Rollup 插件兼容性</h3>
<p>相当数量的 Rollup 插件将直接作为 Vite 插件工作（例如：@rollup/plugin-alias 或 @rollup/plugin-json），但并不是所有的，因为有些插件钩子在非构建式的开发服务器上下文中没有意义。</p>
<p>一般来说，只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作：</p>
<ul>
<li>没有使用 moduleParsed 钩子。</li>
<li>它在打包钩子和输出钩子之间没有很强的耦合。</li>
</ul>
<p>如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。</p>
<p>你也可以用 Vite 独有的属性来扩展现有的 Rollup 插件:</p>
<pre><code class="language-js">// vite.config.js
import example from 'rollup-plugin-example'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      ...example(),
      enforce: 'post',
      apply: 'build'
    }
  ]
})
</code></pre>
<p>查看 <a href="https://vite-rollup-plugins.patak.dev/">Vite Rollup 插件</a> 获取兼容的官方 Rollup 插件列表及其使用指南。</p>
<h3 id="a-idtest-nametest项目实战a"><a id="test" name="test">项目实战</a></h3>
<p>先说下我们要做什么，我们用vite打包完之后需要将打包出来的静态资源上传到cdn上，但现有的插件不够灵活，比如<a href="https://www.npmjs.com/package/vite-plugin-assets-uploader">vite-plugin-assets-uploader<br>
</a>这个很好，但是需要将oss的密钥等信息写在前端，不够安全。对此我们就用node写了个接口，前端只需要调用node接口就能够上传到oss。而且将代码上传到cdn之后，我们的base路径也要改成cdn的路径。</p>
<p>自定义上传插件代码如下：</p>
<pre><code class="language-js">/* eslint-disable no-prototype-builtins */
/* eslint-disable no-self-assign */
const path = require('path')
const fs = require('fs-extra')
const request = require('request')
const glob = require('glob')
import { Ioptions } from '../type'
import 'colors'
const packageInfo: any = require(path.resolve('package.json'))
class FileUploader {
  bucket?: string
  uploadUrl: string
  domain: string
  env: string
  prefix?: string
  constructor({ bucket, prefix, env }: { bucket?: string; prefix?: string; env: string }) {
    this.env = env
    if (!env) {
      new Error('请传入env')
      return
    }
    this.bucket = bucket || '默认bucket'
    this.prefix = prefix || `${packageInfo.name}/${this.env}/${packageInfo.version}/`
    this.uploadUrl = '接口域名'
    this.domain = 'domain'
  }
  // 获取base
  getBase() {
    return `${this.domain}/${this.prefix}`
  }
  // vite上传插件
  UploadPlugin() {
    const options: Ioptions = {
      assetsDir: '',
      mode: '',
      outDir: ''
    }
    const that = this
    return {
      name: 'vite-plugin-upload',
      configResolved: function(config: any) {
        const outDir = config.build.hasOwnProperty('outDir') ? config.build.outDir : 'dist'
        const outDirArr = outDir.split(path.sep)
        options.outDir = outDirArr[outDirArr.length - 1]
        options.assetsDir = `${options.outDir}/${config.build.assetsDir}`
        options.mode = config.mode
      },
      closeBundle() {
        const files = glob.sync(`${options.assetsDir}/*`)
        files.map((item: any) =&gt; {
          that.uploadPre(path.relative(options.outDir, path.resolve(item)), options.outDir)
        })
      }
    }
  }
  // init判断是否支持此bucket
  init() {
    return new Promise((resolve, reject) =&gt; {
      request.get(
        { url: this.uploadUrl + '/api/bucketList' },
        (err: any, response: { statusCode: any }, body: string) =&gt; {
          const { code, data } = typeof body === 'object' ? body : JSON.parse(body)
          if (err) {
            reject(false)
          }
          if (code !== 0) {
            reject(false)
          } else {
            let cdnInfo = new Map([])
            data.forEach((v: any) =&gt; {
              cdnInfo.set(v.bucket, v.url)
            })
            if (!cdnInfo.has(this.bucket)) {
              throw new Error(`目前仅支持以下bucket${data.map((v: any) =&gt; v.bucket).join(' | ')}`)
            } else {
              this.domain = cdnInfo.get(this.bucket) as string
              resolve(this.getBase())
            }
          }
        }
      )
    })
  }
  // 检查是否存在该文件
  isExistObject(filePath: string) {
    return new Promise(reslove =&gt; {
      request.get(
        {
          url: `${this.uploadUrl}/api/isExistObject?name=${this.prefix + filePath}&amp;bucket=${
            this.bucket
          }`
        },
        (err: any, response: any, body: string) =&gt; {
          if (err) {
            console.log('err', err)
            process.exit(1)
          }
          if (response.statusCode !== 200) {
            console.log('err', 'http err')
            process.exit(1)
          }
          const bodys = JSON.parse(body)
          if (bodys.code === 0) {
            console.log(this.prefix + filePath, '已存在'.yellow)
            reslove(0)
          } else {
            reslove(1)
          }
        }
      )
    })
  }
  // 上传
  upload(filePath: string, outDir: string) {
    return new Promise(reslove =&gt; {
      const formData = {
        key: this.prefix + filePath,
        file: fs.createReadStream(path.resolve(path.join(outDir, filePath))),
        bucket: this.bucket
      }
      request.post(
        {
          url: `${this.uploadUrl}/api/upload`,
          formData
        },
        (err: any, response: any, body: string) =&gt; {
          if (err) {
            console.log('err', err)
            process.exit(1)
          }
          if (response.statusCode !== 200) {
            console.log('err', 'http err')
            process.exit(1)
          }
          const bodys = JSON.parse(body)
          if (bodys.code === 0) {
            console.log(bodys.data.fixUrl, 'success~'.green)
            reslove(1)
          }
        }
      )
    })
  }
  // 上传前检测
  uploadPre(filePath: string, outDir: string) {
    this.isExistObject(filePath).then((res: number) =&gt; {
      if (res === 1) {
        return this.upload(filePath, outDir)
      }
    })
  }
}
export default FileUploader

</code></pre>
<p>我们将它封装到前端组件库中，然后在vite中使用</p>
<pre><code class="language-js">// vite.config.js
import { FileUploader } from '@msb-next/vite-plugin-upload'
const isProd = process.env.VITE_APP_ENV &amp;&amp; process.env.VITE_APP_ENV !== 'dev'
  let plugins = [
    reactRefresh(),
    antdDayjs(),
    vitePluginImp({
      libList: [
        {
          libName: 'lodash',
          libDirectory: '',
          camel2DashComponentName: false,
          style: () =&gt; {
            return false
          },
        },
        {
          libName: 'antd',
          style(name) {
            return `antd/es/${name}/style/index.css`
          },
        },
      ],
    }),
  ]
  let base = '/'
  let sourcemap = true
  //////////////////////////// 主要是这里 /////////////////////////////////////
  if (isProd) {
    const uploader = new FileUploader({
      env: process.env.VITE_APP_ENV,
    })
    // 修改base路径
    base = (await uploader.init()) as string
    plugins.push(uploader.UploadPlugin())
    sourcemap = false
  }
</code></pre>
<p>到这里，其实思路就很清晰了，大家基本能够完成一个自定义vite插件了，下面就是我node层的代码了，大家应该能看明白：<br>
先自定义一个koa中间件</p>
<pre><code class="language-js">const OSS = require('ali-oss');
/**
 * oss 连接oss
 * @param ctx
 * @param next
 * @returns {Promise&lt;void&gt;}
 */
const connect = async (ctx, next) =&gt; {
  let bucket = '';
  if (ctx.request.method === 'POST') {
    const body = ctx.request.body;
    bucket = body.bucket;
  } else {
    bucket = ctx.query.bucket;
  }
  // 从redis中获取oss密钥等重要信息，看看是否支持当前的bucket，这样新增bucket时比较灵活，当然也可以直接写死。
  const ossAccessRes = await redisClient.get('ossAccess');
  const ossAccess = JSON.parse(ossAccessRes);

  const ossConf = ossAccess.find(v =&gt; v.bucket === bucket);
  let client, urlPrefix;
  try {
    client = new OSS(ossConf);
    urlPrefix = ossConf.url;
  } catch (e) {
    ctx.DATA.msg = '暂不支持当前bucket';
    ctx.body = ctx.DATA;
    throw new HttpError(200);
  }
  ctx.OSS = client;
  ctx.urlPrefix = urlPrefix;
  await next();
};

module.exports = {
  connect
};
</code></pre>
<p>router.js</p>
<pre><code class="language-js">const router = require('koa-router')();

// 刚才定义的 oss 中间件
const oss = require('../utils/middleware/oss');

// 控制器
const {index, bucketList} = require('../controllers/index');
const api = require('../controllers/api');

// 添加路由
router.post('/api/upload', oss.connect, api.upload);
router.get('/api/list', oss.connect, api.list);
router.get('/api/url', oss.connect, api.url);
router.post('/api/del', oss.connect, api.del);
router.get('/api/isExistObject', oss.connect, api.isExistObject);
router.get('/api/bucketList', bucketList);

module.exports = router;
</code></pre>
<p>controller/api.js</p>
<pre><code class="language-js">const fs = require('fs');
const {CustomError} = require('../utils/tool/error');
const DEL_SWITCH = false;

/**
 * 上传
 */
const upload = async (ctx) =&gt; {
  const {file} = ctx.request.files;
  const {key} = ctx.request.body;
  const stream = fs.createReadStream(file.path);
  const {name, res, url} = await ctx.OSS.putStream(key, stream);
  ctx.DATA.data = {
    ...res,
    name,
    url,
    fixUrl: `${ctx.urlPrefix}/${name}`
  };
  ctx.body = ctx.DATA;
};

/**
 * 获取oss列表
 */
const list = async (ctx, next) =&gt; {
  const name = ctx.query.name;
  console.log(name);
  ctx.DATA.data = await ctx.OSS.list({
    prefix: name,
    delimiter: '/'
  });
  if (ctx.DATA.data.res.status !== 200) {
    throw new CustomError(0, '文件查找失败');
  }
  delete ctx.DATA.data.res;
  ctx.body = ctx.DATA;
};

/**
 * 获取文件下载链接，有效期1分钟
 */
const url = async (ctx) =&gt; {
  const name = ctx.query.name;
  ctx.DATA.data = ctx.OSS.signatureUrl(name, {expires: 3600});
  ctx.body = ctx.DATA;
};

/**
 * 删除文件、文件夹
 */
const del = async (ctx) =&gt; {
  if (DEL_SWITCH) {
    let dat = ctx.request.body;
    let delList = dat[0];
    let directory = dat[1];
    try {
      for (let i = 0; i &lt; directory.length; i++) {
        let retList = await ctx.OSS.list({
          prefix: directory[i]
        });
        retList.objects.reverse();
        retList.objects.map(item =&gt; {
          delList.push(item.name);
        });
      }
    } catch (e) {
      throw new CustomError(0, '删除文件:整合失败');
    }
    let result = await ctx.OSS.deleteMulti(delList, {quiet: true});
    if (result.res.status !== 200) {
      throw new CustomError(0, '删除失败');
    }
    ctx.DATA.msg = '删除成功';
    ctx.body = ctx.DATA;
  } else {
    ctx.DATA.msg = '删除文件、文件夹功能未开放！';
    ctx.body = ctx.DATA;
  }
};

/**
 * 判断文件是否存在
 * @param ctx
 * @returns {Promise&lt;void&gt;}
 */
const isExistObject = async (ctx) =&gt; {
  // 用于判断受版本控制Bucket中指定versionId的Object是否存在。
  const options = {
    // 填写Object的versionId。
    versionId: ''
  };
  const name = ctx.query.name;
  try {
    const res = await ctx.OSS.head(name, options);
    ctx.DATA.data = res;
    ctx.DATA.msg = '文件存在';
    ctx.body = ctx.DATA;
  }  catch (error) {
    if (error.code === 'NoSuchKey') {
      ctx.DATA.code = 1;
      ctx.DATA.msg = '文件不存在';
      ctx.body = ctx.DATA;
    }
  }
};

module.exports = {
  upload,
  list,
  url,
  del,
  isExistObject,
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义一个WebPack的插件]]></title>
        <id>https://weidadeda.github.io/post/zi-ding-yi-yi-ge-webpack-de-cha-jian</id>
        <link href="https://weidadeda.github.io/post/zi-ding-yi-yi-ge-webpack-de-cha-jian">
        </link>
        <updated>2022-02-14T10:32:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-webpack插件的基本原理">1、webpack插件的基本原理</h3>
<p>我们知道，webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。<br>
webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好。<br>
<a href="https://www.webpackjs.com/contribute/writing-a-plugin/">官网提供的自定义插件文档</a></p>
<blockquote>
<p>tapable 是一个类似于 Node.js 中的 EventEmitter的库，但更专注于自定义事件的触发和处理。webpack 通过 tapable 将实现与流程解耦，所有具体实现通过插件的形式存在。</p>
</blockquote>
<ul>
<li>tapable作为webpack的主模块，需要单独抽一篇出来讲。需要注意的是，如果你要写sdk需要向外层吐露数据的话，建议还是用EventEmitter库，不建议用tapable，因为它销毁全部注册事件不是很容易。<br>
好了，写webpack插件必须要了解tapable，这里我们先简单介绍一下它的几个常用的钩子，其他的可以网上查，这里有篇写的还不错<a href="https://blog.csdn.net/mafan121/article/details/113120081">tapable详解</a></li>
</ul>
<pre><code>const {
  SyncHook,
  SyncBailHook,
  SyncWaterfallHook,
  SyncLoopHook,
  AsyncParallelHook,
  AsyncParallelBailHook,
  AsyncSeriesHook,
  AsyncSeriesBailHook,
  AsyncSeriesWaterfallHook
} = require('tapable');
</code></pre>
<h3 id="tapable通过tap注册一个事件通过call执行该钩子注册的所有事件-tapable的每个hooks都tap一个或多个事件-tapasynccallasync-tappromisepromise用于注册同步执行的异步事件callasync用在并行执行的异步钩子完成后再执行该函数">tapable通过tap注册一个事件，通过call执行该钩子注册的所有事件。tapable的每个hooks都tap一个或多个事件。tapAsync/callAsync、tapPromise/Promise用于注册同步执行的异步事件，callAsync用在并行执行的异步钩子完成后再执行该函数。</h3>
<p>具体使用举个例子（比如SyncHook，依次执行注册事件，无法中断）</p>
<pre><code> const hook = new SyncHook(['name', 'sex'])
  /*
  tap(options,function):
  options是事件描述，可以为一个字符串，也可以为一个对象,为对象时必须包含name属性，描述该插件名称。
  function:回调函数
  */
  // 打印我的名字
  hook.tap('printName', (name) =&gt; {
    console.log('my name is ' + name);
  })
  hook.tap('printSex', (name, sex) =&gt; {
    console.log('I’m a ' + sex);
  })
  // call(arg1,arg2,...)
  hook.call('张三', 'man');

  执行结果：

    my name is 张三

    I’m a man
</code></pre>
<p>好了，说了一堆tapable了，该说webpack插件了。</p>
<p>webpack 插件由以下组成：</p>
<ul>
<li>一个 JavaScript 命名函数。</li>
<li>在插件函数的 prototype 上定义一个 apply 方法。</li>
<li>指定一个绑定到 webpack 自身的事件钩子。</li>
<li>处理 webpack 内部实例的特定数据。</li>
<li>功能完成后调用 webpack 提供的回调。</li>
</ul>
<p>下面是官网的简单例子：</p>
<pre><code class="language-js">// 一个 JavaScript 命名函数。
function MyExampleWebpackPlugin() {

};

// 在插件函数的 prototype 上定义一个 `apply` 方法。
MyExampleWebpackPlugin.prototype.apply = function(compiler) {
  // 指定一个挂载到 webpack 自身的事件钩子。
  compiler.plugin('webpacksEventHook', function(compilation /* 处理 webpack 内部实例的特定数据。*/, callback) {
    console.log(&quot;This is an example plugin!!!&quot;);

    // 功能完成后调用 webpack 提供的回调。
    callback();
  });
};
</code></pre>
<p>在我们使用该plugin的时候，相关调用及配置代码如下：</p>
<pre><code class="language-js">const MyExampleWebpackPlugin = require('./MyExampleWebpackPlugin');
module.exports = {
  plugins: [
    new MyExampleWebpackPlugin(options)
  ]
};
</code></pre>
<p>我开始说了一大堆tapable，其实就是为了说明白webpack插件的原理</p>
<p>用代码说明吧，一个compiler.js，一个main.js<br>
compiler.js</p>
<pre><code class="language-js">// 需要做的事情如下：
// 1. 定义一个 Compiler 类，接收一个options对象参数，该参数是从main.js中的MyPlugin类的实列对象。该对象下有 apply函数。

// 2. 在该类中我们定义了run方法，我们在main.js 中执行该run函数就可以自动执行对应的插件了。

const { SyncHook, AsyncParallelHook } = require('tapable');

class Compiler {
  constructor(options) {
    this.hooks = {
      kzSyncHook: new SyncHook(['name', 'age']),
      kzAsyncHook: new AsyncParallelHook(['name', 'age'])
    };
    let plugins = options.plugins;
    if (plugins &amp;&amp; plugins.length &gt; 0) {
      plugins.forEach(plugin =&gt; plugin.apply(this));
    }
  }
  run() {
    console.log('开始执行了---------');
    this.kzSyncHook('我是小明', 81);
    this.kzAsyncHook('我是小红', 91);
  }
  kzSyncHook(name, age) {
    this.hooks.kzSyncHook.call(name, age);
  }
  kzAsyncHook(name, age) {
    this.hooks.kzAsyncHook.callAsync(name, age);
  }
}

module.exports = Compiler;
</code></pre>
<p>main.js</p>
<pre><code class="language-js">// 需要做的事情如下：
// 1. 引入 compiler.js 文件。
// 2. 定义一个自己的插件，比如叫 MyPlugin 类，该类下有 apply 函数。该函数有一个 compiler 参数，该参数就是我们的 compiler.js 中的实列对象。然后我们会使用 compiler 实列对象去调用 compiler.js 里面的函数。因此就可以自动执行了。
const Compiler = require('./compiler');

class MyPlugin {
  constructor() {
    
  }
  apply(compiler) {
    compiler.hooks.kzSyncHook.tap(&quot;eventName1&quot;, (name, age) =&gt; {
      console.log(`同步事件eventName1： ${name} this year ${age} 周岁了, 可是还是单身`);
    });
    compiler.hooks.kzAsyncHook.tapAsync('eventName2', (name, age) =&gt; {
      setTimeout(() =&gt; {
        console.log(`异步事件eventName2： ${name} this year ${age}周岁了，可是还是单身`);
      }, 1000)
    });
  }
}

const myPlugin = new MyPlugin();

const options = {
  plugins: [myPlugin]
};

const compiler = new Compiler(options);
compiler.run();
</code></pre>
<p>看到没，这种使用方式是不是和官网的使用方式很相似～这回知道原理了吧～</p>
<p>现在看官网的简单例子，webpack启动后，在读取配置的过程中会先执行 new MyExampleWebpackPlugin(options) 初始化MyExampleWebpackPlugin来获得一个实例。<br>
然后我们会把该实例当做参数传递给我们的Compiler对象，然后会实例化 Compiler类(这个逻辑可以结合看我们上面实现了一个简单的demo中 的main.js和compiler.js的代码结合起来理解)。在Compiler类中，我们会获取到options的这个参数，该参数是一个对象，该对象下有一个 plugins 这个属性。<br>
然后遍历该属性，然后依次执行 某项插件中的apply方法，即：myExampleWebpackPlugin.apply(compiler); 给插件传递compiler对象。插件实例获取该compiler对象后，就可以通过 compiler.plugin('事件名称', '回调函数'); 监听到webpack广播出来的事件.(这个地方我们可以看我们上面的main.js中的如下代码可以看到, 在我们的main.js代码中有这样代码：compiler.hooks.kzSyncHook.tap(&quot;eventName1&quot;, (name, age) =&gt; {}));</p>
<p>如上就是一个简单的Plugin的插件原理(切记：结合上面的demo中main.js和compiller.js来理解效果会更好)。</p>
<h3 id="2-compiler-和-compilation">2、Compiler 和 Compilation</h3>
<p>在开发Plugin时我们最常用的两个对象就是 Compiler 和 Compilation, 他们是Plugin和webpack之间的桥梁。</p>
<blockquote>
<p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p>
</blockquote>
<blockquote>
<p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p>
</blockquote>
<h4 id="compiler对象">Compiler对象</h4>
<p>Compiler对象包含了Webpack环境所有的配置信息，包含options，loaders, plugins这些项，这个对象在webpack启动时候被实例化，它是全局唯一的。我们可以把它理解为webpack的实例。</p>
<p>基本源码可以看如下：</p>
<pre><code>// webpack/lib/webpack.js
const Compiler = require(&quot;./Compiler&quot;)

const webpack = (options, callback) =&gt; {
  ...
  // 初始化 webpack 各配置参数
  options = new WebpackOptionsDefaulter().process(options);

  // 初始化 compiler 对象，这里 options.context 为 process.cwd()
  let compiler = new Compiler(options.context);

  compiler.options = options                               // 往 compiler 添加初始化参数

  new NodeEnvironmentPlugin().apply(compiler)              // 往 compiler 添加 Node 环境相关方法

  for (const plugin of options.plugins) {
    plugin.apply(compiler);
  }
  ...
}
</code></pre>
<blockquote>
<p><a href="https://github.com/webpack/webpack/blob/10282ea20648b465caec6448849f24fc34e1ba3e/lib/webpack.js#L30">源码可以点击这里</a></p>
</blockquote>
<p>如上我们可以看到，Compiler对象包含了所有的webpack可配置的内容。开发插件时，我们可以从 compiler 对象中拿到所有和 webpack 主环境相关的内容。</p>
<h4 id="compilation对象">compilation对象</h4>
<p>compilation 对象包含了当前的模块资源、编译生成资源、文件的变化等。当webpack在开发模式下运行时，每当检测到一个文件发生改变的时候，那么一次新的 Compilation将会被创建。从而生成一组新的编译资源。</p>
<p>Compiler对象 与 Compilation 对象 的区别是：Compiler代表了是整个webpack从启动到关闭的生命周期。Compilation 对象只代表了一次新的编译。</p>
<p>Compiler对象的事件钩子:</p>
<pre><code>钩子               作用                     参数               类型
after-plugins     设置完一组初始化插件之后    compiler          sync
after-resolvers   设置完 resolvers 之后     compiler          sync
run               在读取记录之前             compiler          async
compile           在创建新 compilation之前  compilationParams  sync
compilation       compilation 创建完成      compilation        sync
emit              在生成资源并输出到目录之前  compilation        async
after-emit        在生成资源并输出到目录之后  compilation        async
done              完成编译                  stats              sync
</code></pre>
<blockquote>
<p><a href="https://github.com/webpack/webpack/blob/eca7bad8de54c39b9cb8b138793362b8a17ac11b/lib/Compiler.js#L32">源码地址</a></p>
</blockquote>
<h4 id="理解webpack中的事件流">理解webpack中的事件流</h4>
<p>我们可以把webpack理解为一条生产线，需要经过一系列处理流程后才能将源文件转换成输出结果。<br>
这条生产线上的每个处理流程的职责都是单一的，多个流程之间会存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。</p>
<p>我们的插件就像一个插入到生产线中的一个功能，在特定的时机对生产线上的资源会做处理。webpack它是通过 Tapable来组织这条复杂的生产线的。</p>
<p>webpack在运行的过程中会广播事件，插件只需要关心监听它的事件，就能加入到这条生产线中。然后会执行相关的操作。<br>
webpack的事件流机制它能保证了插件的有序性，使整个系统的扩展性好。事件流机制使用了观察者模式来实现的。比如如下代码：</p>
<pre><code>/*
 * 广播事件
 * myPlugin-name 为事件名称
 * params 为附带的参数
*/

compiler.apply('myPlugin-name', params); // myPlugin-name随便写，就是一个名字

/*
 * 监听名称为 'myPlugin-name' 的事件，当 myPlugin-name 事件发生时，函数就会执行。
*/

compiler.hooks.myPlugin-name.tap('myPlugin-name', function(params) {
  
});
</code></pre>
<h3 id="插件中常用的api">插件中常用的API</h3>
<h4 id="compiler生命周期钩子">compiler生命周期钩子</h4>
<p><a href="https://www.webpackjs.com/api/compiler-hooks/">官方文档</a></p>
<blockquote>
<p>Compiler 支持可以监控文件系统的<a href="https://www.webpackjs.com/api/node/#watching">监听(watching)</a>机制，并且在文件修改时重新编译。当处于监听模式(watch mode)时，compiler 会触发诸如 watchRun, watchClose 和 invalid 等额外的事件。通常用于开发环境中使用，也常常会在 webpack-dev-server 这些工具的底层之下调用，由此开发人员无须每次都使用手动方式重新编译。还可以通过 CLI 进入监听模式。</p>
</blockquote>
<p>相关钩子：<br>
以下生命周期钩子函数，是由 compiler 暴露，可以通过如下方式访问：</p>
<pre><code>compiler.hooks.someHook.tap(...)
</code></pre>
<p>取决于不同的钩子类型，也可以在某些钩子上访问 tapAsync 和 tapPromise。</p>
<table>
<thead>
<tr>
<th style="text-align:center">生命周期</th>
<th style="text-align:center">对应hooks</th>
<th style="text-align:center">执行时机</th>
<th style="text-align:center">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">entryOption</td>
<td style="text-align:center">SyncBailHook</td>
<td style="text-align:center">在 entry 配置项处理过之后，执行插件。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">afterPlugins</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">设置完初始插件之后，执行插件。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">afterResolvers</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">resolver 安装完成之后，执行插件。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">environment</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">environment 准备好之后，执行插件。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">afterEnvironment</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">environment 安装完成之后，执行插件。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">beforeRun</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">compiler.run() 执行之前，添加一个钩子。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">开始读取 records 之前，钩入(hook into) compiler。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">watchRun</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">监听模式下，一个新的编译(compilation)触发之后，执行一个插件，但是是在实际编译开始之前。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">normalModuleFactory</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">NormalModuleFactory 创建之后，执行插件。</td>
<td style="text-align:center">normalModuleFactory</td>
</tr>
<tr>
<td style="text-align:center">contextModuleFactory</td>
<td style="text-align:center"></td>
<td style="text-align:center">ContextModuleFactory 创建之后，执行插件。</td>
<td style="text-align:center">contextModuleFactory</td>
</tr>
<tr>
<td style="text-align:center">beforeCompile</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">编译(compilation)参数创建之后，执行插件。</td>
<td style="text-align:center">compilationParams</td>
</tr>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">一个新的编译(compilation)创建之后，钩入(hook into) compiler。</td>
<td style="text-align:center">compilationParams</td>
</tr>
<tr>
<td style="text-align:center">thisCompilation</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">触发 compilation 事件之前执行（查看下面的 compilation）</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">compilation</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">编译(compilation)创建之后，执行插件</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">make</td>
<td style="text-align:center">AsyncParallelHook</td>
<td style="text-align:center"></td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">afterCompile</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center"></td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">shouldEmit</td>
<td style="text-align:center">SyncBailHook</td>
<td style="text-align:center">此时返回 true/false。</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">needAdditionalPass</td>
<td style="text-align:center">SyncBailHook</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">emit</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">生成资源到 output 目录之前。</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">afterEmit</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">生成资源到 output 目录之后。</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">done</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">编译(compilation)完成</td>
<td style="text-align:center">stats</td>
</tr>
<tr>
<td style="text-align:center">failed</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">编译(compilation)失败</td>
<td style="text-align:center">error</td>
</tr>
<tr>
<td style="text-align:center">invalid</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">监听模式下，编译无效时</td>
<td style="text-align:center">fileName, changeTime</td>
</tr>
<tr>
<td style="text-align:center">watchClose</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">监听模式停止</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="读取输出资源-模块及依赖">读取输出资源、模块及依赖</h4>
<p>在我们的emit钩子事件发生时，表示的含义是：源文件的转换和组装已经完成了，在这里事件钩子里面我们可以读取到最终将输出的资源、代码块、模块及对应的依赖文件。并且我们还可以输出资源文件的内容。比如插件代码如下:</p>
<pre><code class="language-js">class MyPlugin {
  apply(compiler) {
    compiler.plugin('emit', function(compilation, callback) {
      // compilation.chunks 是存放了所有的代码块，是一个数组，我们需要遍历
      compilation.chunks.forEach(function(chunk) {
        /*
         * chunk 代表一个代码块，代码块它是由多个模块组成的。
         * 我们可以通过 chunk.forEachModule 能读取组成代码块的每个模块
        */
        chunk.forEachModule(function(module) {
          // module 代表一个模块。
          // module.fileDependencies 存放当前模块的所有依赖的文件路径，它是一个数组
          module.fileDependencies.forEach(function(filepath) {
            console.log(filepath);
          });
        });
        /*
         webpack 会根据chunk去生成输出的文件资源，每个chunk都对应一个及以上的输出文件。
         比如在 Chunk中包含了css 模块并且使用了 ExtractTextPlugin 时，
         那么该Chunk 就会生成 .js 和 .css 两个文件
        */
        chunk.files.forEach(function(filename) {
          // compilation.assets 是存放当前所有即将输出的资源。
          // 调用一个输出资源的 source() 方法能获取到输出资源的内容
          const source = compilation.assets[filename].source();
        });
      });
      /*
       该事件是异步事件，因此要调用 callback 来通知本次的 webpack事件监听结束。
       如果我们没有调用callback(); 那么webpack就会一直卡在这里不会往后执行。
      */
      callback();
    })
  }
}
</code></pre>
<h4 id="监听文件变化">监听文件变化</h4>
<p>webpack读取文件的时候，它会从入口模块去读取，然后依次找出所有的依赖模块。当入口模块或依赖的模块发生改变的时候，那么就会触发一次新的 Compilation。</p>
<p>在我们开发插件的时候，我们需要知道是那个文件发生改变，导致了新的Compilation, 我们可以添加如下代码进行监听。</p>
<pre><code class="language-js">// 当依赖的文件发生改变的时候 会触发 watch-run 事件
class MyPlugin {
  apply(compiler) {
    compiler.plugin('watch-run', (watching, callback) =&gt; {
      // 获取发生变换的文件列表
      const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes;
      // changedFiles 格式为键值对的形式，当键为发生变化的文件路径
      if (changedFiles[filePath] !== undefined) {
        // 对应的文件就发生了变化了
      }
      callback();
    });

    /*
     默认情况下Webpack只会监听入口文件或其依赖的模块是否发生变化，但是在有些情况下比如html文件发生改变的时候，那么webpack
     就会去监听html文件的变化。因此就不会重新触发新的 Compilation。因此为了监听html文件的变化，我们需要把html文件加入到
     依赖列表中。因此我们需要添加如下代码：
    */
    compiler.plugin('after-compile', (compilation, callback) =&gt; {
      /*
       如下的参数filePath是html文件路径，我们把HTML文件添加到文件依赖表中，然后我们的webpack会去监听html模块文件，
       html模板文件发生改变的时候，会重新启动下重新编译一个新的 Compilation.
      */
      compilation.fileDependencies.push(filePath);
      callback();
    })
  }
}
</code></pre>
<h4 id="修改输出资源">修改输出资源</h4>
<p>我们在第一点说过：在我们的emit钩子事件发生时，表示的含义是：源文件的转换和组装已经完成了，在这里事件钩子里面我们可以读取到最终将输出的资源、代码块、模块及对应的依赖文件。因此如果我们现在要修改输出资源的内容的话，我们可以在emit事件中去做修改。那么所有输出的资源会存放在 compilation.assets中，compilation.assets是一个键值对，键为需要输出的文件名，值为文件对应的内容。如下代码：</p>
<pre><code class="language-js">class MyPlugin {
  apply(compiler) {
    compiler.plugin('emit', (compilation, callback) =&gt; {
      // 设置名称为 fileName 的输出资源
      compilation.assets[fileName] = {
        // 返回文件内容
        source: () =&gt; {
          // fileContent 即可以代表文本文件的字符串，也可以是代表二进制文件的buffer
          return fileContent;
        },
        // 返回文件大小
        size: () =&gt; {
          return Buffer.byteLength(fileContent, 'utf8');
        }
      };
      callback();
    });
    // 读取 compilation.assets 代码如下：
    compiler.plugin('emit', (compilation, callback) =&gt; {
      // 读取名称为 fileName 的输出资源
      const asset = compilation.assets[fileName];
      // 获取输出资源的内容
      asset.source();
      // 获取输出资源的文件大小
      asset.size();
      callback();
    });
  }
}
</code></pre>
<h4 id="判断webpack使用了哪些插件">判断webpack使用了哪些插件</h4>
<p>在我们开发一个插件的时候，我们需要根据当前配置是否使用了其他某个插件，我们可以通过读取webpack某个插件配置的情况，比如来判断我们当前是否使用了 HtmlWebpackPlugin 插件。代码如下：</p>
<pre><code class="language-js">/*
 判断当前配置使用了 HtmlWebpackPlugin 插件。
 compiler参数即为 webpack 在 apply(compiler) 中传入的参数
*/

function hasHtmlWebpackPlugin(compiler) {
  // 获取当前配置下所有的插件列表
  const plugins = compiler.options.plugins;
  // 去plugins中寻找有没有 HtmlWebpackPlugin 的实列
  return plugins.find(plugin =&gt; plugin.__proto__.constructor === HtmlWebpackPlugin) !== null;
}
</code></pre>
<h3 id="实战">实战</h3>
<h4 id="实现一个打印日志的logwebpackplugin插件">实现一个打印日志的LogWebpackPlugin插件</h4>
<pre><code class="language-js">// 这个文件为了观看更直观，先放到webpack.config.js中，真正使用时可以将你的自定义webpack插件封装到你们的前端组件库中。
class LogWebpackPlugin {
  constructor(doneCallback, emitCallback) {
    this.emitCallback = emitCallback
    this.doneCallback = doneCallback
  }
  apply(compiler) {
    compiler.hooks.emit.tap('LogWebpackPlugin', () =&gt; {
      // 在 emit 事件中回调 emitCallback
      this.emitCallback();
    });
    compiler.hooks.done.tap('LogWebpackPlugin', (err) =&gt; {
      // 在 done 事件中回调 doneCallback
      this.doneCallback();
    });
    compiler.hooks.compilation.tap('LogWebpackPlugin', () =&gt; {
      // compilation（'编译器'对'编译ing'这个事件的监听）
      console.log(&quot;The compiler is starting a new compilation...&quot;)
    });
    compiler.hooks.compile.tap('LogWebpackPlugin', () =&gt; {
      // compile（'编译器'对'开始编译'这个事件的监听）
      console.log(&quot;The compiler is starting to compile...&quot;)
    });
  }
}


// 使用
module.exports = {
  plugins: [
    new LogWebpackPlugin(() =&gt; {
      // Webpack 模块完成转换成功
      console.log('emit 事件发生啦，所有模块的转换和代码块对应的文件已经生成好~')
    } , () =&gt; {
      // Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作
      console.log('done 事件发生啦，成功构建完成~')
    })
  ]
}
</code></pre>
<h4 id="编写去除生成-bundlejs-中多余的注释的插件">编写去除生成 bundle.js 中多余的注释的插件</h4>
<pre><code class="language-js">class MyPlugin {
  constructor(options) {
    this.options = options;
    this.externalModules = {};
  }
  apply(compiler) {
    var reg = /(&quot;([^\\\&quot;]*(\\.)?)*&quot;)|('([^\\\']*(\\.)?)*')|(\/{2,}.*?(\r|\n))|(\/\*(\n|.)*?\*\/)|(\/\*\*\*\*\*\*\/)/g;
    compiler.hooks.emit.tap('CodeBeautify', (compilation) =&gt; {
      Object.keys(compilation.assets).forEach((data) =&gt; {
        console.log(data);
        let content = compilation.assets[data].source(); // 获取处理的文本
        content = content.replace(reg, function (word) { // 去除注释后的文本
          return /^\/{2,}/.test(word) || /^\/\*!/.test(word) || /^\/\*{3,}\//.test(word) ? &quot;&quot; : word;
        });
        compilation.assets[data] = {
          source() {
            return content;
          },
          size() {
            return content.length;
          }
        }
      });
    });
  }
}
module.exports = MyPlugin;
</code></pre>
<p>这个js代码的真正的含义才是我们今天要讲到的，这个插件最主要作用是 去除注释后的文本。</p>
<ol>
<li>
<p>第一步，我们使用 compiler.hooks.emit 钩子函数。在生成资源并输出到目录之前触发该函数，也就是说将编译好的代码发射到指定的stream中就会触发，然后我们从回调函数返回的 compilation 对象上可以拿到编译好的 stream.</p>
</li>
<li>
<p>访问compilation对象，compilation内部会返回很多内部对象，这边先不打印了，因为打印的话直接会卡死掉，要等很长时间才会打印出来，你们自己可以试试；然后我们遍历 assets.</p>
</li>
</ol>
<pre><code class="language-js">Object.keys(compilation.assets).forEach((data) =&gt; {
  console.log(compilation.assets);
  console.log(8888)
  console.log(data);
});
</code></pre>
<p>如下图所示：<br>
<img src="https://weidadeda.github.io/post-images/1644922971138.png" alt="" loading="lazy"></p>
<ul>
<li>assets 数组对象中的key是资源名。在如上代码，我们通过 Object.key()方法拿到了。如下所示：<pre><code>main.css
bundle.js
index.html
</code></pre>
</li>
<li>然后我们调用 compilation.assets[data].source(); 可以获取资源的内容。</li>
<li>使用正则，去掉注释，如下代码：<pre><code class="language-js">Object.keys(compilation.assets).forEach((data) =&gt; {
  let content = compilation.assets[data].source(); // 获取处理的文本
  content = content.replace(reg, function (word) { // 去除注释后的文本
      return /^\/{2,}/.test(word) || /^\/\*!/.test(word) || /^\/\*{3,}\//.test(word) ? &quot;&quot; : word;
  });
});
</code></pre>
</li>
<li>更新 compilation.assets[data] 对象，如下代码：<pre><code class="language-js">compilation.assets[data] = {
  source() {
      return content;
  },
  size() {
      return content.length;
  }
}
</code></pre>
</li>
<li>最后使用<pre><code class="language-js">module.exports = {
  plugins:[
      new MyPlugin(),
  ]
}
</code></pre>
</li>
</ul>
<h4 id="webpack40之后用compilerhooks注册之前用comlilerplugin注册但为了保险起见还是两种办法都写这样能应付服务器无webpack4版本详见这篇文章">webpack4.0之后用compiler.hooks注册，之前用comliler.plugin注册，但为了保险起见，还是两种办法都写，这样能应付服务器无webpack4版本，详见：<a href="https://www.cnblogs.com/dashnowords/p/9572749.html">这篇文章</a></h4>
<h3 id="最后扩展简单看了几个插件之后是不是可以考虑做些其他的事情比如删除consolelog-或者构建完成时做一些文件上传cdn的操作马上动手吧~">最后扩展：简单看了几个插件之后，是不是可以考虑做些其他的事情，比如删除console.log、或者构建完成时做一些文件上传cdn的操作，马上动手吧～</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[短信短链接唤起APP]]></title>
        <id>https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app</id>
        <link href="https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app">
        </link>
        <updated>2022-02-10T07:59:08.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644479995097.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信公众号获取openid等一系列流程]]></title>
        <id>https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng</id>
        <link href="https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng">
        </link>
        <updated>2022-02-08T12:49:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="先说下为什么要获取-openid">先说下为什么要获取 openid?</h3>
<p>因为用户管理类接口可以通过openid可以获取用户的一些信息的.</p>
<h3 id="说到-openid-必须先说微信授权登录的过程">说到 openid 必须先说微信授权登录的过程</h3>
<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644479416142.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>前端需要在进入路由的是beaforEach的时候，先去判断链接上有没有 openid</p>
</li>
<li>
<p>如果没有，就去跳转到服务端给的一个地址。如果有，就继续往下走（next())</p>
</li>
<li>
<p>这个时候服务端会往下面的链接（https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect来获取code）上跳转，去引导用户去点击授权，用户授权之后就会重定向到 redirect_uri（服务端的地址）</p>
</li>
<li>
<p>利用 code 获取 openid 之后(服务端去做)，服务端会跳转到前端页面(带上openid)</p>
</li>
</ul>
<p>下面作为了解：</p>
<p>微信授权使用的是 OAuth2.0授权方式。主要有以下简略的步骤：<br>
第一步：用户同意授权，获取 code<br>
　　第二步：通过 code获取网页授权access_token<br>
　　第三步：刷新access_token（如果需要）<br>
　　第四步：拉取用户信息(需scope为 snsapi_userinfo)</p>
<h3 id="下面来具体api表示下怎么获取的-code-和-openid-吧">下面来具体api表示下怎么获取的 code 和 openid 吧</h3>
<h3 id="一获取code">一：获取code:</h3>
<p>通过https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect来获取code<br>
参数：<br>
APPID：应用唯一标识<br>
redirect_uri：授权后重定向的回调链接地址，用户同意后，code 会自动添加到后面。（请使用urlEncode对链接进行处理 （$url = urlencode('')） ）<br>
scope：是应用授权作用域 （一般有两种：一种是静默方式（snsapi_base); 一种是非静默方式（snsapi_userinfo），需要用户去手动同意才能获取用户信息）</p>
<p>微信中尤其提醒：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问</p>
<p>** code 是微信自动生成的。并且放在redirect_uri（重定向后的回调链接地址）后面,并且带上code和state参数</p>
<p>上面提到了 code。那么 code又是什么呢？<br>
code:作为换取 access_token的票据，每次用户授权带上的 code 都不一样。5分钟未被使用自动过期（过期的这里下面有讲）</p>
<h3 id="二然后授权成功之后-得到-code-就用-code-去获取access_token">二：然后授权成功之后。得到 code。就用 code 去获取access_token</h3>
<p>https://api.weixin.qq.com/sns/oauth2/access_token?appid=wx41cb8dbd827a16e9&amp;secret=d4624c36b6795d1d99dcf0547af5443d&amp;code=00137323023ab55775be09d6d8e75ffA&amp;grant_type=authorization_code<br>
参数说明：<br>
appid：应用唯一标识<br>
code：上一步已经获取到了<br>
secret：应用密钥AppSecret，在微信开放平台提交应用审核通过后获得</p>
<p>正确的返回<br>
&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, // 接口调用凭证 &quot;expires_in&quot;:7200, // access_token接口调用凭证超时时间 &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, // 用户刷新access_token &quot;openid&quot;:&quot;OPENID&quot;, // 授权用户唯一标识 &quot;scope&quot;:&quot;SCOPE&quot;, // 作用域 等</p>
<h3 id="三通过access_token-openid获取用户信息">三：通过access_token、openid获取用户信息</h3>
<p>https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID<br>
就会得到用户的信息：<br>
得到参数：<br>
openid：用户的唯一标识<br>
nickname：用户昵称<br>
sex： 男女<br>
等。。。<br>
特别注意：<br>
1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）； 2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为； 3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。 建议将secret、用户数据（如access_token）放在App云端服务器，由云端中转接口调用请求。</p>
<h3 id="最后总结下详细的步骤">最后总结下详细的步骤：</h3>
<ul>
<li>1．用户关注微信公众账号。</li>
<li>2．微信公众账号提供用户请求授权页面URL。</li>
<li>3．用户点击授权页面URL，将向服务器发起请求</li>
<li>4．服务器询问用户是否同意授权给微信公众账号(scope为snsapi_base时无此步骤)</li>
<li>5．用户同意(scope为snsapi_base时无此步骤)</li>
<li>6．服务器将CODE通过回调传给微信公众账号</li>
<li>7．微信公众账号获得CODE</li>
<li>8．微信公众账号通过CODE向服务器请求Access Token</li>
<li>9．服务器返回Access Token和OpenID给微信公众账号</li>
<li>10．微信公众账号通过Access Token向服务器请求用户信息(scope为snsapi_base时无此步骤)</li>
<li>11．服务器将用户信息回送给微信公众账号(scope为snsapi_base时无此步骤)</li>
</ul>
<p>公众号链接(官网更权威)：<br>
https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</p>
<p>https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何比较 React Hooks 上的旧值和新值？]]></title>
        <id>https://weidadeda.github.io/post/ru-he-bi-jiao-react-hooks-shang-de-jiu-zhi-he-xin-zhi</id>
        <link href="https://weidadeda.github.io/post/ru-he-bi-jiao-react-hooks-shang-de-jiu-zhi-he-xin-zhi">
        </link>
        <updated>2022-01-27T12:24:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="自定义hooks">自定义hooks</h3>
<pre><code class="language-js">function usePrevious(value) {
  const ref = useRef();
  useEffect(() =&gt; {
    ref.current = value;
  });
  return ref.current;
}
</code></pre>
<h3 id="使用">使用</h3>
<pre><code class="language-js">const Component = (props) =&gt; {
    const {valueA, valueB} = props
    
    const prevValue = usePrevious({valueA, valueB});
    useEffect(() =&gt; {
        if(prevValue.valueA !== valueA) {
           ...
       }
        if(prevValue.valueB !== valueB) {
           ...
        }
    }, [valueA, valueB])
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[useCallback 和 useMemo 的区别]]></title>
        <id>https://weidadeda.github.io/post/usecallback-he-usememo-de-qu-bie</id>
        <link href="https://weidadeda.github.io/post/usecallback-he-usememo-de-qu-bie">
        </link>
        <updated>2022-01-11T03:32:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="区别概览">区别概览</h3>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">useCallBack</th>
<th style="text-align:center">useMemo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">返回值</td>
<td style="text-align:center">一个缓存的回调函数</td>
<td style="text-align:center">一个缓存的值</td>
</tr>
<tr>
<td style="text-align:center">参数</td>
<td style="text-align:center">需要缓存的函数，依赖项</td>
<td style="text-align:center">需要缓存的值(也可以是个计算然后再返回值的函数) ，依赖项</td>
</tr>
<tr>
<td style="text-align:center">使用场景</td>
<td style="text-align:center">父组件更新时，通过props传递给子组件的函数也会重新创建，然后这个时候使用 useCallBack 就可以缓存函数不使它重新创建</td>
<td style="text-align:center">组件更新时，一些计算量很大的值也有可能被重新计算，这个时候就可以使用 useMemo 直接使用上一次缓存的值</td>
</tr>
</tbody>
</table>
<h3 id="usecallback-具体示例">useCallBack 具体示例</h3>
<p><a href="https://codesandbox.io/s/usecallback-1w9f1?file=/src/App.jsx">codesanbox在线示例</a></p>
<pre><code class="language-js">import React, { useCallback, useEffect, useState } from &quot;react&quot;;
import &quot;./styles.css&quot;;

export default function App() {
  const [count, setCount] = useState(0);

  // 使用 useCallBack 缓存
  const handleCountAddByCallBack = useCallback(() =&gt; {
    setCount((count) =&gt; count + 1);
  }, []);

  // 不缓存，每次 count 更新时都会重新创建
  const handleCountAdd = () =&gt; {
    setCount((count) =&gt; count + 1);
  };

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;h3&gt;CountAddByChild1: {count}&lt;/h3&gt;
      &lt;Child1 addByCallBack={handleCountAddByCallBack} add={handleCountAdd} /&gt;
    &lt;/div&gt;
  );
}

const Child1 = React.memo(function (props) {
  const { add, addByCallBack } = props;
  
  // 没有缓存，由于每次都创建，memo 认为两次地址都不同，属于不同的函数，所以会触发 useEffect
  useEffect(() =&gt; {
    console.log(&quot;Child1----addFcUpdate&quot;, props);
  }, [add]);

  // 有缓存，memo 判定两次地址都相同，所以不触发 useEffect
  useEffect(() =&gt; {
    console.log(&quot;Child1----addByCallBackFcUpdate&quot;, props);
  }, [addByCallBack]);

  return (
    &lt;div&gt;
      &lt;button onClick={props.add}&gt;+1&lt;/button&gt;
      &lt;br /&gt;
      &lt;button onClick={props.addByCallBack}&gt;+1(addByCallBack)&lt;/button&gt;
    &lt;/div&gt;
  );
});
</code></pre>
<h3 id="usememo-示例">useMemo 示例</h3>
<p><a href="https://codesandbox.io/s/usememo-p9t7e?file=/src/App.jsx">codesandbox 在线示例</a></p>
<pre><code class="language-js">import { useState, useMemo } from &quot;react&quot;;
import &quot;./styles.css&quot;;

export default function App() {
  const [count, setCount] = useState(0);
  const [total, setTotal] = useState(0);

  // 没有使用 useMemo，即使是更新 total, countToString 也会重新计算
  const countToString = (() =&gt; {
    console.log(&quot;countToString 被调用&quot;);
    return count.toString();
  })();

  // 使用了 useMemo, 只有 total 改变，才会重新计算
  const totalToStringByMemo = useMemo(() =&gt; {
    console.log(&quot;totalToStringByMemo 被调用&quot;);
    return total + &quot;&quot;;
  }, [total]);

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;h3&gt;countToString: {countToString}&lt;/h3&gt;
      &lt;h3&gt;countToString: {totalToStringByMemo}&lt;/h3&gt;
      &lt;button
        onClick={() =&gt; {
          setCount((count) =&gt; count + 1);
        }}
      &gt;
        Add Count
      &lt;/button&gt;
      &lt;br /&gt;
      &lt;button
        onClick={() =&gt; {
          setTotal((total) =&gt; total + 1);
        }}
      &gt;
        Add Total
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="小结">小结</h3>
<ul>
<li>共同作用：仅仅 依赖数据 发生变化, 才会重新计算结果，也就是起到缓存的作用</li>
<li>区别
<ul>
<li>useCallBack 针对可能重新创建的函数进行优化，使得函数被缓存，React.memo 认定两次地址是相同就可以避免子组件冗余的更新。</li>
<li>useMemo 针对不必要的计算进行优化，避免了当前组件中一些的冗余计算操作。</li>
</ul>
</li>
</ul>
<p>转载自：https://www.jianshu.com/p/b8d27018ed22</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用React Hooks更新对象或数组的值]]></title>
        <id>https://weidadeda.github.io/post/shi-yong-react-hooks-geng-xin-dui-xiang-huo-shu-zu-de-zhi</id>
        <link href="https://weidadeda.github.io/post/shi-yong-react-hooks-geng-xin-dui-xiang-huo-shu-zu-de-zhi">
        </link>
        <updated>2022-01-07T13:58:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="对象类型">对象类型</h3>
<pre><code class="language-js">import React, { useState } from 'react';

const Index = ()=&gt; {
  const [obj, setObj] = useState({name:&quot;zhangsan&quot;});

  return (
    &lt;&gt;
      &lt;h2&gt;{obj.name}---{obj.age}&lt;/h2&gt;	  
      &lt;button onClick={()=&gt; (
		setObj({
		  ...obj,
		  age:18
		})
	  )}&gt;change-obj&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="数组类型">数组类型</h3>
<pre><code class="language-js">import React, { useState } from 'react';

const Index = ()=&gt; {
  const [arr, setArr] = useState([1,2,3]);

  return (
    &lt;&gt;

      &lt;h2&gt;{arr}&lt;/h2&gt;
      &lt;button onClick={()=&gt;(setArr(
		setarr(()=&gt; {
		  arr.push(4);
		  return [...arr]
		})&gt;change-arr&lt;/button&gt;

    &lt;/&gt;
  );
}
</code></pre>
]]></content>
    </entry>
</feed>