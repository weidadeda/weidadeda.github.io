<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://weidadeda.github.io</id>
    <title>大伟的博客</title>
    <updated>2022-02-18T09:32:22.626Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://weidadeda.github.io"/>
    <link rel="self" href="https://weidadeda.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://weidadeda.github.io/images/avatar.png</logo>
    <icon>https://weidadeda.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 大伟的博客</rights>
    <entry>
        <title type="html"><![CDATA[vite自定义上传插件]]></title>
        <id>https://weidadeda.github.io/post/vite-zi-ding-yi-cha-jian</id>
        <link href="https://weidadeda.github.io/post/vite-zi-ding-yi-cha-jian">
        </link>
        <updated>2022-02-15T11:53:23.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://vitejs.cn/guide/api-plugin.html">vite官网自定义插件</a></p>
<p>Vite 插件扩展了设计出色的 Rollup 接口，带有一些 Vite 独有的配置项。因为vite是使用rollup打包的所以最好你能了解<a href="https://rollupjs.org/guide/en/#plugin-development">Rollup 插件文档</a></p>
<blockquote>
<p>下面的都是按照官网介绍写的，因为毕竟你看到我这了，直接给你个链接再让你跳转到官网去看有点不负责任，如果你已经从官网看过了，并且对自定义插件很熟悉了，那么请直接到最下面看 <a href="#test">项目实战部分</a></p>
</blockquote>
<h3 id="约定">约定</h3>
<p>如果插件不使用 Vite 特有的钩子，可以作为 <a href="https://vitejs.cn/guide/api-plugin.html#rollup-plugin-compatibility">兼容 Rollup 的插件</a> 来实现，推荐使用 <a href="https://rollupjs.org/guide/en/#conventions">Rollup 插件名称约定</a>。</p>
<ul>
<li>Rollup 插件应该有一个带 rollup-plugin- 前缀、语义清晰的名称。</li>
<li>在 package.json 中包含 rollup-plugin 和 vite-plugin 关键字。</li>
</ul>
<p>这样，插件也可以用于纯 Rollup 或基于 WMR 的项目。</p>
<p>对于 Vite 专属的插件：</p>
<ul>
<li>Vite 插件应该有一个带 vite-plugin- 前缀、语义清晰的名称。</li>
<li>在 package.json 中包含 vite-plugin 关键字。</li>
<li>在插件文档增加一部分关于为什么本插件是一个 Vite 专属插件的详细说明（如，本插件使用了 Vite 特有的插件钩子）。</li>
</ul>
<p>如果你的插件只适用于特定的框架，它的名字应该遵循以下前缀格式：</p>
<ul>
<li>vite-plugin-vue- 前缀作为 Vue 插件</li>
<li>vite-plugin-react- 前缀作为 React 插件</li>
<li>vite-plugin-svelte- 前缀作为 Svelte 插件</li>
</ul>
<h3 id="插件配置">插件配置</h3>
<p>用户会将插件添加到项目的 devDependencies 中并使用数组形式的 plugins 选项配置它们。</p>
<pre><code class="language-js">// vite.config.js
import vitePlugin from 'vite-plugin-feature'
import rollupPlugin from 'rollup-plugin-feature'

export default defineConfig({
  plugins: [vitePlugin(), rollupPlugin()]
})
</code></pre>
<p>假值的插件将被忽略，可以用来轻松地启用或停用插件。</p>
<p>plugins 也可以接受将多个插件作为单个元素的预设。这对于使用多个插件实现的复杂特性（如框架集成）很有用。该数组将在内部被扁平化（flatten）。</p>
<pre><code class="language-js">// 框架插件
import frameworkRefresh from 'vite-plugin-framework-refresh'
import frameworkDevtools from 'vite-plugin-framework-devtools'

export default function framework(config) {
  return [frameworkRefresh(config), frameworkDevTools(config)]
}
</code></pre>
<pre><code class="language-js">// vite.config.js
import { defineConfig } from 'vite'
import framework from 'vite-plugin-framework'

export default defineConfig({
  plugins: [framework()]
})
</code></pre>
<h3 id="简单示例">简单示例</h3>
<blockquote>
<p>TIP<br>
通常的惯例是创建一个 Vite/Rollup 插件作为一个返回实际插件对象的工厂函数。该函数可以接受允许用户自定义插件行为的选项。</p>
</blockquote>
<h4 id="转换自定义文件类型">转换自定义文件类型</h4>
<pre><code class="language-js">const fileRegex = /\.(my-file-ext)$/

export default function myPlugin() {
  return {
    name: 'transform-file',

    transform(src, id) {
      if (fileRegex.test(id)) {
        return {
          code: compileFileToJS(src),
          map: null // 如果可行将提供 source map
        }
      }
    }
  }
}
</code></pre>
<h3 id="通用钩子">通用钩子</h3>
<p>在开发中，Vite 开发服务器会创建一个插件容器来调用 <a href="https://rollupjs.org/guide/en/#build-hooks">Rollup 构建钩子</a>，与 Rollup 如出一辙。</p>
<p>以下钩子在服务器启动时被调用：</p>
<ul>
<li>
<p>options</p>
</li>
<li>
<p>buildStart<br>
以下钩子会在每个传入模块请求时被调用：</p>
</li>
<li>
<p>resolveId</p>
</li>
<li>
<p>load</p>
</li>
<li>
<p>transform<br>
以下钩子在服务器关闭时被调用：</p>
</li>
<li>
<p>buildEnd</p>
</li>
<li>
<p>closeBundle<br>
请注意 moduleParsed 钩子在开发中是 不会 被调用的，因为 Vite 为了性能会避免完整的 AST 解析。<br>
Output Generation Hooks（除了 closeBundle) 在开发中是 不会 被调用的。你可以认为 Vite 的开发服务器只调用了 rollup.rollup() 而没有调用 bundle.generate()。<br>
<img src="https://weidadeda.github.io/post-images/1645006280268.jpeg" alt="" loading="lazy"></p>
</li>
</ul>
<h3 id="vite-独有钩子">Vite 独有钩子</h3>
<p>Vite 插件也可以提供钩子来服务于特定的 Vite 目标。这些钩子会被 Rollup 忽略。</p>
<h4 id="config">config</h4>
<ul>
<li>
<p>类型： (config: UserConfig, env: { mode: string, command: string }) =&gt; UserConfig | null | void</p>
</li>
<li>
<p>种类： async, sequential</p>
</li>
</ul>
<p>在解析 Vite 配置前调用。钩子接收原始用户配置（命令行选项指定的会与配置文件合并）和一个描述配置环境的变量，包含正在使用的 mode 和 command。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置（如果默认的合并不能达到预期的结果）。</p>
<p>示例：</p>
<pre><code class="language-js">// 返回部分配置（推荐）
const partialConfigPlugin = () =&gt; ({
  name: 'return-partial',
  config: () =&gt; ({
    alias: {
      foo: 'bar'
    }
  })
})

// 直接改变配置（应仅在合并不起作用时使用）
const mutateConfigPlugin = () =&gt; ({
  name: 'mutate-config',
  config(config, { command }) {
    if (command === 'build') {
      config.root = __dirname
    }
  }
})
</code></pre>
<blockquote>
<p>注意<br>
用户插件在运行这个钩子之前会被解析，因此在 config 钩子中注入其他插件不会有任何效果。</p>
</blockquote>
<h4 id="configresolved">configResolved</h4>
<ul>
<li>
<p>类型： (config: ResolvedConfig) =&gt; void | Promise<void></p>
</li>
<li>
<p>种类： async, parallel</p>
</li>
</ul>
<p>在解析 Vite 配置后调用。使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。</p>
<p>示例：</p>
<pre><code class="language-js">const exmaplePlugin = () =&gt; {
  let config

  return {
    name: 'read-config',

    configResolved(resolvedConfig) {
      // 存储最终解析的配置
      config = resolvedConfig
    },

    // 在其他钩子中使用存储的配置
    transform(code, id) {
      if (config.command === 'serve') {
        // dev: 由开发服务器调用的插件
      } else {
        // build: 由 Rollup 调用的插件
      }
    }
  }
}
</code></pre>
<blockquote>
<p>注意，在开发环境下，command 的值为 serve（在 CLI 中，vite 和 vite dev 是 vite serve 的别名）。</p>
</blockquote>
<h4 id="configureserver">configureServer</h4>
<ul>
<li>
<p>类型： (server: ViteDevServer) =&gt; (() =&gt; void) | void | Promise&lt;(() =&gt; void) | void&gt;</p>
</li>
<li>
<p>种类： async, sequential</p>
</li>
<li>
<p>此外请看 <a href="https://vitejs.cn/guide/api-javascript.html#vitedevserver">ViteDevServer</a></p>
</li>
</ul>
<p>是用于配置开发服务器的钩子。最常见的用例是在内部 connect 应用程序中添加自定义中间件:</p>
<pre><code class="language-js">const myPlugin = () =&gt; ({
  name: 'configure-server',
  configureServer(server) {
    server.middlewares.use((req, res, next) =&gt; {
      // 自定义请求处理...
    })
  }
})
</code></pre>
<p>注入后置中间件</p>
<p>configureServer 钩子将在内部中间件被安装前调用，所以自定义的中间件将会默认会比内部中间件早运行。如果你想注入一个在内部中间件 之后 运行的中间件，你可以从 configureServer 返回一个函数，将会在内部中间件安装后被调用：</p>
<pre><code class="language-js">const myPlugin = () =&gt; ({
  name: 'configure-server',
  configureServer(server) {
    // 返回一个在内部中间件安装后
    // 被调用的后置钩子
    return () =&gt; {
      server.middlewares.use((req, res, next) =&gt; {
        // 自定义请求处理...
      })
    }
  }
})
</code></pre>
<p>存储服务器访问</p>
<p>在某些情况下，其他插件钩子可能需要访问开发服务器实例（例如访问 websocket 服务器、文件系统监视程序或模块图）。这个钩子也可以用来存储服务器实例以供其他钩子访问:</p>
<pre><code class="language-js">const myPlugin = () =&gt; {
  let server
  return {
    name: 'configure-server',
    configureServer(_server) {
      server = _server
    },
    transform(code, id) {
      if (server) {
        // 使用 server...
      }
    }
  }
}
</code></pre>
<p>注意 configureServer 在运行生产版本时不会被调用，所以其他钩子需要防范它缺失。</p>
<h4 id="transformindexhtml">transformIndexHtml</h4>
<ul>
<li>
<p>类型： IndexHtmlTransformHook | { enforce?: 'pre' | 'post', transform: IndexHtmlTransformHook }</p>
</li>
<li>
<p>种类： async, sequential</p>
</li>
</ul>
<p>转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文。上下文在开发期间暴露ViteDevServer实例，在构建期间暴露 Rollup 输出的包。<br>
这个钩子可以是异步的，并且可以返回以下其中之一:</p>
<ul>
<li>经过转换的 HTML 字符串</li>
<li>注入到现有 HTML 中的标签描述符对象数组（{ tag, attrs, children }）。每个标签也可以指定它应该被注入到哪里（默认是在 <head> 之前）</li>
<li>一个包含 { html, tags } 的对象</li>
</ul>
<p>基础示例：</p>
<pre><code class="language-js">const htmlPlugin = () =&gt; {
  return {
    name: 'html-transform',
    transformIndexHtml(html) {
      return html.replace(
        /&lt;title&gt;(.*?)&lt;\/title&gt;/,
        `&lt;title&gt;Title replaced!&lt;/title&gt;`
      )
    }
  }
}
</code></pre>
<h4 id="handlehotupdate">handleHotUpdate</h4>
<ul>
<li>类型： (ctx: HmrContext) =&gt; Array<ModuleNode> | void | Promise&lt;Array<ModuleNode> | void&gt;</li>
</ul>
<p>执行自定义 HMR 更新处理。钩子接收一个带有以下签名的上下文对象：</p>
<pre><code class="language-js">interface HmrContext {
  file: string
  timestamp: number
  modules: Array&lt;ModuleNode&gt;
  read: () =&gt; string | Promise&lt;string&gt;
  server: ViteDevServer
}
</code></pre>
<ul>
<li>
<p>modules 是受更改文件影响的模块数组。它是一个数组，因为单个文件可能映射到多个服务模块（例如 Vue 单文件组件）。</p>
</li>
<li>
<p>read 这是一个异步读函数，它返回文件的内容。之所以这样做，是因为在某些系统上，文件更改的回调函数可能会在编辑器完成文件更新之前过快地触发，并 fs.readFile 直接会返回空内容。传入的 read 函数规范了这种行为。</p>
</li>
</ul>
<p>钩子可以选择:</p>
<ul>
<li>
<p>过滤和缩小受影响的模块列表，使 HMR 更准确。</p>
</li>
<li>
<p>返回一个空数组，并通过向客户端发送自定义事件来执行完整的自定义 HMR 处理:</p>
</li>
</ul>
<pre><code class="language-js">handleHotUpdate({ server }) {
  server.ws.send({
    type: 'custom',
    event: 'special-update',
    data: {}
  })
  return []
}
</code></pre>
<p>客户端代码应该使用 <a href="https://vitejs.cn/guide/api-hmr.html">HMR API</a> 注册相应的处理器（这应该被相同插件的 transform 钩子注入）：</p>
<pre><code class="language-js">if (import.meta.hot) {
  import.meta.hot.on('special-update', (data) =&gt; {
    // 执行自定义更新
  })
}
</code></pre>
<h3 id="插件顺序">插件顺序</h3>
<p>一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。解析后的插件将按照以下顺序排列：</p>
<ul>
<li>Alias</li>
<li>带有 enforce: 'pre' 的用户插件</li>
<li>Vite 核心插件</li>
<li>没有 enforce 值的用户插件</li>
<li>Vite 构建用的插件</li>
<li>带有 enforce: 'post' 的用户插件</li>
<li>Vite 后置构建插件（最小化，manifest，报告）</li>
</ul>
<h3 id="情景应用">情景应用</h3>
<p>默认情况下插件在开发（serve）和构建（build）模式中都会调用。如果插件只需要在预览或构建期间有条件地应用，请使用 apply 属性指明它们仅在 'build' 或 'serve' 模式时调用：</p>
<pre><code class="language-js">function myPlugin() {
  return {
    name: 'build-only',
    apply: 'build' // 或 'serve'
  }
}
</code></pre>
<p>同时，还可以使用函数来进行更精准的控制：</p>
<pre><code class="language-js">apply(config, { command }) {
  // 非 SSR 情况下的 build
  return command === 'build' &amp;&amp; !config.build.ssr
}
</code></pre>
<h3 id="rollup-插件兼容性">Rollup 插件兼容性</h3>
<p>相当数量的 Rollup 插件将直接作为 Vite 插件工作（例如：@rollup/plugin-alias 或 @rollup/plugin-json），但并不是所有的，因为有些插件钩子在非构建式的开发服务器上下文中没有意义。</p>
<p>一般来说，只要 Rollup 插件符合以下标准，它就应该像 Vite 插件一样工作：</p>
<ul>
<li>没有使用 moduleParsed 钩子。</li>
<li>它在打包钩子和输出钩子之间没有很强的耦合。</li>
</ul>
<p>如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。</p>
<p>你也可以用 Vite 独有的属性来扩展现有的 Rollup 插件:</p>
<pre><code class="language-js">// vite.config.js
import example from 'rollup-plugin-example'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      ...example(),
      enforce: 'post',
      apply: 'build'
    }
  ]
})
</code></pre>
<p>查看 <a href="https://vite-rollup-plugins.patak.dev/">Vite Rollup 插件</a> 获取兼容的官方 Rollup 插件列表及其使用指南。</p>
<h3 id="a-idtest-nametest项目实战a"><a id="test" name="test">项目实战</a></h3>
<p>先说下我们要做什么，我们用vite打包完之后需要将打包出来的静态资源上传到cdn上，但现有的插件不够灵活，比如<a href="https://www.npmjs.com/package/vite-plugin-assets-uploader">vite-plugin-assets-uploader<br>
</a>这个很好，但是需要将oss的密钥等信息写在前端，不够安全。对此我们就用node写了个接口，前端只需要调用node接口就能够上传到oss。而且将代码上传到cdn之后，我们的base路径也要改成cdn的路径。</p>
<p>自定义上传插件代码如下：</p>
<pre><code class="language-js">/* eslint-disable no-prototype-builtins */
/* eslint-disable no-self-assign */
const path = require('path')
const fs = require('fs-extra')
const request = require('request')
const glob = require('glob')
import { Ioptions } from '../type'
import 'colors'
const packageInfo: any = require(path.resolve('package.json'))
class FileUploader {
  bucket?: string
  uploadUrl: string
  domain: string
  env: string
  prefix?: string
  constructor({ bucket, prefix, env }: { bucket?: string; prefix?: string; env: string }) {
    this.env = env
    if (!env) {
      new Error('请传入env')
      return
    }
    this.bucket = bucket || '默认bucket'
    this.prefix = prefix || `${packageInfo.name}/${this.env}/${packageInfo.version}/`
    this.uploadUrl = '接口域名'
    this.domain = 'domain'
  }
  // 获取base
  getBase() {
    return `${this.domain}/${this.prefix}`
  }
  // vite上传插件
  UploadPlugin() {
    const options: Ioptions = {
      assetsDir: '',
      mode: '',
      outDir: ''
    }
    const that = this
    return {
      name: 'vite-plugin-upload',
      configResolved: function(config: any) {
        const outDir = config.build.hasOwnProperty('outDir') ? config.build.outDir : 'dist'
        const outDirArr = outDir.split(path.sep)
        options.outDir = outDirArr[outDirArr.length - 1]
        options.assetsDir = `${options.outDir}/${config.build.assetsDir}`
        options.mode = config.mode
      },
      closeBundle() {
        const files = glob.sync(`${options.assetsDir}/*`)
        files.map((item: any) =&gt; {
          that.uploadPre(path.relative(options.outDir, path.resolve(item)), options.outDir)
        })
      }
    }
  }
  // init判断是否支持此bucket
  init() {
    return new Promise((resolve, reject) =&gt; {
      request.get(
        { url: this.uploadUrl + '/api/bucketList' },
        (err: any, response: { statusCode: any }, body: string) =&gt; {
          const { code, data } = typeof body === 'object' ? body : JSON.parse(body)
          if (err) {
            reject(false)
          }
          if (code !== 0) {
            reject(false)
          } else {
            let cdnInfo = new Map([])
            data.forEach((v: any) =&gt; {
              cdnInfo.set(v.bucket, v.url)
            })
            if (!cdnInfo.has(this.bucket)) {
              throw new Error(`目前仅支持以下bucket${data.map((v: any) =&gt; v.bucket).join(' | ')}`)
            } else {
              this.domain = cdnInfo.get(this.bucket) as string
              resolve(this.getBase())
            }
          }
        }
      )
    })
  }
  // 检查是否存在该文件
  isExistObject(filePath: string) {
    return new Promise(reslove =&gt; {
      request.get(
        {
          url: `${this.uploadUrl}/api/isExistObject?name=${this.prefix + filePath}&amp;bucket=${
            this.bucket
          }`
        },
        (err: any, response: any, body: string) =&gt; {
          if (err) {
            console.log('err', err)
            process.exit(1)
          }
          if (response.statusCode !== 200) {
            console.log('err', 'http err')
            process.exit(1)
          }
          const bodys = JSON.parse(body)
          if (bodys.code === 0) {
            console.log(this.prefix + filePath, '已存在'.yellow)
            reslove(0)
          } else {
            reslove(1)
          }
        }
      )
    })
  }
  // 上传
  upload(filePath: string, outDir: string) {
    return new Promise(reslove =&gt; {
      const formData = {
        key: this.prefix + filePath,
        file: fs.createReadStream(path.resolve(path.join(outDir, filePath))),
        bucket: this.bucket
      }
      request.post(
        {
          url: `${this.uploadUrl}/api/upload`,
          formData
        },
        (err: any, response: any, body: string) =&gt; {
          if (err) {
            console.log('err', err)
            process.exit(1)
          }
          if (response.statusCode !== 200) {
            console.log('err', 'http err')
            process.exit(1)
          }
          const bodys = JSON.parse(body)
          if (bodys.code === 0) {
            console.log(bodys.data.fixUrl, 'success~'.green)
            reslove(1)
          }
        }
      )
    })
  }
  // 上传前检测
  uploadPre(filePath: string, outDir: string) {
    this.isExistObject(filePath).then((res: number) =&gt; {
      if (res === 1) {
        return this.upload(filePath, outDir)
      }
    })
  }
}
export default FileUploader

</code></pre>
<p>我们将它封装到前端组件库中，然后在vite中使用</p>
<pre><code class="language-js">// vite.config.js
import { FileUploader } from '@msb-next/vite-plugin-upload'
const isProd = process.env.VITE_APP_ENV &amp;&amp; process.env.VITE_APP_ENV !== 'dev'
  let plugins = [
    reactRefresh(),
    antdDayjs(),
    vitePluginImp({
      libList: [
        {
          libName: 'lodash',
          libDirectory: '',
          camel2DashComponentName: false,
          style: () =&gt; {
            return false
          },
        },
        {
          libName: 'antd',
          style(name) {
            return `antd/es/${name}/style/index.css`
          },
        },
      ],
    }),
  ]
  let base = '/'
  let sourcemap = true
  //////////////////////////// 主要是这里 /////////////////////////////////////
  if (isProd) {
    const uploader = new FileUploader({
      env: process.env.VITE_APP_ENV,
    })
    // 修改base路径
    base = (await uploader.init()) as string
    plugins.push(uploader.UploadPlugin())
    sourcemap = false
  }
</code></pre>
<p>到这里，其实思路就很清晰了，大家基本能够完成一个自定义vite插件了，下面就是我node层的代码了，大家应该能看明白：<br>
先自定义一个koa中间件</p>
<pre><code class="language-js">const OSS = require('ali-oss');
/**
 * oss 连接oss
 * @param ctx
 * @param next
 * @returns {Promise&lt;void&gt;}
 */
const connect = async (ctx, next) =&gt; {
  let bucket = '';
  if (ctx.request.method === 'POST') {
    const body = ctx.request.body;
    bucket = body.bucket;
  } else {
    bucket = ctx.query.bucket;
  }
  // 从redis中获取oss密钥等重要信息，看看是否支持当前的bucket，这样新增bucket时比较灵活，当然也可以直接写死。
  const ossAccessRes = await redisClient.get('ossAccess');
  const ossAccess = JSON.parse(ossAccessRes);

  const ossConf = ossAccess.find(v =&gt; v.bucket === bucket);
  let client, urlPrefix;
  try {
    client = new OSS(ossConf);
    urlPrefix = ossConf.url;
  } catch (e) {
    ctx.DATA.msg = '暂不支持当前bucket';
    ctx.body = ctx.DATA;
    throw new HttpError(200);
  }
  ctx.OSS = client;
  ctx.urlPrefix = urlPrefix;
  await next();
};

module.exports = {
  connect
};
</code></pre>
<p>router.js</p>
<pre><code class="language-js">const router = require('koa-router')();

// 刚才定义的 oss 中间件
const oss = require('../utils/middleware/oss');

// 控制器
const {index, bucketList} = require('../controllers/index');
const api = require('../controllers/api');

// 添加路由
router.post('/api/upload', oss.connect, api.upload);
router.get('/api/list', oss.connect, api.list);
router.get('/api/url', oss.connect, api.url);
router.post('/api/del', oss.connect, api.del);
router.get('/api/isExistObject', oss.connect, api.isExistObject);
router.get('/api/bucketList', bucketList);

module.exports = router;
</code></pre>
<p>controller/api.js</p>
<pre><code class="language-js">const fs = require('fs');
const {CustomError} = require('../utils/tool/error');
const DEL_SWITCH = false;

/**
 * 上传
 */
const upload = async (ctx) =&gt; {
  const {file} = ctx.request.files;
  const {key} = ctx.request.body;
  const stream = fs.createReadStream(file.path);
  const {name, res, url} = await ctx.OSS.putStream(key, stream);
  ctx.DATA.data = {
    ...res,
    name,
    url,
    fixUrl: `${ctx.urlPrefix}/${name}`
  };
  ctx.body = ctx.DATA;
};

/**
 * 获取oss列表
 */
const list = async (ctx, next) =&gt; {
  const name = ctx.query.name;
  console.log(name);
  ctx.DATA.data = await ctx.OSS.list({
    prefix: name,
    delimiter: '/'
  });
  if (ctx.DATA.data.res.status !== 200) {
    throw new CustomError(0, '文件查找失败');
  }
  delete ctx.DATA.data.res;
  ctx.body = ctx.DATA;
};

/**
 * 获取文件下载链接，有效期1分钟
 */
const url = async (ctx) =&gt; {
  const name = ctx.query.name;
  ctx.DATA.data = ctx.OSS.signatureUrl(name, {expires: 3600});
  ctx.body = ctx.DATA;
};

/**
 * 删除文件、文件夹
 */
const del = async (ctx) =&gt; {
  if (DEL_SWITCH) {
    let dat = ctx.request.body;
    let delList = dat[0];
    let directory = dat[1];
    try {
      for (let i = 0; i &lt; directory.length; i++) {
        let retList = await ctx.OSS.list({
          prefix: directory[i]
        });
        retList.objects.reverse();
        retList.objects.map(item =&gt; {
          delList.push(item.name);
        });
      }
    } catch (e) {
      throw new CustomError(0, '删除文件:整合失败');
    }
    let result = await ctx.OSS.deleteMulti(delList, {quiet: true});
    if (result.res.status !== 200) {
      throw new CustomError(0, '删除失败');
    }
    ctx.DATA.msg = '删除成功';
    ctx.body = ctx.DATA;
  } else {
    ctx.DATA.msg = '删除文件、文件夹功能未开放！';
    ctx.body = ctx.DATA;
  }
};

/**
 * 判断文件是否存在
 * @param ctx
 * @returns {Promise&lt;void&gt;}
 */
const isExistObject = async (ctx) =&gt; {
  // 用于判断受版本控制Bucket中指定versionId的Object是否存在。
  const options = {
    // 填写Object的versionId。
    versionId: ''
  };
  const name = ctx.query.name;
  try {
    const res = await ctx.OSS.head(name, options);
    ctx.DATA.data = res;
    ctx.DATA.msg = '文件存在';
    ctx.body = ctx.DATA;
  }  catch (error) {
    if (error.code === 'NoSuchKey') {
      ctx.DATA.code = 1;
      ctx.DATA.msg = '文件不存在';
      ctx.body = ctx.DATA;
    }
  }
};

module.exports = {
  upload,
  list,
  url,
  del,
  isExistObject,
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义一个WebPack的插件]]></title>
        <id>https://weidadeda.github.io/post/zi-ding-yi-yi-ge-webpack-de-cha-jian</id>
        <link href="https://weidadeda.github.io/post/zi-ding-yi-yi-ge-webpack-de-cha-jian">
        </link>
        <updated>2022-02-14T10:32:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-webpack插件的基本原理">1、webpack插件的基本原理</h3>
<p>我们知道，webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。<br>
webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好。<br>
<a href="https://www.webpackjs.com/contribute/writing-a-plugin/">官网提供的自定义插件文档</a></p>
<blockquote>
<p>tapable 是一个类似于 Node.js 中的 EventEmitter的库，但更专注于自定义事件的触发和处理。webpack 通过 tapable 将实现与流程解耦，所有具体实现通过插件的形式存在。</p>
</blockquote>
<ul>
<li>tapable作为webpack的主模块，需要单独抽一篇出来讲。需要注意的是，如果你要写sdk需要向外层吐露数据的话，建议还是用EventEmitter库，不建议用tapable，因为它销毁全部注册事件不是很容易。<br>
好了，写webpack插件必须要了解tapable，这里我们先简单介绍一下它的几个常用的钩子，其他的可以网上查，这里有篇写的还不错<a href="https://blog.csdn.net/mafan121/article/details/113120081">tapable详解</a></li>
</ul>
<pre><code>const {
  SyncHook,
  SyncBailHook,
  SyncWaterfallHook,
  SyncLoopHook,
  AsyncParallelHook,
  AsyncParallelBailHook,
  AsyncSeriesHook,
  AsyncSeriesBailHook,
  AsyncSeriesWaterfallHook
} = require('tapable');
</code></pre>
<h3 id="tapable通过tap注册一个事件通过call执行该钩子注册的所有事件-tapable的每个hooks都tap一个或多个事件-tapasynccallasync-tappromisepromise用于注册同步执行的异步事件callasync用在并行执行的异步钩子完成后再执行该函数">tapable通过tap注册一个事件，通过call执行该钩子注册的所有事件。tapable的每个hooks都tap一个或多个事件。tapAsync/callAsync、tapPromise/Promise用于注册同步执行的异步事件，callAsync用在并行执行的异步钩子完成后再执行该函数。</h3>
<p>具体使用举个例子（比如SyncHook，依次执行注册事件，无法中断）</p>
<pre><code> const hook = new SyncHook(['name', 'sex'])
  /*
  tap(options,function):
  options是事件描述，可以为一个字符串，也可以为一个对象,为对象时必须包含name属性，描述该插件名称。
  function:回调函数
  */
  // 打印我的名字
  hook.tap('printName', (name) =&gt; {
    console.log('my name is ' + name);
  })
  hook.tap('printSex', (name, sex) =&gt; {
    console.log('I’m a ' + sex);
  })
  // call(arg1,arg2,...)
  hook.call('张三', 'man');

  执行结果：

    my name is 张三

    I’m a man
</code></pre>
<p>好了，说了一堆tapable了，该说webpack插件了。</p>
<p>webpack 插件由以下组成：</p>
<ul>
<li>一个 JavaScript 命名函数。</li>
<li>在插件函数的 prototype 上定义一个 apply 方法。</li>
<li>指定一个绑定到 webpack 自身的事件钩子。</li>
<li>处理 webpack 内部实例的特定数据。</li>
<li>功能完成后调用 webpack 提供的回调。</li>
</ul>
<p>下面是官网的简单例子：</p>
<pre><code class="language-js">// 一个 JavaScript 命名函数。
function MyExampleWebpackPlugin() {

};

// 在插件函数的 prototype 上定义一个 `apply` 方法。
MyExampleWebpackPlugin.prototype.apply = function(compiler) {
  // 指定一个挂载到 webpack 自身的事件钩子。
  compiler.plugin('webpacksEventHook', function(compilation /* 处理 webpack 内部实例的特定数据。*/, callback) {
    console.log(&quot;This is an example plugin!!!&quot;);

    // 功能完成后调用 webpack 提供的回调。
    callback();
  });
};
</code></pre>
<p>在我们使用该plugin的时候，相关调用及配置代码如下：</p>
<pre><code class="language-js">const MyExampleWebpackPlugin = require('./MyExampleWebpackPlugin');
module.exports = {
  plugins: [
    new MyExampleWebpackPlugin(options)
  ]
};
</code></pre>
<p>我开始说了一大堆tapable，其实就是为了说明白webpack插件的原理</p>
<p>用代码说明吧，一个compiler.js，一个main.js<br>
compiler.js</p>
<pre><code class="language-js">// 需要做的事情如下：
// 1. 定义一个 Compiler 类，接收一个options对象参数，该参数是从main.js中的MyPlugin类的实列对象。该对象下有 apply函数。

// 2. 在该类中我们定义了run方法，我们在main.js 中执行该run函数就可以自动执行对应的插件了。

const { SyncHook, AsyncParallelHook } = require('tapable');

class Compiler {
  constructor(options) {
    this.hooks = {
      kzSyncHook: new SyncHook(['name', 'age']),
      kzAsyncHook: new AsyncParallelHook(['name', 'age'])
    };
    let plugins = options.plugins;
    if (plugins &amp;&amp; plugins.length &gt; 0) {
      plugins.forEach(plugin =&gt; plugin.apply(this));
    }
  }
  run() {
    console.log('开始执行了---------');
    this.kzSyncHook('我是小明', 81);
    this.kzAsyncHook('我是小红', 91);
  }
  kzSyncHook(name, age) {
    this.hooks.kzSyncHook.call(name, age);
  }
  kzAsyncHook(name, age) {
    this.hooks.kzAsyncHook.callAsync(name, age);
  }
}

module.exports = Compiler;
</code></pre>
<p>main.js</p>
<pre><code class="language-js">// 需要做的事情如下：
// 1. 引入 compiler.js 文件。
// 2. 定义一个自己的插件，比如叫 MyPlugin 类，该类下有 apply 函数。该函数有一个 compiler 参数，该参数就是我们的 compiler.js 中的实列对象。然后我们会使用 compiler 实列对象去调用 compiler.js 里面的函数。因此就可以自动执行了。
const Compiler = require('./compiler');

class MyPlugin {
  constructor() {
    
  }
  apply(compiler) {
    compiler.hooks.kzSyncHook.tap(&quot;eventName1&quot;, (name, age) =&gt; {
      console.log(`同步事件eventName1： ${name} this year ${age} 周岁了, 可是还是单身`);
    });
    compiler.hooks.kzAsyncHook.tapAsync('eventName2', (name, age) =&gt; {
      setTimeout(() =&gt; {
        console.log(`异步事件eventName2： ${name} this year ${age}周岁了，可是还是单身`);
      }, 1000)
    });
  }
}

const myPlugin = new MyPlugin();

const options = {
  plugins: [myPlugin]
};

const compiler = new Compiler(options);
compiler.run();
</code></pre>
<p>看到没，这种使用方式是不是和官网的使用方式很相似～这回知道原理了吧～</p>
<p>现在看官网的简单例子，webpack启动后，在读取配置的过程中会先执行 new MyExampleWebpackPlugin(options) 初始化MyExampleWebpackPlugin来获得一个实例。<br>
然后我们会把该实例当做参数传递给我们的Compiler对象，然后会实例化 Compiler类(这个逻辑可以结合看我们上面实现了一个简单的demo中 的main.js和compiler.js的代码结合起来理解)。在Compiler类中，我们会获取到options的这个参数，该参数是一个对象，该对象下有一个 plugins 这个属性。<br>
然后遍历该属性，然后依次执行 某项插件中的apply方法，即：myExampleWebpackPlugin.apply(compiler); 给插件传递compiler对象。插件实例获取该compiler对象后，就可以通过 compiler.plugin('事件名称', '回调函数'); 监听到webpack广播出来的事件.(这个地方我们可以看我们上面的main.js中的如下代码可以看到, 在我们的main.js代码中有这样代码：compiler.hooks.kzSyncHook.tap(&quot;eventName1&quot;, (name, age) =&gt; {}));</p>
<p>如上就是一个简单的Plugin的插件原理(切记：结合上面的demo中main.js和compiller.js来理解效果会更好)。</p>
<h3 id="2-compiler-和-compilation">2、Compiler 和 Compilation</h3>
<p>在开发Plugin时我们最常用的两个对象就是 Compiler 和 Compilation, 他们是Plugin和webpack之间的桥梁。</p>
<blockquote>
<p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p>
</blockquote>
<blockquote>
<p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p>
</blockquote>
<h4 id="compiler对象">Compiler对象</h4>
<p>Compiler对象包含了Webpack环境所有的配置信息，包含options，loaders, plugins这些项，这个对象在webpack启动时候被实例化，它是全局唯一的。我们可以把它理解为webpack的实例。</p>
<p>基本源码可以看如下：</p>
<pre><code>// webpack/lib/webpack.js
const Compiler = require(&quot;./Compiler&quot;)

const webpack = (options, callback) =&gt; {
  ...
  // 初始化 webpack 各配置参数
  options = new WebpackOptionsDefaulter().process(options);

  // 初始化 compiler 对象，这里 options.context 为 process.cwd()
  let compiler = new Compiler(options.context);

  compiler.options = options                               // 往 compiler 添加初始化参数

  new NodeEnvironmentPlugin().apply(compiler)              // 往 compiler 添加 Node 环境相关方法

  for (const plugin of options.plugins) {
    plugin.apply(compiler);
  }
  ...
}
</code></pre>
<blockquote>
<p><a href="https://github.com/webpack/webpack/blob/10282ea20648b465caec6448849f24fc34e1ba3e/lib/webpack.js#L30">源码可以点击这里</a></p>
</blockquote>
<p>如上我们可以看到，Compiler对象包含了所有的webpack可配置的内容。开发插件时，我们可以从 compiler 对象中拿到所有和 webpack 主环境相关的内容。</p>
<h4 id="compilation对象">compilation对象</h4>
<p>compilation 对象包含了当前的模块资源、编译生成资源、文件的变化等。当webpack在开发模式下运行时，每当检测到一个文件发生改变的时候，那么一次新的 Compilation将会被创建。从而生成一组新的编译资源。</p>
<p>Compiler对象 与 Compilation 对象 的区别是：Compiler代表了是整个webpack从启动到关闭的生命周期。Compilation 对象只代表了一次新的编译。</p>
<p>Compiler对象的事件钩子:</p>
<pre><code>钩子               作用                     参数               类型
after-plugins     设置完一组初始化插件之后    compiler          sync
after-resolvers   设置完 resolvers 之后     compiler          sync
run               在读取记录之前             compiler          async
compile           在创建新 compilation之前  compilationParams  sync
compilation       compilation 创建完成      compilation        sync
emit              在生成资源并输出到目录之前  compilation        async
after-emit        在生成资源并输出到目录之后  compilation        async
done              完成编译                  stats              sync
</code></pre>
<blockquote>
<p><a href="https://github.com/webpack/webpack/blob/eca7bad8de54c39b9cb8b138793362b8a17ac11b/lib/Compiler.js#L32">源码地址</a></p>
</blockquote>
<h4 id="理解webpack中的事件流">理解webpack中的事件流</h4>
<p>我们可以把webpack理解为一条生产线，需要经过一系列处理流程后才能将源文件转换成输出结果。<br>
这条生产线上的每个处理流程的职责都是单一的，多个流程之间会存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。</p>
<p>我们的插件就像一个插入到生产线中的一个功能，在特定的时机对生产线上的资源会做处理。webpack它是通过 Tapable来组织这条复杂的生产线的。</p>
<p>webpack在运行的过程中会广播事件，插件只需要关心监听它的事件，就能加入到这条生产线中。然后会执行相关的操作。<br>
webpack的事件流机制它能保证了插件的有序性，使整个系统的扩展性好。事件流机制使用了观察者模式来实现的。比如如下代码：</p>
<pre><code>/*
 * 广播事件
 * myPlugin-name 为事件名称
 * params 为附带的参数
*/

compiler.apply('myPlugin-name', params); // myPlugin-name随便写，就是一个名字

/*
 * 监听名称为 'myPlugin-name' 的事件，当 myPlugin-name 事件发生时，函数就会执行。
*/

compiler.hooks.myPlugin-name.tap('myPlugin-name', function(params) {
  
});
</code></pre>
<h3 id="插件中常用的api">插件中常用的API</h3>
<h4 id="compiler生命周期钩子">compiler生命周期钩子</h4>
<p><a href="https://www.webpackjs.com/api/compiler-hooks/">官方文档</a></p>
<blockquote>
<p>Compiler 支持可以监控文件系统的<a href="https://www.webpackjs.com/api/node/#watching">监听(watching)</a>机制，并且在文件修改时重新编译。当处于监听模式(watch mode)时，compiler 会触发诸如 watchRun, watchClose 和 invalid 等额外的事件。通常用于开发环境中使用，也常常会在 webpack-dev-server 这些工具的底层之下调用，由此开发人员无须每次都使用手动方式重新编译。还可以通过 CLI 进入监听模式。</p>
</blockquote>
<p>相关钩子：<br>
以下生命周期钩子函数，是由 compiler 暴露，可以通过如下方式访问：</p>
<pre><code>compiler.hooks.someHook.tap(...)
</code></pre>
<p>取决于不同的钩子类型，也可以在某些钩子上访问 tapAsync 和 tapPromise。</p>
<table>
<thead>
<tr>
<th style="text-align:center">生命周期</th>
<th style="text-align:center">对应hooks</th>
<th style="text-align:center">执行时机</th>
<th style="text-align:center">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">entryOption</td>
<td style="text-align:center">SyncBailHook</td>
<td style="text-align:center">在 entry 配置项处理过之后，执行插件。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">afterPlugins</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">设置完初始插件之后，执行插件。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">afterResolvers</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">resolver 安装完成之后，执行插件。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">environment</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">environment 准备好之后，执行插件。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">afterEnvironment</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">environment 安装完成之后，执行插件。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">beforeRun</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">compiler.run() 执行之前，添加一个钩子。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">开始读取 records 之前，钩入(hook into) compiler。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">watchRun</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">监听模式下，一个新的编译(compilation)触发之后，执行一个插件，但是是在实际编译开始之前。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">normalModuleFactory</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">NormalModuleFactory 创建之后，执行插件。</td>
<td style="text-align:center">normalModuleFactory</td>
</tr>
<tr>
<td style="text-align:center">contextModuleFactory</td>
<td style="text-align:center"></td>
<td style="text-align:center">ContextModuleFactory 创建之后，执行插件。</td>
<td style="text-align:center">contextModuleFactory</td>
</tr>
<tr>
<td style="text-align:center">beforeCompile</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">编译(compilation)参数创建之后，执行插件。</td>
<td style="text-align:center">compilationParams</td>
</tr>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">一个新的编译(compilation)创建之后，钩入(hook into) compiler。</td>
<td style="text-align:center">compilationParams</td>
</tr>
<tr>
<td style="text-align:center">thisCompilation</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">触发 compilation 事件之前执行（查看下面的 compilation）</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">compilation</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">编译(compilation)创建之后，执行插件</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">make</td>
<td style="text-align:center">AsyncParallelHook</td>
<td style="text-align:center"></td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">afterCompile</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center"></td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">shouldEmit</td>
<td style="text-align:center">SyncBailHook</td>
<td style="text-align:center">此时返回 true/false。</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">needAdditionalPass</td>
<td style="text-align:center">SyncBailHook</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">emit</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">生成资源到 output 目录之前。</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">afterEmit</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">生成资源到 output 目录之后。</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">done</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">编译(compilation)完成</td>
<td style="text-align:center">stats</td>
</tr>
<tr>
<td style="text-align:center">failed</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">编译(compilation)失败</td>
<td style="text-align:center">error</td>
</tr>
<tr>
<td style="text-align:center">invalid</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">监听模式下，编译无效时</td>
<td style="text-align:center">fileName, changeTime</td>
</tr>
<tr>
<td style="text-align:center">watchClose</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">监听模式停止</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="读取输出资源-模块及依赖">读取输出资源、模块及依赖</h4>
<p>在我们的emit钩子事件发生时，表示的含义是：源文件的转换和组装已经完成了，在这里事件钩子里面我们可以读取到最终将输出的资源、代码块、模块及对应的依赖文件。并且我们还可以输出资源文件的内容。比如插件代码如下:</p>
<pre><code class="language-js">class MyPlugin {
  apply(compiler) {
    compiler.plugin('emit', function(compilation, callback) {
      // compilation.chunks 是存放了所有的代码块，是一个数组，我们需要遍历
      compilation.chunks.forEach(function(chunk) {
        /*
         * chunk 代表一个代码块，代码块它是由多个模块组成的。
         * 我们可以通过 chunk.forEachModule 能读取组成代码块的每个模块
        */
        chunk.forEachModule(function(module) {
          // module 代表一个模块。
          // module.fileDependencies 存放当前模块的所有依赖的文件路径，它是一个数组
          module.fileDependencies.forEach(function(filepath) {
            console.log(filepath);
          });
        });
        /*
         webpack 会根据chunk去生成输出的文件资源，每个chunk都对应一个及以上的输出文件。
         比如在 Chunk中包含了css 模块并且使用了 ExtractTextPlugin 时，
         那么该Chunk 就会生成 .js 和 .css 两个文件
        */
        chunk.files.forEach(function(filename) {
          // compilation.assets 是存放当前所有即将输出的资源。
          // 调用一个输出资源的 source() 方法能获取到输出资源的内容
          const source = compilation.assets[filename].source();
        });
      });
      /*
       该事件是异步事件，因此要调用 callback 来通知本次的 webpack事件监听结束。
       如果我们没有调用callback(); 那么webpack就会一直卡在这里不会往后执行。
      */
      callback();
    })
  }
}
</code></pre>
<h4 id="监听文件变化">监听文件变化</h4>
<p>webpack读取文件的时候，它会从入口模块去读取，然后依次找出所有的依赖模块。当入口模块或依赖的模块发生改变的时候，那么就会触发一次新的 Compilation。</p>
<p>在我们开发插件的时候，我们需要知道是那个文件发生改变，导致了新的Compilation, 我们可以添加如下代码进行监听。</p>
<pre><code class="language-js">// 当依赖的文件发生改变的时候 会触发 watch-run 事件
class MyPlugin {
  apply(compiler) {
    compiler.plugin('watch-run', (watching, callback) =&gt; {
      // 获取发生变换的文件列表
      const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes;
      // changedFiles 格式为键值对的形式，当键为发生变化的文件路径
      if (changedFiles[filePath] !== undefined) {
        // 对应的文件就发生了变化了
      }
      callback();
    });

    /*
     默认情况下Webpack只会监听入口文件或其依赖的模块是否发生变化，但是在有些情况下比如html文件发生改变的时候，那么webpack
     就会去监听html文件的变化。因此就不会重新触发新的 Compilation。因此为了监听html文件的变化，我们需要把html文件加入到
     依赖列表中。因此我们需要添加如下代码：
    */
    compiler.plugin('after-compile', (compilation, callback) =&gt; {
      /*
       如下的参数filePath是html文件路径，我们把HTML文件添加到文件依赖表中，然后我们的webpack会去监听html模块文件，
       html模板文件发生改变的时候，会重新启动下重新编译一个新的 Compilation.
      */
      compilation.fileDependencies.push(filePath);
      callback();
    })
  }
}
</code></pre>
<h4 id="修改输出资源">修改输出资源</h4>
<p>我们在第一点说过：在我们的emit钩子事件发生时，表示的含义是：源文件的转换和组装已经完成了，在这里事件钩子里面我们可以读取到最终将输出的资源、代码块、模块及对应的依赖文件。因此如果我们现在要修改输出资源的内容的话，我们可以在emit事件中去做修改。那么所有输出的资源会存放在 compilation.assets中，compilation.assets是一个键值对，键为需要输出的文件名，值为文件对应的内容。如下代码：</p>
<pre><code class="language-js">class MyPlugin {
  apply(compiler) {
    compiler.plugin('emit', (compilation, callback) =&gt; {
      // 设置名称为 fileName 的输出资源
      compilation.assets[fileName] = {
        // 返回文件内容
        source: () =&gt; {
          // fileContent 即可以代表文本文件的字符串，也可以是代表二进制文件的buffer
          return fileContent;
        },
        // 返回文件大小
        size: () =&gt; {
          return Buffer.byteLength(fileContent, 'utf8');
        }
      };
      callback();
    });
    // 读取 compilation.assets 代码如下：
    compiler.plugin('emit', (compilation, callback) =&gt; {
      // 读取名称为 fileName 的输出资源
      const asset = compilation.assets[fileName];
      // 获取输出资源的内容
      asset.source();
      // 获取输出资源的文件大小
      asset.size();
      callback();
    });
  }
}
</code></pre>
<h4 id="判断webpack使用了哪些插件">判断webpack使用了哪些插件</h4>
<p>在我们开发一个插件的时候，我们需要根据当前配置是否使用了其他某个插件，我们可以通过读取webpack某个插件配置的情况，比如来判断我们当前是否使用了 HtmlWebpackPlugin 插件。代码如下：</p>
<pre><code class="language-js">/*
 判断当前配置使用了 HtmlWebpackPlugin 插件。
 compiler参数即为 webpack 在 apply(compiler) 中传入的参数
*/

function hasHtmlWebpackPlugin(compiler) {
  // 获取当前配置下所有的插件列表
  const plugins = compiler.options.plugins;
  // 去plugins中寻找有没有 HtmlWebpackPlugin 的实列
  return plugins.find(plugin =&gt; plugin.__proto__.constructor === HtmlWebpackPlugin) !== null;
}
</code></pre>
<h3 id="实战">实战</h3>
<h4 id="实现一个打印日志的logwebpackplugin插件">实现一个打印日志的LogWebpackPlugin插件</h4>
<pre><code class="language-js">// 这个文件为了观看更直观，先放到webpack.config.js中，真正使用时可以将你的自定义webpack插件封装到你们的前端组件库中。
class LogWebpackPlugin {
  constructor(doneCallback, emitCallback) {
    this.emitCallback = emitCallback
    this.doneCallback = doneCallback
  }
  apply(compiler) {
    compiler.hooks.emit.tap('LogWebpackPlugin', () =&gt; {
      // 在 emit 事件中回调 emitCallback
      this.emitCallback();
    });
    compiler.hooks.done.tap('LogWebpackPlugin', (err) =&gt; {
      // 在 done 事件中回调 doneCallback
      this.doneCallback();
    });
    compiler.hooks.compilation.tap('LogWebpackPlugin', () =&gt; {
      // compilation（'编译器'对'编译ing'这个事件的监听）
      console.log(&quot;The compiler is starting a new compilation...&quot;)
    });
    compiler.hooks.compile.tap('LogWebpackPlugin', () =&gt; {
      // compile（'编译器'对'开始编译'这个事件的监听）
      console.log(&quot;The compiler is starting to compile...&quot;)
    });
  }
}


// 使用
module.exports = {
  plugins: [
    new LogWebpackPlugin(() =&gt; {
      // Webpack 模块完成转换成功
      console.log('emit 事件发生啦，所有模块的转换和代码块对应的文件已经生成好~')
    } , () =&gt; {
      // Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作
      console.log('done 事件发生啦，成功构建完成~')
    })
  ]
}
</code></pre>
<h4 id="编写去除生成-bundlejs-中多余的注释的插件">编写去除生成 bundle.js 中多余的注释的插件</h4>
<pre><code class="language-js">class MyPlugin {
  constructor(options) {
    this.options = options;
    this.externalModules = {};
  }
  apply(compiler) {
    var reg = /(&quot;([^\\\&quot;]*(\\.)?)*&quot;)|('([^\\\']*(\\.)?)*')|(\/{2,}.*?(\r|\n))|(\/\*(\n|.)*?\*\/)|(\/\*\*\*\*\*\*\/)/g;
    compiler.hooks.emit.tap('CodeBeautify', (compilation) =&gt; {
      Object.keys(compilation.assets).forEach((data) =&gt; {
        console.log(data);
        let content = compilation.assets[data].source(); // 获取处理的文本
        content = content.replace(reg, function (word) { // 去除注释后的文本
          return /^\/{2,}/.test(word) || /^\/\*!/.test(word) || /^\/\*{3,}\//.test(word) ? &quot;&quot; : word;
        });
        compilation.assets[data] = {
          source() {
            return content;
          },
          size() {
            return content.length;
          }
        }
      });
    });
  }
}
module.exports = MyPlugin;
</code></pre>
<p>这个js代码的真正的含义才是我们今天要讲到的，这个插件最主要作用是 去除注释后的文本。</p>
<ol>
<li>
<p>第一步，我们使用 compiler.hooks.emit 钩子函数。在生成资源并输出到目录之前触发该函数，也就是说将编译好的代码发射到指定的stream中就会触发，然后我们从回调函数返回的 compilation 对象上可以拿到编译好的 stream.</p>
</li>
<li>
<p>访问compilation对象，compilation内部会返回很多内部对象，这边先不打印了，因为打印的话直接会卡死掉，要等很长时间才会打印出来，你们自己可以试试；然后我们遍历 assets.</p>
</li>
</ol>
<pre><code class="language-js">Object.keys(compilation.assets).forEach((data) =&gt; {
  console.log(compilation.assets);
  console.log(8888)
  console.log(data);
});
</code></pre>
<p>如下图所示：<br>
<img src="https://weidadeda.github.io/post-images/1644922971138.png" alt="" loading="lazy"></p>
<ul>
<li>assets 数组对象中的key是资源名。在如上代码，我们通过 Object.key()方法拿到了。如下所示：<pre><code>main.css
bundle.js
index.html
</code></pre>
</li>
<li>然后我们调用 compilation.assets[data].source(); 可以获取资源的内容。</li>
<li>使用正则，去掉注释，如下代码：<pre><code class="language-js">Object.keys(compilation.assets).forEach((data) =&gt; {
  let content = compilation.assets[data].source(); // 获取处理的文本
  content = content.replace(reg, function (word) { // 去除注释后的文本
      return /^\/{2,}/.test(word) || /^\/\*!/.test(word) || /^\/\*{3,}\//.test(word) ? &quot;&quot; : word;
  });
});
</code></pre>
</li>
<li>更新 compilation.assets[data] 对象，如下代码：<pre><code class="language-js">compilation.assets[data] = {
  source() {
      return content;
  },
  size() {
      return content.length;
  }
}
</code></pre>
</li>
<li>最后使用<pre><code class="language-js">module.exports = {
  plugins:[
      new MyPlugin(),
  ]
}
</code></pre>
</li>
</ul>
<h4 id="webpack40之后用compilerhooks注册之前用comlilerplugin注册但为了保险起见还是两种办法都写这样能应付服务器无webpack4版本详见这篇文章">webpack4.0之后用compiler.hooks注册，之前用comliler.plugin注册，但为了保险起见，还是两种办法都写，这样能应付服务器无webpack4版本，详见：<a href="https://www.cnblogs.com/dashnowords/p/9572749.html">这篇文章</a></h4>
<h3 id="最后扩展简单看了几个插件之后是不是可以考虑做些其他的事情比如删除consolelog-或者构建完成时做一些文件上传cdn的操作马上动手吧~">最后扩展：简单看了几个插件之后，是不是可以考虑做些其他的事情，比如删除console.log、或者构建完成时做一些文件上传cdn的操作，马上动手吧～</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[短信短链接唤起APP]]></title>
        <id>https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app</id>
        <link href="https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app">
        </link>
        <updated>2022-02-10T07:59:08.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644479995097.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信公众号获取openid等一系列流程]]></title>
        <id>https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng</id>
        <link href="https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng">
        </link>
        <updated>2022-02-08T12:49:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="先说下为什么要获取-openid">先说下为什么要获取 openid?</h3>
<p>因为用户管理类接口可以通过openid可以获取用户的一些信息的.</p>
<h3 id="说到-openid-必须先说微信授权登录的过程">说到 openid 必须先说微信授权登录的过程</h3>
<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644479416142.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>前端需要在进入路由的是beaforEach的时候，先去判断链接上有没有 openid</p>
</li>
<li>
<p>如果没有，就去跳转到服务端给的一个地址。如果有，就继续往下走（next())</p>
</li>
<li>
<p>这个时候服务端会往下面的链接（https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect来获取code）上跳转，去引导用户去点击授权，用户授权之后就会重定向到 redirect_uri（服务端的地址）</p>
</li>
<li>
<p>利用 code 获取 openid 之后(服务端去做)，服务端会跳转到前端页面(带上openid)</p>
</li>
</ul>
<p>下面作为了解：</p>
<p>微信授权使用的是 OAuth2.0授权方式。主要有以下简略的步骤：<br>
第一步：用户同意授权，获取 code<br>
　　第二步：通过 code获取网页授权access_token<br>
　　第三步：刷新access_token（如果需要）<br>
　　第四步：拉取用户信息(需scope为 snsapi_userinfo)</p>
<h3 id="下面来具体api表示下怎么获取的-code-和-openid-吧">下面来具体api表示下怎么获取的 code 和 openid 吧</h3>
<h3 id="一获取code">一：获取code:</h3>
<p>通过https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect来获取code<br>
参数：<br>
APPID：应用唯一标识<br>
redirect_uri：授权后重定向的回调链接地址，用户同意后，code 会自动添加到后面。（请使用urlEncode对链接进行处理 （$url = urlencode('')） ）<br>
scope：是应用授权作用域 （一般有两种：一种是静默方式（snsapi_base); 一种是非静默方式（snsapi_userinfo），需要用户去手动同意才能获取用户信息）</p>
<p>微信中尤其提醒：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问</p>
<p>** code 是微信自动生成的。并且放在redirect_uri（重定向后的回调链接地址）后面,并且带上code和state参数</p>
<p>上面提到了 code。那么 code又是什么呢？<br>
code:作为换取 access_token的票据，每次用户授权带上的 code 都不一样。5分钟未被使用自动过期（过期的这里下面有讲）</p>
<h3 id="二然后授权成功之后-得到-code-就用-code-去获取access_token">二：然后授权成功之后。得到 code。就用 code 去获取access_token</h3>
<p>https://api.weixin.qq.com/sns/oauth2/access_token?appid=wx41cb8dbd827a16e9&amp;secret=d4624c36b6795d1d99dcf0547af5443d&amp;code=00137323023ab55775be09d6d8e75ffA&amp;grant_type=authorization_code<br>
参数说明：<br>
appid：应用唯一标识<br>
code：上一步已经获取到了<br>
secret：应用密钥AppSecret，在微信开放平台提交应用审核通过后获得</p>
<p>正确的返回<br>
&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, // 接口调用凭证 &quot;expires_in&quot;:7200, // access_token接口调用凭证超时时间 &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, // 用户刷新access_token &quot;openid&quot;:&quot;OPENID&quot;, // 授权用户唯一标识 &quot;scope&quot;:&quot;SCOPE&quot;, // 作用域 等</p>
<h3 id="三通过access_token-openid获取用户信息">三：通过access_token、openid获取用户信息</h3>
<p>https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID<br>
就会得到用户的信息：<br>
得到参数：<br>
openid：用户的唯一标识<br>
nickname：用户昵称<br>
sex： 男女<br>
等。。。<br>
特别注意：<br>
1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）； 2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为； 3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。 建议将secret、用户数据（如access_token）放在App云端服务器，由云端中转接口调用请求。</p>
<h3 id="最后总结下详细的步骤">最后总结下详细的步骤：</h3>
<ul>
<li>1．用户关注微信公众账号。</li>
<li>2．微信公众账号提供用户请求授权页面URL。</li>
<li>3．用户点击授权页面URL，将向服务器发起请求</li>
<li>4．服务器询问用户是否同意授权给微信公众账号(scope为snsapi_base时无此步骤)</li>
<li>5．用户同意(scope为snsapi_base时无此步骤)</li>
<li>6．服务器将CODE通过回调传给微信公众账号</li>
<li>7．微信公众账号获得CODE</li>
<li>8．微信公众账号通过CODE向服务器请求Access Token</li>
<li>9．服务器返回Access Token和OpenID给微信公众账号</li>
<li>10．微信公众账号通过Access Token向服务器请求用户信息(scope为snsapi_base时无此步骤)</li>
<li>11．服务器将用户信息回送给微信公众账号(scope为snsapi_base时无此步骤)</li>
</ul>
<p>公众号链接(官网更权威)：<br>
https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</p>
<p>https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何比较 React Hooks 上的旧值和新值？]]></title>
        <id>https://weidadeda.github.io/post/ru-he-bi-jiao-react-hooks-shang-de-jiu-zhi-he-xin-zhi</id>
        <link href="https://weidadeda.github.io/post/ru-he-bi-jiao-react-hooks-shang-de-jiu-zhi-he-xin-zhi">
        </link>
        <updated>2022-01-27T12:24:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="自定义hooks">自定义hooks</h3>
<pre><code class="language-js">function usePrevious(value) {
  const ref = useRef();
  useEffect(() =&gt; {
    ref.current = value;
  });
  return ref.current;
}
</code></pre>
<h3 id="使用">使用</h3>
<pre><code class="language-js">const Component = (props) =&gt; {
    const {valueA, valueB} = props
    
    const prevValue = usePrevious({valueA, valueB});
    useEffect(() =&gt; {
        if(prevValue.valueA !== valueA) {
           ...
       }
        if(prevValue.valueB !== valueB) {
           ...
        }
    }, [valueA, valueB])
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[useCallback 和 useMemo 的区别]]></title>
        <id>https://weidadeda.github.io/post/usecallback-he-usememo-de-qu-bie</id>
        <link href="https://weidadeda.github.io/post/usecallback-he-usememo-de-qu-bie">
        </link>
        <updated>2022-01-11T03:32:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="区别概览">区别概览</h3>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">useCallBack</th>
<th style="text-align:center">useMemo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">返回值</td>
<td style="text-align:center">一个缓存的回调函数</td>
<td style="text-align:center">一个缓存的值</td>
</tr>
<tr>
<td style="text-align:center">参数</td>
<td style="text-align:center">需要缓存的函数，依赖项</td>
<td style="text-align:center">需要缓存的值(也可以是个计算然后再返回值的函数) ，依赖项</td>
</tr>
<tr>
<td style="text-align:center">使用场景</td>
<td style="text-align:center">父组件更新时，通过props传递给子组件的函数也会重新创建，然后这个时候使用 useCallBack 就可以缓存函数不使它重新创建</td>
<td style="text-align:center">组件更新时，一些计算量很大的值也有可能被重新计算，这个时候就可以使用 useMemo 直接使用上一次缓存的值</td>
</tr>
</tbody>
</table>
<h3 id="usecallback-具体示例">useCallBack 具体示例</h3>
<p><a href="https://codesandbox.io/s/usecallback-1w9f1?file=/src/App.jsx">codesanbox在线示例</a></p>
<pre><code class="language-js">import React, { useCallback, useEffect, useState } from &quot;react&quot;;
import &quot;./styles.css&quot;;

export default function App() {
  const [count, setCount] = useState(0);

  // 使用 useCallBack 缓存
  const handleCountAddByCallBack = useCallback(() =&gt; {
    setCount((count) =&gt; count + 1);
  }, []);

  // 不缓存，每次 count 更新时都会重新创建
  const handleCountAdd = () =&gt; {
    setCount((count) =&gt; count + 1);
  };

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;h3&gt;CountAddByChild1: {count}&lt;/h3&gt;
      &lt;Child1 addByCallBack={handleCountAddByCallBack} add={handleCountAdd} /&gt;
    &lt;/div&gt;
  );
}

const Child1 = React.memo(function (props) {
  const { add, addByCallBack } = props;
  
  // 没有缓存，由于每次都创建，memo 认为两次地址都不同，属于不同的函数，所以会触发 useEffect
  useEffect(() =&gt; {
    console.log(&quot;Child1----addFcUpdate&quot;, props);
  }, [add]);

  // 有缓存，memo 判定两次地址都相同，所以不触发 useEffect
  useEffect(() =&gt; {
    console.log(&quot;Child1----addByCallBackFcUpdate&quot;, props);
  }, [addByCallBack]);

  return (
    &lt;div&gt;
      &lt;button onClick={props.add}&gt;+1&lt;/button&gt;
      &lt;br /&gt;
      &lt;button onClick={props.addByCallBack}&gt;+1(addByCallBack)&lt;/button&gt;
    &lt;/div&gt;
  );
});
</code></pre>
<h3 id="usememo-示例">useMemo 示例</h3>
<p><a href="https://codesandbox.io/s/usememo-p9t7e?file=/src/App.jsx">codesandbox 在线示例</a></p>
<pre><code class="language-js">import { useState, useMemo } from &quot;react&quot;;
import &quot;./styles.css&quot;;

export default function App() {
  const [count, setCount] = useState(0);
  const [total, setTotal] = useState(0);

  // 没有使用 useMemo，即使是更新 total, countToString 也会重新计算
  const countToString = (() =&gt; {
    console.log(&quot;countToString 被调用&quot;);
    return count.toString();
  })();

  // 使用了 useMemo, 只有 total 改变，才会重新计算
  const totalToStringByMemo = useMemo(() =&gt; {
    console.log(&quot;totalToStringByMemo 被调用&quot;);
    return total + &quot;&quot;;
  }, [total]);

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;h3&gt;countToString: {countToString}&lt;/h3&gt;
      &lt;h3&gt;countToString: {totalToStringByMemo}&lt;/h3&gt;
      &lt;button
        onClick={() =&gt; {
          setCount((count) =&gt; count + 1);
        }}
      &gt;
        Add Count
      &lt;/button&gt;
      &lt;br /&gt;
      &lt;button
        onClick={() =&gt; {
          setTotal((total) =&gt; total + 1);
        }}
      &gt;
        Add Total
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="小结">小结</h3>
<ul>
<li>共同作用：仅仅 依赖数据 发生变化, 才会重新计算结果，也就是起到缓存的作用</li>
<li>区别
<ul>
<li>useCallBack 针对可能重新创建的函数进行优化，使得函数被缓存，React.memo 认定两次地址是相同就可以避免子组件冗余的更新。</li>
<li>useMemo 针对不必要的计算进行优化，避免了当前组件中一些的冗余计算操作。</li>
</ul>
</li>
</ul>
<p>转载自：https://www.jianshu.com/p/b8d27018ed22</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用React Hooks更新对象或数组的值]]></title>
        <id>https://weidadeda.github.io/post/shi-yong-react-hooks-geng-xin-dui-xiang-huo-shu-zu-de-zhi</id>
        <link href="https://weidadeda.github.io/post/shi-yong-react-hooks-geng-xin-dui-xiang-huo-shu-zu-de-zhi">
        </link>
        <updated>2022-01-07T13:58:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="对象类型">对象类型</h3>
<pre><code class="language-js">import React, { useState } from 'react';

const Index = ()=&gt; {
  const [obj, setObj] = useState({name:&quot;zhangsan&quot;});

  return (
    &lt;&gt;
      &lt;h2&gt;{obj.name}---{obj.age}&lt;/h2&gt;	  
      &lt;button onClick={()=&gt; (
		setObj({
		  ...obj,
		  age:18
		})
	  )}&gt;change-obj&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="数组类型">数组类型</h3>
<pre><code class="language-js">import React, { useState } from 'react';

const Index = ()=&gt; {
  const [arr, setArr] = useState([1,2,3]);

  return (
    &lt;&gt;

      &lt;h2&gt;{arr}&lt;/h2&gt;
      &lt;button onClick={()=&gt;(setArr(
		setarr(()=&gt; {
		  arr.push(4);
		  return [...arr]
		})&gt;change-arr&lt;/button&gt;

    &lt;/&gt;
  );
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Airbnb CSS / Sass 规范指南]]></title>
        <id>https://weidadeda.github.io/post/airbnb-css-sass-gui-fan-zhi-nan</id>
        <link href="https://weidadeda.github.io/post/airbnb-css-sass-gui-fan-zhi-nan">
        </link>
        <updated>2022-01-05T08:18:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><em>用更合理的方式写 CSS 和 Sass</em> 翻译自<a href="https://github.com/airbnb/css">Airbnb CSS / Sass Styleguide</a></p>
</blockquote>
<h3 id="术语">术语</h3>
<h4 id="规则声明">规则声明</h4>
<p>我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子：</p>
<pre><code class="language-css">.listing {
  font-size: 18px;
  line-height: 1.2;
}
</code></pre>
<h4 id="选择器">选择器</h4>
<p>在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子：</p>
<pre><code class="language-css">.my-element-class {
  /* ... */
}

[aria-hidden] {
  /* ... */
}
</code></pre>
<h4 id="属性">属性</h4>
<p>最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子：</p>
<pre><code class="language-css">/* some selector */ {
  background: #f1f1f1;
  color: #333;
}
</code></pre>
<h3 id="css格式">CSS格式</h3>
<ul>
<li>使用 2 个空格作为缩进。</li>
<li>类名建议使用破折号代替驼峰法。如果你使用 BEM，也可以使用下划线（参见下面的 <a href="#oocss-and-bem">OOCSS 和 BEM</a>）。</li>
<li>不要使用 ID 选择器。</li>
<li>在一个规则声明中应用了多个选择器时，每个选择器独占一行。</li>
<li>在规则声明的左大括号 { 前加上一个空格。</li>
<li>在属性的冒号 : 后面加上一个空格，前面不加空格。</li>
<li>规则声明的右大括号 } 独占一行。</li>
<li>规则声明之间用空行分隔开。</li>
</ul>
<h4 id="bad">Bad</h4>
<pre><code class="language-css">.avatar{
    border-radius:50%;
    border:2px solid white; }
.no, .nope, .not_good {
    // ...
}
#lol-no {
  // ...
}
</code></pre>
<h4 id="good">Good</h4>
<pre><code class="language-css">.avatar {
  border-radius: 50%;
  border: 2px solid white;
}

.one,
.selector,
.per-line {
  // ...
}
</code></pre>
<h3 id="注释">注释</h3>
<ul>
<li>建议使用行注释 (在 Sass 中是 //) 代替块注释。</li>
<li>建议注释独占一行。避免行末注释。</li>
<li>给没有自注释的代码写上详细说明，比如：<br>
为什么用到了 z-index<br>
兼容性处理或者针对特定浏览器的 hack</li>
</ul>
<h3 id="id-选择器">ID 选择器</h3>
<p>在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高优先级，而且 ID 选择器是不可重用的。</p>
<p>想要了解关于这个主题的更多内容，参见 <a href="https://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/">CSS Wizardry</a> 的文章，文章中有关于如何处理优先级的内容。</p>
<h3 id="javascript-钩子">JavaScript 钩子</h3>
<p>避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。</p>
<p>我们推荐在创建用于特定 JavaScript 的类名时，添加 .js- 前缀：</p>
<pre><code class="language-html">&lt;button class=&quot;btn btn-primary js-request-to-book&quot;&gt;Request to Book&lt;/button&gt;
</code></pre>
<h3 id="边框">边框</h3>
<p>在定义无边框样式时，使用 0 代替 none。</p>
<h4 id="bad-2">Bad</h4>
<pre><code class="language-css">.foo {
  border: none;
}
</code></pre>
<h4 id="good-2">Good</h4>
<pre><code class="language-css">.foo {
  border: 0;
}
</code></pre>
<h3 id="sass">Sass</h3>
<p>语法<br>
使用 .scss 的语法，不使用 .sass 原本的语法。<br>
CSS 和 @include 声明按照以下逻辑排序（参见下文）</p>
<pre><code class="language-html">&lt;a name=&quot;ordering-of-property-declarations&quot;&gt;&lt;/a&gt;
</code></pre>
<h3 id="属性声明的排序">属性声明的排序</h3>
<h4 id="属性声明">属性声明</h4>
<p>首先列出除去 @include 和嵌套选择器之外的所有属性声明。</p>
<p><code>.btn-green { background: green; font-weight: bold; // ... }</code></p>
<h4 id="include-声明">@include 声明</h4>
<p>紧随后面的是 @include，这样可以使得整个选择器的可读性更高。</p>
<p><code>.btn-green { background: green; font-weight: bold; @include transition(background 0.5s ease); // ... }</code></p>
<h4 id="嵌套选择器">嵌套选择器</h4>
<p>_如果有必要_用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。</p>
<p>` .btn { background: green; font-weight: bold; @include transition(background 0.5s ease);</p>
<p>.icon { margin-right: 10px; } } `</p>
<h3 id="变量">变量</h3>
<p>变量名应使用破折号（例如 $my-variable）代替 camelCased 和 snake_cased 风格。对于仅用在当前文件的变量，可以在变量名之前添加下划线前缀（例如 $_my-variable）。</p>
<h3 id="mixins">Mixins</h3>
<p>为了让代码遵循 DRY 原则（Don't Repeat Yourself）、增强清晰性或抽象化复杂性，应该使用 mixin，这与那些命名良好的函数的作用是异曲同工的。虽然 mixin 可以不接收参数，但要注意，假如你不压缩负载（比如通过 gzip），这样会导致最终的样式包含不必要的代码重复。</p>
<h3 id="扩展指令">扩展指令</h3>
<p>应避免使用 @extend 指令，因为它并不直观，而且具有潜在风险，特别是用在嵌套选择器的时候。即便是在顶层占位符选择器使用扩展，如果选择器的顺序最终会改变，也可能会导致问题。（比如，如果它们存在于其他文件，而加载顺序发生了变化）。其实，使用 @extend 所获得的大部分优化效果，gzip 压缩已经帮助你做到了，因此你只需要通过 mixin 让样式表更符合 DRY 原则就足够了。</p>
<h3 id="嵌套选择器-2">嵌套选择器</h3>
<p>请不要让嵌套选择器的深度超过 3 层！</p>
<pre><code class="language-sass">.page-container {
  .content {
    .profile {
      // STOP!
    }
  }
}
</code></pre>
<p>当遇到以上情况的时候，你也许是这样写 CSS 的：</p>
<ul>
<li>与 HTML 强耦合的（也是脆弱的）<em>—或者—</em></li>
<li>过于具体（强大）<em>—或者—</em></li>
<li>没有重用</li>
</ul>
<h5 id="再说一遍-永远不要嵌套-id-选择器-永远不要嵌套-id-选择器-永远不要嵌套-id-选择器">再说一遍: 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！</h5>
<p>如果你始终坚持要使用 ID 选择器（劝你三思），那也不应该嵌套它们。如果你正打算这么做，你需要先重新检查你的标签，或者指明原因。如果你想要写出风格良好的 HTML 和 CSS，你是不应该这样做的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端常用的命名规范]]></title>
        <id>https://weidadeda.github.io/post/qian-duan-chang-yong-de-ming-ming-gui-fan</id>
        <link href="https://weidadeda.github.io/post/qian-duan-chang-yong-de-ming-ming-gui-fan">
        </link>
        <updated>2021-12-20T11:20:48.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>目录 全小写中划线</li>
<li>文件 全小写中划线</li>
<li>类名 大驼峰</li>
<li>变量 小驼峰</li>
<li>常量 全大写 下划线风格</li>
<li>特殊变量</li>
<li>css类名 小写中划线</li>
<li>单词拼音不允许</li>
<li>复杂函数和公用函数必须加注释</li>
<li>函数的参数最多不能超过三个</li>
<li>url 全小写 中划线</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[瀑布流计算js源码]]></title>
        <id>https://weidadeda.github.io/post/pu-bu-liu-ji-suan-js-yuan-ma</id>
        <link href="https://weidadeda.github.io/post/pu-bu-liu-ji-suan-js-yuan-ma">
        </link>
        <updated>2021-11-24T14:38:44.000Z</updated>
        <content type="html"><![CDATA[<p>遇到问题时的解决方法及使用注意事项：</p>
<p>1、下拉刷新会导致瀑布流顺序错乱，重新new一下瀑布流即可。</p>
<p>2、图片宽高必须要让服务端返，前端去获取数据太多会导致性能非常慢。</p>
<p>3、dom加载时获取小程序的某个dom的宽度（列宽）为空，放在wx.nextTick中即可。还获取不到，就需要看自己要获取的dom是否已加载。</p>
<p>4、此代码抗揍，如果出问题先从自身找问题，再仔细阅读一遍此代码。</p>
<pre><code>class Waterfall {
  constructor(options) {
    this.initWaterfall(options);
  }
    /**
   * 初始化瀑布流
   * @param {Object} options
   * @param {Array&lt;Object&gt;} options.columns {width} - 此参数主要定义每列的宽度
   */
  initWaterfall(options) {
    this.columns = options.columns;
    this.formatedData = [];
    for (let column of options.columns) {
      this.formatedData.push({
        width: column.width,
        height: 0
      });
    }
  }
  imageUrlFeild = 'imageUrl'
 
  /**
   * 格式化从数据中获取图片url的方法
   * @param {Function | String | Number} fn - 若为函数，则需要返回瀑布流每项数据对应的图片字段
   */
 
  formatGetImageUrlMethod(fn) {
    this.imageUrlFeild = typeof fn === 'function' ? fn() : fn
  }
 
  /**
   * 向瀑布流中填充数据
   * @param {Object}  resource - 单个瀑布流项的数据源
   */
  getResourceInfo(resource) {
    const _self = this
    return new Promise(resolve =&gt; {
      if (resource[_self.imageUrlFeild]) {
        // getImageInfo方法在小程序中使用，h5中暂未测试，不过一般都是让服务端直接返回图片宽高，所以这个方法一般用不到，如果需要用到的话，必须加一层loading阻止用户操作
        wx.getImageInfo({
          src: resource[_self.imageUrlFeild],
          success(res) {
            resolve(res)
          },
          fail() {
            resolve()
          }
        })
      } else {
        resolve()
      }
    })
  }
 
  /**
   * 向瀑布流中补充数据
   * @param {Boolean} extraVal 瀑布流的卡片中图片之外的内容
   * @param {Array&lt;resource&gt;}  resources
   */
 
  async addResources(resources, extraVal) {
    // let promiseArray = []
    let newResourcesArray = Array.apply(null, Array(this.columns.length)).map(
      _ =&gt; []
    )
    for (let resource of resources) {
      // promiseArray.push(this.getResourceInfo(resource))
      // let imageInfo
      // imageInfo = await this.getResourceInfo(resource)
      const width = Number(resource.width) || 100;
      const height = Number(resource.height) || 100;
      // 获取最短列的索引
      const index = this.getShortestColumn();
      // 卡片宽度
      const imageWidth = this.formatedData[index].width;
      // 附加的卡片高度在这里是写死的，每个项目会有不同高度
      const extraHeight = extraVal ? extraVal : 0;
      // 获取卡片高度
      const cardHeight = imageWidth / (width / height) + extraHeight;
      // 当前列总高度
      this.formatedData[index].height += cardHeight;
      // 返回卡片高度
      resource.cardHeight = cardHeight;
      // 返回图片高度
      resource.computedHeight = cardHeight - extraVal;
      // 返回当前列的数组
      newResourcesArray[index].push(resource);
    }
    return newResourcesArray
  }
 
  /**
   * 最重要的地方
   * 获取当前数据中填充最短的列
   * 返回最短列的索引
   */
  getShortestColumn() {
    let minHeight = Infinity
    let minHeightColumnIndex = 0
    for (let index = this.formatedData.length - 1; index &gt; -1; index--) {
      //从后往前遍历，防止每列的高度相同的情况
      const height = this.formatedData[index].height
      if (height &lt;= minHeight) {
        minHeightColumnIndex = index
        minHeight = height
      }
    }
    return minHeightColumnIndex
  }
}
 
export default Waterfall;
 
 
// 例：双列瀑布流
let newList = new Waterfall({
      columns: [
        {
          width: 列宽
        },
        {
          width: 列宽
        }
      ]
    });
newList.addResources(lists, 卡片内除图片的额外高度).then(res =&gt; {});
</code></pre>
]]></content>
    </entry>
</feed>