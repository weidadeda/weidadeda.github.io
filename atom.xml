<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://weidadeda.github.io</id>
    <title>Gridea</title>
    <updated>2022-02-07T06:31:48.815Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://weidadeda.github.io"/>
    <link rel="self" href="https://weidadeda.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://weidadeda.github.io/images/avatar.png</logo>
    <icon>https://weidadeda.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[如何用Object.create浅拷贝一个对象]]></title>
        <id>https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang</id>
        <link href="https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang">
        </link>
        <updated>2022-01-21T02:41:42.000Z</updated>
        <content type="html"><![CDATA[<p>// 首先得介绍一下深拷贝和浅拷贝（虽然大家都知道，但毕竟写文章，还是得照顾下不知道的同学）<br>
// 其次问下大家object.assign属于浅拷贝还是深拷贝<br>
// Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型<br>
// Object.getOwnPropertyDescriptors方法配合 Object.create() 方法可以实现浅拷贝。<br>
// <code>// Object.create( // Object.getPrototypeOf(obj), // Object.getOwnPropertyDescriptors(obj) // ); //</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义一个new方法]]></title>
        <id>https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa</id>
        <link href="https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa">
        </link>
        <updated>2022-01-20T06:36:51.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">MDN new</a></p>
<h3 id="一-new的介绍">一、new的介绍</h3>
<p>new是干什么的：</p>
<blockquote>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
</blockquote>
<p>使用new可以少做四件事情：</p>
<p>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；<br>
不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；<br>
不用 return 临时对象，因为 new 会帮你做；<br>
不要给原型想名字了，因为 new 指定名字为 prototype。</p>
<p>new 关键字会进行如下的操作：</p>
<p>创建一个空的简单JavaScript对象（即{}）；<br>
为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；<br>
将步骤1新创建的对象作为this的上下文 ；<br>
如果该函数没有返回对象，则返回this。<br>
（译注：关于对象的 constructor，参见 Object.prototype.constructor）</p>
<p>创建一个用户自定义的对象需要两步：</p>
<p>通过编写函数来定义对象类型。<br>
通过 new 来创建对象实例。<br>
创建一个对象类型，需要创建一个指定其名称和属性的函数；对象的属性可以指向其他对象，看下面的例子：</p>
<p>当代码 new Foo(...) 执行时，会发生以下事情：</p>
<p>一个继承自 Foo.prototype 的新对象被创建。<br>
使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。<br>
由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）<br>
你始终可以对已定义的对象添加新的属性。例如，car1.color = &quot;black&quot; 语句给 car1 添加了一个新的属性 color，并给这个属性赋值 &quot;black&quot;。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，你必须将该属性添加到 Car 对象类型的定义中。</p>
<p>你可以使用 Function.prototype 属性将共享属性添加到以前定义的对象类型。这定义了一个由该函数创建的所有对象共享的属性，而不仅仅是对象类型的其中一个实例。下面的代码将一个值为 null 的 color 属性添加到 car 类型的所有对象，然后仅在实例对象 car1 中用字符串 &quot;black&quot; 覆盖该值</p>
<pre><code>function Car() {}
car1 = new Car();
car2 = new Car();

console.log(car1.color);    // undefined

Car.prototype.color = &quot;original color&quot;;
console.log(car1.color);    // original color

car1.color = 'black';
console.log(car1.color);   // black

console.log(car1.__proto__.color) //original color
console.log(car2.__proto__.color) //original color
console.log(car1.color)  // black
console.log(car2.color) // original color
</code></pre>
<blockquote>
<p>如果你没有使用 new 运算符， 构造函数会像其他的常规函数一样被调用， 并不会创建一个对象。在这种情况下， this 的指向也是不一样的。</p>
</blockquote>
<h3 id="二-自定义一个new">二、自定义一个new</h3>
<pre><code>  // 构造器函数
  let Parent = function (name, age) {
    this.name = name;
    this.age = age;
  };
  Parent.prototype.sayName = function () {
    console.log(this.name);
  };
  //自己定义的new方法
  let newMethod = function (Parent, ...rest) {
    // 1.以构造器的prototype属性为原型，创建新对象；
    let child = Object.create(Parent.prototype);
    // 2.将this和调用参数传给构造器执行
    Parent.apply(child, rest);
    // 3.返回第一步的对象
    return child;
  };
  //创建实例，将构造函数Parent与形参作为参数传入
  const child = newMethod(Parent, 'echo', 26);
  child.sayName() //'echo';

  //最后检验，与使用new的效果相同
  child instanceof Parent//true
  child.hasOwnProperty('name')//true
  child.hasOwnProperty('age')//true
  child.hasOwnProperty('sayName')//false
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js 常用工具 （util.inherits）]]></title>
        <id>https://weidadeda.github.io/post/nodejs-chang-yong-gong-ju-utilinherits</id>
        <link href="https://weidadeda.github.io/post/nodejs-chang-yong-gong-ju-utilinherits">
        </link>
        <updated>2022-01-19T03:27:23.000Z</updated>
        <content type="html"><![CDATA[<p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>
<p>util.inherits<br>
util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。</p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<p>在这里我们只介绍util.inherits 的用法，示例如下：</p>
<pre><code>var util = require('util'); 
function Base() { 
    this.name = 'base'; 
    this.base = 1991; 
    this.sayHello = function() { 
    console.log('Hello ' + this.name); 
    }; 
} 
Base.prototype.showName = function() { 
    console.log(this.name);
}; 
function Sub() { 
    this.name = 'sub'; 
} 
util.inherits(Sub, Base); 
var objBase = new Base(); 
objBase.showName(); 
objBase.sayHello(); 
console.log(objBase); 
var objSub = new Sub(); 
objSub.showName(); 
//objSub.sayHello(); 
console.log(objSub);
</code></pre>
<p>我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：</p>
<pre><code>base 
Hello base 
{ name: 'base', base: 1991, sayHello: [Function] } 
sub 
{ name: 'sub' }
</code></pre>
<p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。</p>
<p>同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：</p>
<pre><code>node.js:201 
throw e; // process.nextTick error, or 'error' event on first tick 
^ 
TypeError: Object #&lt;Sub&gt; has no method 'sayHello' 
at Object.&lt;anonymous&gt; (/home/byvoid/utilinherits.js:29:8) 
at Module._compile (module.js:441:26) 
at Object..js (module.js:459:10) 
at Module.load (module.js:348:31) 
at Function._load (module.js:308:12) 
at Array.0 (module.js:479:10) 
at EventEmitter._tickCallback (node.js:192:40)
</code></pre>
<p>转载自https://www.cnblogs.com/yuwenjing0727/p/8135608.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Koa接口参数校验与返回值统一处理]]></title>
        <id>https://weidadeda.github.io/post/koa-jie-kou-can-shu-xiao-yan-yu-fan-hui-zhi-tong-yi-chu-li</id>
        <link href="https://weidadeda.github.io/post/koa-jie-kou-can-shu-xiao-yan-yu-fan-hui-zhi-tong-yi-chu-li">
        </link>
        <updated>2022-01-18T11:03:04.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/node-modules/parameter">parameter地址</a><br>
// Koa接口参数校验与返回值统一处理  将参数校验变成一个路由中间件，正确的话继续执行，错误的话抛出错误异常。<br>
// 在第一个中间件中自定义返回格式这里叫ctx.DATA（ctx上自定义一个对象，对象包含code默认200,msg默认‘成功’,data默认空对象）<br>
// 这里对错误异常做了处理，抛出的是带code码以及与code码对应的msg和错误原因data的对象，此时我们将错误信息赋值给ctx.DATA.data。app中先写一个捕获错误的中间件，这样抛出的错误我们能够捕获到，然后从这里我们给body赋值，这样错误时返回的就是code码和message都有的返回值<br>
// 当成功查找到数据库中的数据时，我们只需要将数据给ctx.DATA.data，那么返回值就是code码为200，msg为成功，data为正确数据的对象了。万一出现了登陆失败，我们也可以改变ctx.DATA.message为登陆失败，改变code码等</p>
<pre><code>/**
 * 数据校验
 * wiki：https://github.com/node-modules/parameter/blob/master/example.js
 * @type {Parameter}
 */
// const { HttpError } = require('../../utils/tool/error')
const util = require('util')
// const ERROR_MSG = require('./errorMsg')
const ERROR_MSG = Object.freeze({
  // en
  // 0: 'fail',
  // 1: 'validation error',
  // 200: 'ok',
  // 400: 'invalid param',
  // 401: 'unauthorized',
  // 403: 'forbidden',
  // 404: 'not found',
  // 500: 'internal server error',
  // 503: 'service busy',

  // zh-cn
  0: '失败',
  1: '验证码错误',
  200: '成功',
  400: '请求出错',
  401: '未授权的请求',
  403: '禁止：禁止执行访问',
  404: '找不到：请检查URL以确保路径正确',
  500: '服务器的内部错误',
  503: '服务不可用'
})

function CustomError(code, msg) {
  Error.call(this, '')

  this.code = code
  this.msg = msg || ERROR_MSG[code] || 'unknown error'

  this.getCodeMsg = function() {
    return {
      code: this.code,
      msg: this.msg
    }
  }
}

util.inherits(CustomError, Error)

function HttpError(code, msg) {
  if ([0, 1, 200, 400, 401, 403, 404, 500, 503].indexOf(code) &lt; 0) {
    throw Error('not an invalid http code')
  }

  CustomError.call(this, code, msg)
}

util.inherits(HttpError, CustomError)

const Parameter = require('parameter')
const parm = new Parameter()

// 自定义校验
parm.addRule('name', function(e, v) {
  let sta = /^[a-z]$/.test(v)
  return sta || '只能输入一个字母'
})

// 路由校验列表
const ruleList = {
  // 登录
  'post/api/login': {
    mobile: { type: 'string', required: true },
    password: { type: 'string', required: true }
  },
  // 获取配置
  'get/api/setting': {
    id: { type: 'string', required: true }
  },
  // 保存配置
  'post/api/setting': {
    id: { type: 'number', required: true },
    title: { type: 'string', required: false },
    report_fix_id: { type: 'string', required: false },
    fix_url: { type: 'string', required: false },
    env: { type: 'string', required: false },
    report: { type: 'number', required: false },
    report_interval: { type: 'number', required: false }
  },
  // CICD
  'post/api/deploy': {
    name: { type: 'string', required: true },
    branch: { type: 'string', required: false },
    env: { type: 'string', required: false }
  },
  // 用户详情
  'get/api/user-details': {
    user_id: { type: 'string', required: true }
  }
}

/**
 * 校验方法
 * @param ctx
 * @param next
 * @returns {Promise&lt;void&gt;}
 */
const parameter = async (ctx, next) =&gt; {
  let errors, data
  let method = 'get'
  if (ctx.request.method === 'GET') {
    data = ctx.query
  } else {
    method = 'post'
    data = ctx.request.body
  }
  console.log(method, data)
  try {
    let name = ctx.req._parsedUrl.pathname
    errors = parm.validate(ruleList[method + name], data)
  } catch (e) {
    throw new HttpError(0, e.toString())
  }
  if (errors &amp;&amp; errors.length) {
    ctx.DATA.data = errors
    throw new HttpError(0, '数据校验未通过')
  }
  await next()
}
module.exports = parameter
</code></pre>
<p>router.js</p>
<pre><code>// 数据校验
const router = require('koa-router')()
const parameter = require('../utils/parameter')
// project
router.get('/api/user-details', parameter, userDetail)
router.get('/api/setting', parameter, getSetting)
router.post('/api/setting', parameter, setSetting)
// common
router.post('/api/login', parameter, login)
// devops
router.post('/api/deploy', parameter, checkToken, deploy)
// swagger
router.get('/api/swagger.json', async function (ctx) {
  ctx.set('Content-Type', 'application/json')
  ctx.body = openapiSpecification
})
// index
router.get('/', index)

module.exports = router
</code></pre>
<p>app.js</p>
<pre><code>const Koa = require('koa')
const app = new Koa()
const views = require('koa-views')
const json = require('koa-json')
const favicon = require('koa-favicon')
const koaBody = require('koa-body')
const logger = require('koa-logger')
const colors = require('colors')
const { resolve } = require('path')
const { koaSwagger } = require('koa2-swagger-ui')
const mysql = require('mysql2')

const conf = require('./config')
const index = require('./routes')

// 允许上传文件
app.use(
  koaBody({
    multipart: true,
    formidable: {
      maxFileSize: 1000 * 1024 * 1024 // 设置上传文件大小最大限制
    }
  })
)

// 网站图标
app.use(favicon(resolve(__dirname, './public', 'favicon.ico')))

// 返回美化json
app.use(json())

// koa-logger
app.use(logger())

// 资源文件
app.use(require('koa-static')(resolve(__dirname, './public')))

// 模板引擎
app.use(views(resolve(__dirname, './views'), { map: { html: 'nunjucks' } }))

// sql特殊字符处理
const toEscapeString = val =&gt; {
  return mysql.escape(val)
}
const toEscapeObject = dat =&gt; {
  for (let key in dat) {
    typeof dat[key] === 'string' &amp;&amp; (dat[key] = toEscapeString(dat[key]))
    typeof dat[key] === 'object' &amp;&amp; toEscapeObject(dat[key])
  }
  return dat
}

// 加入cookie.get、set及自定义返回格式
app.use(async (ctx, next) =&gt; {
  ctx.cookie = {
    set: (k, v, opt) =&gt; {
      opt = Object.assign({}, conf.cookieOptions, opt)
      return ctx.cookies.set(k, v, opt)
    },
    get: (k, opt) =&gt; {
      opt = Object.assign({}, conf.cookieOptions, opt)
      return ctx.cookies.get(k, opt)
    }
  }

  let msg = {
    0: '失败',
    1: '验证码错误',
    200: '成功',
    400: '请求出错',
    401: '未授权的请求',
    403: '禁止：禁止执行访问',
    404: '找不到：请检查URL以确保路径正确',
    500: '服务器的内部错误',
    503: '服务不可用'
  }
  ctx.json = dat =&gt; {
    !dat.message &amp;&amp; (dat.message = msg[dat.code])
    return dat
  }

  // 自定义返回格式
  ctx.DATA = {
    data: {},
    message: '',
    code: 200
  }

  // 状态统一判断
  ctx.state = res =&gt; {
    return !(res &amp;&amp; res.length ? res[0] : res)
  }
  await next()
})

// swagger
app.use(
  koaSwagger({
    routePrefix: '/swagger', // host at /swagger instead of default /docs
    swaggerOptions: {
      url: '/api/swagger.json' // example path to json 其实就是之后swagger-jsdoc生成的文档地址
    }
  })
)
// 错误捕获
app.use((ctx, next) =&gt; {
  return next().catch(err =&gt; {
    console.log(err)
    let msg = err ? err.msg || err.toString() : 'unknown error'
    let code = err ? (err.code &gt;= 0 ? err.code : 500) : 500
    ctx.DATA.code = code
    ctx.DATA.message = msg
    ctx.body = ctx.DATA
    ctx.status =
      [200, 400, 401, 403, 404, 500, 503].indexOf(code) &gt;= 0 ? code : 200
  })
})
// routes
app.use(index.routes(), index.allowedMethods())

app.proxy = true

// koa error-handling 服务端、http错误
app.on('error', (err, ctx) =&gt; {
  console.error('server error', err, ctx)
})

module.exports = app
</code></pre>
<p>controller层的接口文件</p>
<pre><code>const resData = {
    os_type_data,
    ip_data,
    browser_data,
    channel_group_data,
    client_id_group_data,
    sortArrFormat,
    userActions
  }
  // 正常返回写法，一个个的定义很麻烦
  // const successData = {
  //   code: 0,
  //   data: resData,
  //   status: '请求成功'
  // }
  // ctx.body = successData
  
  // 直接把结果赋值，code码和message不用管
  ctx.DATA.data = resData
  ctx.body = ctx.json(ctx.DATA)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KOA中间件与执行顺序]]></title>
        <id>https://weidadeda.github.io/post/koa-zhong-jian-jian-yu-zhi-xing-shun-xu</id>
        <link href="https://weidadeda.github.io/post/koa-zhong-jian-jian-yu-zhi-xing-shun-xu">
        </link>
        <updated>2022-01-18T06:59:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.itying.com/koa/article-index-id-90.html">koa2中文文档</a></p>
<h3 id="一-什么是koa的中间件">一、什么是Koa的中间件</h3>
<p>通俗的讲：中间件就是匹配路由之前或者匹配路由完成做的一系列的操作，我们就可以把它叫做中间件。</p>
<p>在express中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处理请求-响应循环流程中的中间件，一般被命名为 next 的变量。在Koa中中间件和express有点类似。</p>
<p>中间件的功能包括：</p>
<p>执行任何代码。<br>
修改请求和响应对象。<br>
终结请求-响应循环。<br>
调用堆栈中的下一个中间件。</p>
<p>如果我的get、post回调函数中，没有next参数，那么就匹配上第一个路由，就不会往下匹配了。如果想往下匹配的话，那么需要写next()</p>
<h3 id="二-koa应用可使用如下几种中间件">二、Koa应用可使用如下几种中间件：</h3>
<p>应用级中间件<br>
路由级中间件<br>
错误处理中间件<br>
第三方中间件</p>
<h3 id="三-使用">三、使用</h3>
<ul>
<li>
<ol>
<li>async和await<br>
在koa中使用关键词 async 标记的函数是异步函数，<br>
在异步函数中使用 await next(); 处理下一个异步函数。</li>
</ol>
</li>
<li>
<ol start="2">
<li>app.use(async func())<br>
koa的使用方法很简单，将一系列要处理的操作封装到一个个异步函数中，然后用Koa的实例app通过 app.use(async func()) 的形式调用</li>
</ol>
</li>
</ul>
<p>一个koa应用程序如下：</p>
<pre><code>// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:
const Koa = require('koa');
const app = new Koa(); // 创建一个Koa对象表示web app本身:

// 对于任何请求，app将调用该异步函数处理请求：
app.use(async (ctx, next) =&gt; {
    await next();
    ctx.response.type = 'text/html';
    ctx.response.body = '&lt;h1&gt;Hello, koa2!&lt;/h1&gt;';
});

// 在端口3000监听:
app.listen(3000);
console.log('app started at port 3000...');
</code></pre>
<p>可以看到 app.use() 括号里面的参数是一个函数。函数用了异步修饰符 async ，在这个函数内部，又通过关键字 await next() 调用下一个app.use的异步函数。如果这个函数是最后一个需要执行的函数，则内部不需要再写await next（）。</p>
<h3 id="四-koa中间件的执行顺序">四、koa中间件的执行顺序</h3>
<p>Express的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应。<br>
Koa是从第一个中间件开始执行,遇到 await next() 就进入下一个中间件，一直到执行到最后一个中间件。然后再逆序执行上一个中间件 await next() 后面的代码，一直到第一个中间件 await next() 后面的代码执行完毕才发出响应。</p>
<p>koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>
<p>例子：</p>
<pre><code>app.use(async (ctx, next) =&gt; {
    console.log('1'); 
    await next(); // 调用下一个middleware
    console.log('5')
});

app.use(async (ctx, next) =&gt; {
    console.log('2');
    await next(); // 调用下一个middleware
    console.log('4');
});

app.use(async (ctx, next) =&gt; {
    console.log('3');
});
</code></pre>
<p>输出结果： 12345</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[node接口生成接口文档]]></title>
        <id>https://weidadeda.github.io/post/node-jie-kou-sheng-cheng-jie-kou-wen-dang</id>
        <link href="https://weidadeda.github.io/post/node-jie-kou-sheng-cheng-jie-kou-wen-dang">
        </link>
        <updated>2022-01-17T03:21:22.000Z</updated>
        <content type="html"><![CDATA[<p>先看下效果<br>
<img src="https://weidadeda.github.io/post-images/1642391805862.png" alt="" loading="lazy"><br>
这里我用的是koa2+swagger</p>
<h3 id="安装">安装</h3>
<pre><code>// koa2-swagger-ui UI视图组件  swagger-jsdoc 识别写的 /***/ 转 json
npm install koa2-swagger-ui swagger-jsdoc --save
</code></pre>
<p><a href="https://www.npmjs.com/package/koa2-swagger-ui">koa2-swagger-ui npm地址</a> （创建接口文档）<br>
<a href="https://www.npmjs.com/package/swagger-jsdoc">swagger-jsdoc npm地址</a> （这个库读取带有jsdoc注释的源代码，并生成OpenAPI (Swagger)规范。）<br>
<a href="https://www.jianshu.com/p/5365ef83252a">OpenAPI 规范摘要</a></p>
<h3 id="配置">配置</h3>
<p>router.js</p>
<pre><code>const router = require('koa-router')() //引入路由函数
const swaggerJSDoc = require('swagger-jsdoc')
const path = require('path')
const swaggerDefinition = {
  openapi: '3.0.1',
    info: {
        title: 'blog项目访问地址',
        version: '1.0.0',
        description: 'API',
    },
    basePath: '/', // Base path (optional)
    tags: [
      {
        name: 'manage',
        description: '管理系统'
      },
      {
        name: 'client',
        description: '日志上报'
      }
    ],
    schemes: ['http', 'https'],
    securityDefinitions: {
    server_auth: {
      type: 'oauth2',
      description: '登录账号密码鉴权',
      tokenUrl: '',
      flow: 'password',
      scopes: {
        token: 'modify pets in your account'
      }
    },
    token: {
      type: 'apiKey',
      name: 'token',
      in: 'header'
    }
  }
};
const options = {
    swaggerDefinition,
    apis: [path.join(__dirname, './controllers/*.js')], // 包含上述注释的文件（）
};
const swaggerSpec = swaggerJSDoc(options)
// 通过路由获取生成的注解文件
router.get('/swagger.json', async function (ctx) {
    ctx.set('Content-Type', 'application/json');
    ctx.body = swaggerSpec;
})
module.exports = router
</code></pre>
<p>app.js 入口文件</p>
<pre><code>const swagger = require('./router')  // router中做了swagger配置
const { koaSwagger } = require('koa2-swagger-ui')

// 接口文档配置
app.use(swagger.routes(), swagger.allowedMethods())
app.use(koaSwagger({
  routePrefix: '/swagger', // 接口文档访问地址
  swaggerOptions: {
    url: '/swagger.json', // example path to json 其实就是之后swagger-jsdoc生成的文档地址
  }
}))
</code></pre>
<p>启动项目，访问项目接口地址 + swagger ，我的地址是 http://localhost:4002/swagger</p>
<h3 id="注释生成文档">注释生成文档</h3>
<p>在controller层文件每个接口上写注释，注释是以@swagger开头的，swagger-jsdoc 会识别@swagger，然后解析下面的注释，解析完给koa2-swagger-ui显示成页面，总的流程就是这样。<br>
get方式</p>
<pre><code>// 获取博客列表
/**
 * @swagger
 * /api/blog/list:
 *   get:
 *     summary: 获取博客列表
 *     description: 获取博客列表
 *     tags:
 *       - blogs
 *     parameters:
 *       - name: author
 *         in: query
 *         required: false
 *         description: 作者
 *         type: string
 *       - name: keyword
 *         in: query
 *         required: false
 *         description: 搜索关键字
 *         type: string
 *     responses:
 *       200:
 *         description: 成功获取
 */
router.get('/list', async (ctx, next) =&gt; {
  const query = ctx.query
  let author = query.author || ''
  const keyword = query.keyword || ''

  const listData = await getList(author, keyword)
  ctx.body = new SuccessModel(listData)
})
</code></pre>
<p>post方式</p>
<pre><code>/**
 * @swagger
 * definitions:
 *  loginparam:
 *    properties:
 *      username:
 *        type: &quot;string&quot;
 *        default: &quot;shangsan&quot;
 *        description: 用户名
 *      password:
 *        type: &quot;string&quot;
 *        default: &quot;123&quot;
 *        description: 密码
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     ProjectDetail:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *           format: int64
 *         petId:
 *           type: integer
 *           format: int64
 *         quantity:
 *           type: integer
 *           format: int32
 *         shipDate:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /api/user/login:
 *   post:
 *     summary: 登录
 *     description: 登录
 *     tags:
 *       - user
 *     consumes:
 *      - application/json
 *      - application/xml
 *     produces:
 *      - application/json
 *      - application/xml
 *     parameters:
 *       - name: body
 *         in: body
 *         schema:
 *          $ref: '#/definitions/loginparam' （请求参数这里单独抽出，在上面定义）
 *     responses:
 *       200:
 *         description: 发布成功
 *          content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ProjectDetail'（返回参数也是单独抽出定义，这里是随便举个例子）
 *       402:
 *          description: 信息填写不全
 *       403:
 *          description: 参数类型错误
 */

router.post('/login', async (ctx, next) =&gt; {
    // 业务逻辑
})
</code></pre>
<p>返回示例<br>
<img src="https://weidadeda.github.io/post-images/1642412213197.png" alt="" loading="lazy"><br>
基本的接口文档就生成啦，快试一下吧～</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sequelize node连接数据库的ORM]]></title>
        <id>https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm</id>
        <link href="https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm">
        </link>
        <updated>2022-01-14T07:36:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.sequelize.com.cn/">Sequelize 中文文档</a><br>
可以先看文档，文档很全，它的语句帮我们做了很多处理，而且很精简，让我们不用死记硬背sql语句，也不用去库里建表。</p>
<h3 id="连接数据库">连接数据库</h3>
<pre><code>连接到数据库
要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将连接参数分别传递到 Sequelize 构造函数或通过传递一个连接 URI 来完成：

const { Sequelize } = require('sequelize');

// 方法 1: 传递一个连接 URI
const sequelize = new Sequelize('sqlite::memory:') // Sqlite 示例
const sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname') // Postgres 示例

// 方法 2: 分别传递参数 (sqlite)
const sequelize = new Sequelize({
  dialect: 'sqlite',
  storage: 'path/to/database.sqlite'
});

// 方法 3: 分别传递参数 (其它数据库)
const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: /* 选择 'mysql' | 'mariadb' | 'postgres' | 'mssql' 其一 */
});
</code></pre>
<h3 id="定义模型-定义表结构">定义模型 （定义表结构）</h3>
<pre><code>module.exports = function(sequelize, DataTypes) {
  return sequelize.define(
    'project',
    {
      id: {
        type: DataTypes.INTEGER(11),
        allowNull: false,
        primaryKey: true,
        autoIncrement: true
      },
      name: { type: DataTypes.STRING(255), allowNull: true },
      title: { type: DataTypes.STRING(255), allowNull: true },
      report_fix_id: { type: DataTypes.STRING(1000), allowNull: true },
      fix_url: { type: DataTypes.STRING(2000), allowNull: true },
      ignore_key: {
        type: DataTypes.STRING(2000),
        allowNull: true,
        comment: '简化打印对象中比较大的对象'
      },
      env: {
        type: DataTypes.STRING(255),
        allowNull: true,
        comment: '哪些环境能上报日志'
      },
      report_interval: {
        type: DataTypes.INTEGER(11),
        allowNull: true,
        comment: '上报时间间隔'
      },
      ctime: {
        type: DataTypes.INTEGER(10),
        allowNull: true,
        get() {
          return moment
            .unix(this.getDataValue('ctime'))
            .format('YYYY/MM/DD HH:mm:ss')
        }
      },
      del: { type: DataTypes.INTEGER(1), allowNull: true, defaultValue: '0' }
    },
    {
      tableName: 'project'
    }
  )
}
</code></pre>
<h3 id="模型同步-真正从数据库创建">模型同步 （真正从数据库创建）</h3>
<p>定义模型时,你要告诉 Sequelize 有关数据库中表的一些信息. 但是,如果该表实际上不存在于数据库中怎么办？ 如果存在,但具有不同的列,较少的列或任何其他差异,该怎么办？</p>
<p>这就是模型同步的来源.可以通过调用一个异步函数(返回一个Promise)model.sync(options). 通过此调用,Sequelize 将自动对数据库执行 SQL 查询. 请注意,这仅更改数据库中的表,而不更改 JavaScript 端的模型.</p>
<p>User.sync() - 如果表不存在,则创建该表(如果已经存在,则不执行任何操作)</p>
<h4 id="usersync-force-true-将创建表如果表已经存在则将其首先删除-这个不要用也最好别试">User.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除 （这个不要用，也最好别试）</h4>
<p>User.sync({ alter: true }) - 这将检查数据库中表的当前状态(它具有哪些列,它们的数据类型等),然后在表中进行必要的更改以使其与模型匹配.</p>
<pre><code>sequelize
  .authenticate()
  .then(() =&gt; {
    console.log('数据库连接成功'.green)
    // sequelize.sync({ alter: true })
  })
  .catch(err =&gt; {
    console.log('数据库连接失败'.red)
  })
</code></pre>
<h3 id="创建实例修改内容insert">创建实例（修改内容INSERT）</h3>
<p>尽管模型是一个类,但是你不应直接使用 new 运算符来创建实例. 相反,应该使用 build 方法：</p>
<pre><code>const jane = User.build({ name: &quot;Jane&quot; });
console.log(jane instanceof User); // true
console.log(jane.name); // &quot;Jane&quot;
</code></pre>
<p>但是,以上代码根本无法与数据库通信(请注意,它甚至不是异步的)！ 这是因为 build 方法仅创建一个对象,该对象 表示 可以 映射到数据库的数据. 为了将这个实例真正保存(即持久保存)在数据库中,应使用 save 方法：</p>
<pre><code>await jane.save();
console.log('Jane 已保存到数据库!');
</code></pre>
<p>请注意,从上面代码段中的 await 用法来看,save 是一种异步方法. 实际上,几乎每个 Sequelize 方法都是异步的. build 是极少数例外之一.</p>
<p>非常有用的捷径: create 方法<br>
Sequelize提供了 create 方法,该方法将上述的 build 方法和 save 方法合并为一个方法：</p>
<pre><code>const jane = await User.create({ name: &quot;Jane&quot; });
// Jane 现在存在于数据库中！
console.log(jane instanceof User); // true
console.log(jane.name); // &quot;Jane&quot;
</code></pre>
<h3 id="简单-select-查询">简单 SELECT 查询</h3>
<p>你可以使用 findAll 方法从数据库中读取整个表：</p>
<pre><code>// 查询所有用户
const users = await User.findAll();
console.log(users.every(user =&gt; user instanceof User)); // true
console.log(&quot;All users:&quot;, JSON.stringify(users, null, 2));
</code></pre>
<p>相当于sql语句</p>
<pre><code>SELECT * FROM ...
</code></pre>
<p>嗯，写一些建表与查询的流程，照着官网抄也没什么意思。使用这个我们可以很轻松的操作数据库，使我们写node接口的时候效率翻倍～</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端使用Nacos]]></title>
        <id>https://weidadeda.github.io/post/sequelize</id>
        <link href="https://weidadeda.github.io/post/sequelize">
        </link>
        <updated>2022-01-14T07:36:06.000Z</updated>
        <content type="html"><![CDATA[<p>官网介绍：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>
<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">Nacos中文文档</a></p>
<blockquote>
<p>概览<br>
欢迎来到 Nacos 的世界！<br>
Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。<br>
Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p>
</blockquote>
<p>这个东西主要用于微服务，但我作为一个前端，只用了它的配置管理功能，虽然有点大材小用，但确实方便,而且还可以通过网页去直接查看数据结构。</p>
<p>假设前端要搞一个平台，但是并没有后端支持，那么权限管理以及一些必要的数据获取该怎么做呢，我们想到的肯定是node起服务，然后写接口，然后连接数据库。从而实现数据的增删改查。</p>
<p>但有一种更简单的方式，就是在服务器的docker中下载一个nacos,把数据放到nacos中管理，这样数据依然在我们的服务器上，并且不需要我们自己去写接口，nacos提供了openApi，我们直接调用接口就可以，是不是很方便呢。下面开始安装：</p>
<h3 id="nacos-docker-快速开始">Nacos Docker 快速开始</h3>
<p>操作步骤<br>
Clone 项目</p>
<pre><code>git clone https://github.com/nacos-group/nacos-docker.git
cd nacos-docker
</code></pre>
<p>单机模式 Derby</p>
<pre><code>docker-compose -f example/standalone-derby.yaml up
</code></pre>
<p>单机模式 MySQL</p>
<p>如果希望使用MySQL5.7</p>
<pre><code>docker-compose -f example/standalone-mysql-5.7.yaml up
</code></pre>
<p>如果希望使用MySQL8</p>
<pre><code>docker-compose -f example/standalone-mysql-8.yaml up
</code></pre>
<p>集群模式</p>
<pre><code>docker-compose -f example/cluster-hostname.yaml up 
</code></pre>
<p>服务注册</p>
<p>curl -X POST 'http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080'<br>
服务发现</p>
<p>curl -X GET 'http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName'<br>
发布配置</p>
<p>curl -X POST &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=helloWorld&quot;<br>
获取配置</p>
<p>curl -X GET &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&quot;<br>
Nacos 控制台</p>
<p>link：http://127.0.0.1:8848/nacos/（因为是在服务器上，所以可以直接使用对应的域名或者ip来访问）</p>
<h3 id="注意这里要用openapi提供的字段信息多了tenant字段-有哪里不明白的可以看下开头的官方文档哈">注意，这里要用openApi提供的字段信息，多了tenant字段。有哪里不明白的可以看下开头的官方文档哈。</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql查询语句]]></title>
        <id>https://weidadeda.github.io/post/mysql-cha-xun-yu-ju</id>
        <link href="https://weidadeda.github.io/post/mysql-cha-xun-yu-ju">
        </link>
        <updated>2022-01-14T06:46:38.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.mysqlzh.com/doc/124.html">mysql中文文档</a></p>
<h3 id="1查询记录">1.查询记录</h3>
<pre><code>select*from 表名 [where 条件];

eg:select*from students;//查询 students 表中所有记录，所有字段的值都显示出来

select field1,field2,...fieldn... from 表名 [where 条件];

eg:select id,name,age from students;//查询 students 表中所有记录, 只显示出 id，name，age三个字段的值
</code></pre>
<p>1.“*”表示将所有的字段都显示出来</p>
<p>2.用逗号分割，列出需要显示的字段</p>
<h3 id="2查询不重复的记录">2.查询不重复的记录</h3>
<pre><code>select distinct 字段 from 表名;

eg: select distinct name from students;//查询名字不相同的学生;
　　select distinct name,age from students;//查询名字和年龄同时不同的学生
　　
　　1.distinct必须放在最开头
　　2.distinct只能使用需要去重的字段进行操作。  ----也就是说我sidtinct了name,age两个字段，我后面想根据id进行排序，是不可以的，因为只能name,age两个字段进行操作.
　　3.distinct去重多个字段时，含义是：几个字段 同时重复 时才会被 过滤。
</code></pre>
<h3 id="3条件查询">3.条件查询</h3>
<pre><code>select 字段 from 表名 where 条件;

eg:select * from student where sex='男' and age&gt;20; //查询性别是男，并且年龄大于20岁的人。

where后面的条件可以用&gt;、&lt;、&gt;=、&lt;=、!=等多种比较运算符，多个条件之间可以用or、and等逻辑运算符
</code></pre>
<h3 id="4排序和限制">4.排序和限制</h3>
<pre><code>排序
select * from 表名 [where 条件] [ order by  field1 [desc/asc],field2 [desc/asc]... ];

eg:select *from student order by age desc;//查询学生表并按年龄降序排列。

1.desc 降序排列，asc 升序排列
2.order by 后面可以跟多个不同的排序字段，每个排序字段都可以有不同的排序顺序。
3.如果排序字段的值一样，则相同的字段按照第二个排序字段进行排序。
4.如果只有一个排序字段，则字段相同的记录将会无序排列。
</code></pre>
<pre><code>限制
select ... [limit 起始偏移量,行数];

eg:select * from student order by mark desc limit 5;//取出成绩前五名的学生(省略了起始偏移量，此时默认为0)

1.默认情况下，起始偏移量为0，只写记录行数就可以。
</code></pre>
<h3 id="5聚合">5.聚合</h3>
<pre><code>select 字段 fun_name from 表名 [where 条件] [group by field1,field2...] [with rollup] [having 条件];

eg:

1.fun_name 表示要做的聚合操作，也就是说聚合函数，常用的有 : sum(求和)、count(*)(记录数)、max(最大值)、min(最小值)。
2.group by关键字 表示要进行分类聚合的字段。比如要按照部门分类统计员工数量，部门就应该写在group by 后面。
3.with rollup 是可选语法，表明是否对分类聚合后的结果进行再汇总
4.having 关键字表示对分类后的结果再进行条件过滤。
</code></pre>
<p>公司员工表A如下 (编号，姓，名，薪水) ：<br>
<img src="https://weidadeda.github.io/post-images/1642143111386.png" alt="" loading="lazy"></p>
<pre><code>统计总人数
select count(1) from A;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1642143169839.png" alt="" loading="lazy"></figure>
<pre><code>统计各个姓的人数
select xing,count(1) from A group by xing;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://weidadeda.github.io/post-images/1642143194061.png" alt="" loading="lazy"></figure>
<pre><code>既要统计各个姓的人数，又统计总人数
select xing,count(1) from A group by xing with rollup;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://weidadeda.github.io/post-images/1642143250933.png" alt="" loading="lazy"></figure>
<pre><code>统计人数大4的姓
select xing,count(1) from A group by xing having count(1)&gt;4;
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://weidadeda.github.io/post-images/1642143298558.png" alt="" loading="lazy"></figure>
<pre><code>统计薪水总额，最低薪资，最高薪资
select count(1),min(salary),max(salary) from A;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://weidadeda.github.io/post-images/1642143319528.png" alt="" loading="lazy"></figure>
<h3 id="6为表和字段取别名">6.为表和字段取别名</h3>
<p>在查询数据时，可以为表和字段取别名，这个别名可以代替指定的表和字段。如果表名很长，用起来不方便，则可以用一个别名来代替，语法如下：(as关键字可省略)</p>
<pre><code>select * from 表名 [as] 别名  （为表取别名）
</code></pre>
<pre><code>SELECT 字段名 [AS] 别名[,字段名 [AS] 别名,……] FROM 表名; (为字段取别名)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker的安装与使用]]></title>
        <id>https://weidadeda.github.io/post/docker-de-an-zhuang-yu-shi-yong</id>
        <link href="https://weidadeda.github.io/post/docker-de-an-zhuang-yu-shi-yong">
        </link>
        <updated>2022-01-13T09:14:24.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://www.dockerinfo.net/document">docker中文文档</a></p>
<p>最近Docker突然火得不得了，到处都是谈论Docker的声音，相信大家和小编一样的心情，看这个东西有点高大上，但尝试去阅读Docker文章时又发现概念很模糊、不接地气、难以理解、无从下手…于是三天打鱼两天晒网，最终不了了之，反正公司也没要求用这玩意儿，不费劲了… 这不，当前几天项目要求快速上线并且部署多台服务器环境时，小编一台一台服务器的yum install、vim、restart…想屎的心都有，那时小编心里想要是有一个这么一个U盘，能把整个环境一台一台的Ctrl+V过去，那该多好啊。那时脑子一下子闪过一个念头：Docker不就是我想拥有的那个U盘吗。</p>
<p>怀着这样的一个念头，小编花了一些时间去查阅Docker相关的书籍、看视频、逛论坛，刚开始学习时非常难受，搞不懂什么是容器什么是镜像什么是鲸鱼船…而涉及到一些原理底层的知识，书籍里的那些概念比代码都能懂，小编硬啃了一段时间并且实操了几次之后，再回过头来，才豁然开朗。念及许多想要学Docker却苦于难以入门的开发者们，正在学习却很挣扎的初学者们，故而把小编这段时间的学习成果，以一个初学者的角度，遵循循序渐进的原则，编成一份通俗易懂的文章，希望能以此引导入门，早日成Docker大神。</p>
<p>文章提纲：</p>
<p>1、什么是Docker</p>
<p>2、Docker对我们有什么用处</p>
<p>3、Docker安装和使用</p>
<p>4、彩蛋</p>
<p>1、什么是Docker<br>
什么是docker？恐怕90%的人脑子一闪而过的都是那张图：一条鲸鱼背上扛着一堆箱子，图片下方是大大的“docker”。</p>
<p>docker是什么？</p>
<p>是鲸鱼？</p>
<p>还是一堆箱子？</p>
<p>或者说是载着箱子的鲸鱼？<br>
这里小编不做解释，先引用一下官方的解释：</p>
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>顾名思义，docker是一个容器引擎，容器且不说，什么是引擎？</p>
<p>我们知道：</p>
<p>汽车的引擎是发动机，有了发动起，汽车才能跑起来</p>
<p>游戏需要游戏引擎（如Unity3D..），基于引擎的开发，能让游戏动起来。</p>
<p>如官言，docker也是一种引擎，基于这个引擎，开发者能让他们开发的应用处于一个有隔离性的、可移植性的容器中，以便于发布于各种机器中而无需考虑兼容性问题。</p>
<p>因此就不难解释，为什么docker的logo是一条装着一堆箱子的鲸鱼.</p>
<p>这是因为：docker扮演的是图中鲸鱼的角色，而鲸鱼之上的集装箱就是一个个容器，容器中是我们开发的应用程序（不仅限于web应用），每个容器都有自己独立的环境（环境设置、网络、文件系统…），互不干扰。而每个箱子，又可以打包成一个新的镜像，放到其它服务器的docker环境中直接运行，不再需要重复安装程序运行环境。</p>
<p>上面的解释插入了两个生疏的概念：</p>
<p>1、镜像</p>
<p>2、容器</p>
<p>我们先讲容器</p>
<p>容器，顾名思义：就是装东西的器皿，在docker中，容器就是装载我们的应用程序的器皿，在docker的logo中，容器就是一个个箱子。我们知道，运行JavaWeb应用程序需要有Tomcat，那么我们就需要创建一个Tomcat的容器，才能把我们的程序放进去运行。</p>
<p>那么，容器哪里来的呢</p>
<p>我们知道，给电脑安装Windows系统需要有Windows镜像，因此给docker安装容器也是需要镜像的，所以，通俗一点，镜像就类似于我们日常中的安装软件，甚至说是操作系统镜像更为形象点。</p>
<p>那容器和镜像有什么关系？</p>
<p>网上说是类和对象的关系，没错，但是这样的比喻没什么实际卵用。</p>
<p>我们知道:要运行一个web程序，需要有个Tomcat环境，需要Tomcat环境，那就下载一个Tomcat解压出来，然后把web程序放入Tomcat的webapps中启动即可，</p>
<p>那么在docker中要运行一个web程序，就需要有Tomcat容器，需要Tomcat容器，就得去下载Tomcat镜像（也可以自己构建），把镜像pull下来之后，运行起来，就是一个Tomcat容器，此时把web程序至于Tomcat挂载的数据目录webapps中既可以运行。</p>
<p>所以docker中，容器和镜像的关系更像是一种动静的关系，也就是说，存于仓库中的镜像是一个死的软件，而运行起来的容器则像是一个正在运行的程序（进程）。</p>
<p>2、Docker有什么用<br>
对docker有了清晰的了解之后，我们心里可能在想： 这玩儿对我有什么用？ 我在哪里能用得上？ 怎么用才对？</p>
<p>这里引用几个案例来让大家体会体会。</p>
<p>1、案例一 前几天，公司一批服务器就要到期了，由于服务器是15年购买的，硬件的性能远比现在新出的云主机低，因此决定把所有服务器都换成新一代服务器，但是小编整准备动手迁移服务器时，内心一阵阵崩溃感涌上心头，仔细一算，每台服务器都要做同样的事情：</p>
<p>1、安装jdk、Tomcat、nginx 2、配置jdk环境变量和系统变量 3、配置Tomcat 4、配置nginx 5、安装项目所需的视频解码组件 6、导入项目所需的一些特殊字体</p>
<p>后来决定用docker部署的办法，在每台服务器都把docker安装之后，只需要在其中一台服务器中把Tomcat镜像从镜像仓库拉取下来，把这些配置都设置好，做成一个自己的镜像上传到镜像仓库中，之后在其他几台服务器都下载自己做的镜像，运行于docker中，把代码上传，就万事大吉了。</p>
<p>2、案例二</p>
<p>前不久的圣诞活动中，公司临时的活动方案在程序员的加班加点中终于上线，但是一上线之后发现推广海报中的中文名字乱码，领导问责测试人员怎么没做好测试，测试很委屈的说我已经测试无数遍并且测试报告都提交了，解决了所有问题才上线的；没办法只能让服务器同事查看正式服务器中的tomcat配置，发现原来 tomcat用了默认编码方式：iso8859-1，而测试环境中是UTF-8。针对这个问题，项目组决定把开发环境迁移到docker中，在测试环境中测试无误后，把镜像打包发布到正式环境中，解决了环境不同导致的问题。</p>
<p>3、docker的安装<br>
感知到docker对我们开发者的好处之后，相信大家也跃跃欲试了吧，下面 就Linux centOS（版本大于等于7.0）系统进行演示docker的安装步骤：</p>
<p>1、删除可能存在的旧版本</p>
<pre><code>1 sudo yum remove docker
2 docker-client
3 docker-client-latest
4 docker-common
5 docker-latest
6 docker-latest-logrotate
7 docker-logrotate
8 docker-selinux
9 docker-engine-selinux
10 docker-engine
</code></pre>
<p></p>
<p>2、安装一些必备工具：</p>
<pre><code>1 yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre>
<p>3、添加Docker源：</p>
<pre><code>1yum-config-manager
2 --add-repo
3 https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
<p>4、更新yum缓存</p>
<pre><code>1 yum makecache fast
</code></pre>
<p>5、安装</p>
<pre><code>yum install docker-ce
</code></pre>
<p>6、创建docker用户</p>
<p>温馨提示：以下操作不是必备，但是为了养成一个Linux用户的使用的良好习惯，小编不建议直接使用root操作，因此创建一个用户用来操作docker。</p>
<pre><code>useradd docker_manager
</code></pre>
<p>docker_manager是用户名，可以根据喜好起名，创建完用户之后，设置密码</p>
<pre><code>1 passwd docker_manager
2
3 docker_manager_wsdt
</code></pre>
<p>会提示输入密码和确认密码,按照提示操作即可</p>
<p>7、配置docker用户的权限</p>
<pre><code>visudo
</code></pre>
<p>visudo是配置用户权限的文件，在命令行中输入visudo回车之后，会进入文件操作，找到“# %wheel ALL=(ALL) NOPASSWD: ALL”这一行，把前面的“#”去掉，保存文件</p>
<p>8、授权</p>
<pre><code>usermod -aG wheel,docker docker_manager
</code></pre>
<p>9、启动 Docker CE</p>
<pre><code>sudo systemctl enable docker
sudo systemctl start docker
```　
此时在命令行中输入“docker info”之后，能够展示docker相关信息，就表示docker安装成功。

</code></pre>
<p>docker info</p>
<pre><code>
10、镜像加速：

编辑daemon.json文件（首次安装daemon.json是个新文件，不要惊讶）

</code></pre>
<p>vim /etc/docker/daemon.json</p>
<pre><code>加入以下内容：
</code></pre>
<p>1{<br>
2 &quot;registry-mirrors&quot;: [<br>
3 &quot;https://registry.docker-cn.com&quot;<br>
4 ]<br>
5}</p>
<pre><code>保存，sudo systemctl restart docker重启即可。

4、总结
上面针对docker使用了一种比较通俗诙谐的语言来讲述，也是为了方便读者能容易的解读和理解，理解并且成功安装docker之后，你们就会想方设法的要把自己的web项目部署到docker了，这我没说错吧，大家可以网上查找一些资料去学习这一块。
学习转载：https://www.cnblogs.com/myprogramer/p/10288634.html</code></pre>
]]></content>
    </entry>
</feed>