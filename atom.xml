<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://weidadeda.github.io</id>
    <title>Gridea</title>
    <updated>2022-02-10T08:00:03.384Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://weidadeda.github.io"/>
    <link rel="self" href="https://weidadeda.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://weidadeda.github.io/images/avatar.png</logo>
    <icon>https://weidadeda.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[短信短链接唤起APP]]></title>
        <id>https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app</id>
        <link href="https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app">
        </link>
        <updated>2022-02-10T07:59:08.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644479995097.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信公众号获取openid等一系列流程]]></title>
        <id>https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng</id>
        <link href="https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng">
        </link>
        <updated>2022-02-10T07:49:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="先说下为什么要获取-openid">先说下为什么要获取 openid?</h3>
<p>因为用户管理类接口可以通过openid可以获取用户的一些信息的.</p>
<h3 id="说到-openid-必须先说微信授权登录的过程">说到 openid 必须先说微信授权登录的过程</h3>
<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644479416142.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>前端需要在进入路由的是beaforEach的时候，先去判断链接上有没有 openid</p>
</li>
<li>
<p>如果没有，就去跳转到服务端给的一个地址。如果有，就继续往下走（next())</p>
</li>
<li>
<p>这个时候服务端会往下面的链接（https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect来获取code）上跳转，去引导用户去点击授权，用户授权之后就会重定向到 redirect_uri（服务端的地址）</p>
</li>
<li>
<p>利用 code 获取 openid 之后(服务端去做)，服务端会跳转到前端页面(带上openid)</p>
</li>
</ul>
<p>下面作为了解：</p>
<p>微信授权使用的是 OAuth2.0授权方式。主要有以下简略的步骤：<br>
第一步：用户同意授权，获取 code<br>
　　第二步：通过 code获取网页授权access_token<br>
　　第三步：刷新access_token（如果需要）<br>
　　第四步：拉取用户信息(需scope为 snsapi_userinfo)</p>
<h3 id="下面来具体api表示下怎么获取的-code-和-openid-吧">下面来具体api表示下怎么获取的 code 和 openid 吧</h3>
<h3 id="一获取code">一：获取code:</h3>
<p>通过https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect来获取code<br>
参数：<br>
APPID：应用唯一标识<br>
redirect_uri：授权后重定向的回调链接地址，用户同意后，code 会自动添加到后面。（请使用urlEncode对链接进行处理 （$url = urlencode('')） ）<br>
scope：是应用授权作用域 （一般有两种：一种是静默方式（snsapi_base); 一种是非静默方式（snsapi_userinfo），需要用户去手动同意才能获取用户信息）</p>
<p>微信中尤其提醒：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问</p>
<p>** code 是微信自动生成的。并且放在redirect_uri（重定向后的回调链接地址）后面,并且带上code和state参数</p>
<p>上面提到了 code。那么 code又是什么呢？<br>
code:作为换取 access_token的票据，每次用户授权带上的 code 都不一样。5分钟未被使用自动过期（过期的这里下面有讲）</p>
<h3 id="二然后授权成功之后-得到-code-就用-code-去获取access_token">二：然后授权成功之后。得到 code。就用 code 去获取access_token</h3>
<p>https://api.weixin.qq.com/sns/oauth2/access_token?appid=wx41cb8dbd827a16e9&amp;secret=d4624c36b6795d1d99dcf0547af5443d&amp;code=00137323023ab55775be09d6d8e75ffA&amp;grant_type=authorization_code<br>
参数说明：<br>
appid：应用唯一标识<br>
code：上一步已经获取到了<br>
secret：应用密钥AppSecret，在微信开放平台提交应用审核通过后获得</p>
<p>正确的返回<br>
&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, // 接口调用凭证 &quot;expires_in&quot;:7200, // access_token接口调用凭证超时时间 &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, // 用户刷新access_token &quot;openid&quot;:&quot;OPENID&quot;, // 授权用户唯一标识 &quot;scope&quot;:&quot;SCOPE&quot;, // 作用域 等</p>
<h3 id="三通过access_token-openid获取用户信息">三：通过access_token、openid获取用户信息</h3>
<p>https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID<br>
就会得到用户的信息：<br>
得到参数：<br>
openid：用户的唯一标识<br>
nickname：用户昵称<br>
sex： 男女<br>
等。。。<br>
特别注意：<br>
1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）； 2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为； 3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。 建议将secret、用户数据（如access_token）放在App云端服务器，由云端中转接口调用请求。</p>
<h3 id="最后总结下详细的步骤">最后总结下详细的步骤：</h3>
<ul>
<li>1．用户关注微信公众账号。</li>
<li>2．微信公众账号提供用户请求授权页面URL。</li>
<li>3．用户点击授权页面URL，将向服务器发起请求</li>
<li>4．服务器询问用户是否同意授权给微信公众账号(scope为snsapi_base时无此步骤)</li>
<li>5．用户同意(scope为snsapi_base时无此步骤)</li>
<li>6．服务器将CODE通过回调传给微信公众账号</li>
<li>7．微信公众账号获得CODE</li>
<li>8．微信公众账号通过CODE向服务器请求Access Token</li>
<li>9．服务器返回Access Token和OpenID给微信公众账号</li>
<li>10．微信公众账号通过Access Token向服务器请求用户信息(scope为snsapi_base时无此步骤)</li>
<li>11．服务器将用户信息回送给微信公众账号(scope为snsapi_base时无此步骤)</li>
</ul>
<p>公众号链接(官网更权威)：<br>
https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</p>
<p>https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Taro 小程序直播组件 LivePlayer 注意事项]]></title>
        <id>https://weidadeda.github.io/post/taro-xiao-cheng-xu-zhi-bo-zu-jian-liveplayer-zhu-yi-shi-xiang</id>
        <link href="https://weidadeda.github.io/post/taro-xiao-cheng-xu-zhi-bo-zu-jian-liveplayer-zhu-yi-shi-xiang">
        </link>
        <updated>2022-02-10T07:46:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-直播组件优先开通实时音频和视频管理后台申请对应的证书">1、直播组件优先开通实时音频和视频（管理后台），申请对应的证书</h3>
<h3 id="2-直播组件需要做系统权限验证麦克风和相机引导用户打开权限不然部分手机加载失败-insertliveplayerfailaccess-denied-因为权限有三个状态undefined-denied-authorizedauthorized代表系统权限已开">2、直播组件需要做【系统】权限验证，（麦克风和相机）,引导用户打开权限，不然部分手机加载失败（ insertLivePlayer:fail:access denied） 因为权限有三个状态(undefined、denied、authorized)，authorized代表系统权限已开</h3>
<pre><code>export const getSystemInfo = (keys: Tkey[], content = '') =&gt; {
  return new Promise((resolve) =&gt; {
    const systemInfo = wx.getAppAuthorizeSetting();
    console.log('system', systemInfo);
    if (!systemInfo) {
      return resolve({ code: -1, msg: '获取系统权限失败~' });
    }
    keys.forEach((item) =&gt; {
      if (systemInfo[item] !== 'authorized') {
        Taro.showModal({
          content,
          success: (res) =&gt; {
            if (res.confirm) {
              wx.openAppAuthorizeSetting({
                success: () =&gt; {
                  return resolve({ code: 100, msg: '打开系统授权页成功~' });
                },
                fail: () =&gt; {
                  return resolve({ code: 101, msg: '打开系统授权页失败~' });
                }
              });
            } else {
              return resolve({ code: 403, msg: '用户点击取消~' });
            }
          }
        });
        return resolve({ code: 401, msg: '权限没打开~' });
      }
    });
    return resolve({ code: 0, msg: '用户已开通对应权限~' });
  });
};
 
// 获取系统权限
      const res: any = await getSystemInfo(
        ['cameraAuthorized', 'microphoneAuthorized'],
        '检测到您没有打开麦克风和相机权限，部分功能将没法使用~'
      );
</code></pre>
<h3 id="3-直播组件同层渲染在全屏下失效需要单独处理全屏做coverviewcoverimage做原生覆盖能力处理不是全屏就同层渲染全屏处理时候顶层容器和直接子节点需要设置-visiblityvisiblepositionrelativez-index99999-必须得处理不然android-的coverview覆盖不了原生直播组件">3、直播组件同层渲染在全屏下失效，需要单独处理，全屏做CoverView\CoverImage做原生覆盖能力处理，不是全屏就同层渲染，全屏处理时候顶层容器和直接子节点需要设置 visiblity:visible;position:relative;z-index:99999; 必须得处理，不然android 的CoverView覆盖不了原生直播组件。</h3>
<pre><code>.cover-main{
    position: absolute;
    visibility: visible;
    z-index: 999999;
}
 
&lt;CoverView className={style['cover-main']}&gt;
                &lt;CoverView className={style['cover-main']}&gt;
                  &lt;CoverView className={style['live-control']} onClick={showTips}&gt;&lt;/CoverView&gt;
 
        {fullScreenFlag &amp;&amp; (
        &lt;&gt;
            {/*广告*/}
            &lt;Curtain /&gt;

            {/* 封面*/}
            {startStatus === false ? (
            &lt;CoverView className={style.cannot_see}&gt;
                &lt;CoverImage className={style.cannot_see_img} src={readyImg}&gt;&lt;/CoverImage&gt;
            &lt;/CoverView&gt;
            ) : teachStatus === false ? (
            &lt;CoverView className={style.cannot_see}&gt;
                &lt;CoverImage className={style.cannot_see_img} src={outImg}&gt;&lt;/CoverImage&gt;
            &lt;/CoverView&gt;
            ) : null}

            {/* 倒计时*/}
            {time &gt;= 1800 ? &lt;CountDown time={time} /&gt; : null}
        &lt;/&gt;
        )}

        {/*控制*/}
        &lt;CoverView
        className={`${style.control} ${tips ? style['up-ani'] : style['down-ani']}`}
        &gt;
        &lt;CoverView className={style.info}&gt;
            &lt;CoverView&gt;直播&lt;/CoverView&gt;
        &lt;/CoverView&gt;
        &lt;CoverView className={style['full-screen']} onClick={handleFullScreen}&gt;
            &lt;CoverImage
            className={style.icon}
            src={fullScreenFlag ? tuichuquanping : quanping}
            &gt;&lt;/CoverImage&gt;
            &lt;CoverView&gt;{fullScreenFlag ? '小屏播放' : '全屏播放'}&lt;/CoverView&gt;
        &lt;/CoverView&gt;
        &lt;/CoverView&gt;
    &lt;/CoverView&gt;
    &lt;/CoverView&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[瀑布流计算js源码]]></title>
        <id>https://weidadeda.github.io/post/pu-bu-liu-ji-suan-js-yuan-ma</id>
        <link href="https://weidadeda.github.io/post/pu-bu-liu-ji-suan-js-yuan-ma">
        </link>
        <updated>2022-02-10T07:35:44.000Z</updated>
        <content type="html"><![CDATA[<p>遇到问题时的解决方法及使用注意事项：</p>
<p>1、下拉刷新会导致瀑布流顺序错乱，重新new一下瀑布流即可。</p>
<p>2、图片宽高必须要让服务端返，前端去获取数据太多会导致性能非常慢。</p>
<p>3、dom加载时获取小程序的某个dom的宽度（列宽）为空，放在wx.nextTick中即可。还获取不到，就需要看自己要获取的dom是否已加载。</p>
<p>4、此代码抗揍，如果出问题先从自身找问题，再仔细阅读一遍此代码。</p>
<pre><code>class Waterfall {
  constructor(options) {
    this.initWaterfall(options);
  }
    /**
   * 初始化瀑布流
   * @param {Object} options
   * @param {Array&lt;Object&gt;} options.columns {width} - 此参数主要定义每列的宽度
   */
  initWaterfall(options) {
    this.columns = options.columns;
    this.formatedData = [];
    for (let column of options.columns) {
      this.formatedData.push({
        width: column.width,
        height: 0
      });
    }
  }
  imageUrlFeild = 'imageUrl'
 
  /**
   * 格式化从数据中获取图片url的方法
   * @param {Function | String | Number} fn - 若为函数，则需要返回瀑布流每项数据对应的图片字段
   */
 
  formatGetImageUrlMethod(fn) {
    this.imageUrlFeild = typeof fn === 'function' ? fn() : fn
  }
 
  /**
   * 向瀑布流中填充数据
   * @param {Object}  resource - 单个瀑布流项的数据源
   */
  getResourceInfo(resource) {
    const _self = this
    return new Promise(resolve =&gt; {
      if (resource[_self.imageUrlFeild]) {
        // getImageInfo方法在小程序中使用，h5中暂未测试，不过一般都是让服务端直接返回图片宽高，所以这个方法一般用不到，如果需要用到的话，必须加一层loading阻止用户操作
        wx.getImageInfo({
          src: resource[_self.imageUrlFeild],
          success(res) {
            resolve(res)
          },
          fail() {
            resolve()
          }
        })
      } else {
        resolve()
      }
    })
  }
 
  /**
   * 向瀑布流中补充数据
   * @param {Boolean} extraVal 瀑布流的卡片中图片之外的内容
   * @param {Array&lt;resource&gt;}  resources
   */
 
  async addResources(resources, extraVal) {
    // let promiseArray = []
    let newResourcesArray = Array.apply(null, Array(this.columns.length)).map(
      _ =&gt; []
    )
    for (let resource of resources) {
      // promiseArray.push(this.getResourceInfo(resource))
      // let imageInfo
      // imageInfo = await this.getResourceInfo(resource)
      const width = Number(resource.width) || 100;
      const height = Number(resource.height) || 100;
      // 获取最短列的索引
      const index = this.getShortestColumn();
      // 卡片宽度
      const imageWidth = this.formatedData[index].width;
      // 附加的卡片高度在这里是写死的，每个项目会有不同高度
      const extraHeight = extraVal ? extraVal : 0;
      // 获取卡片高度
      const cardHeight = imageWidth / (width / height) + extraHeight;
      // 当前列总高度
      this.formatedData[index].height += cardHeight;
      // 返回卡片高度
      resource.cardHeight = cardHeight;
      // 返回图片高度
      resource.computedHeight = cardHeight - extraVal;
      // 返回当前列的数组
      newResourcesArray[index].push(resource);
    }
    return newResourcesArray
  }
 
  /**
   * 最重要的地方
   * 获取当前数据中填充最短的列
   * 返回最短列的索引
   */
  getShortestColumn() {
    let minHeight = Infinity
    let minHeightColumnIndex = 0
    for (let index = this.formatedData.length - 1; index &gt; -1; index--) {
      //从后往前遍历，防止每列的高度相同的情况
      const height = this.formatedData[index].height
      if (height &lt;= minHeight) {
        minHeightColumnIndex = index
        minHeight = height
      }
    }
    return minHeightColumnIndex
  }
}
 
export default Waterfall;
 
 
// 例：双列瀑布流
let newList = new Waterfall({
      columns: [
        {
          width: 列宽
        },
        {
          width: 列宽
        }
      ]
    });
newList.addResources(lists, 卡片内除图片的额外高度).then(res =&gt; {});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C端H5或小程序常见问题总结]]></title>
        <id>https://weidadeda.github.io/post/c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie</id>
        <link href="https://weidadeda.github.io/post/c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie">
        </link>
        <updated>2022-02-09T07:59:28.000Z</updated>
        <content type="html"><![CDATA[<p>开发C端时遇到的一些问题与解决方法，都记录下来，希望对你也有帮助。</p>
<h3 id="1部分机型拍照上传图片旋转问题">1.部分机型拍照上传图片旋转问题：</h3>
<p>直接从图片后面加参数‘?x-oss-process=image/auto-orient,1/resize,m_fixed’（加上参数之后会自动旋转回来，其他参数可参考阿里OSS官方文档https://help.aliyun.com/document_detail/44691.html?spm=a2c4g.11186623.6.1390.750ac1f6HTe92Q）</p>
<h3 id="2swiper3d两边留白效果">2.swiper3D两边留白效果：</h3>
<p>（小程序h5均适用），代码如下，需要注意的是必须给swiper父级元素加overflow-x:hidden</p>
<pre><code>.swiper-container {
  height: 100%;
  width: 600px;
  perspective: 1600px;
  overflow: visible;
  img {
    width: 100%;
    height: 720px;
    border-radius: 20px;
  }
}
.swiper-slide {
  padding: 0 24px;
  box-sizing: border-box;
  text-align: center;
  transition: transform 0.5s;
  transform-origin: 50% 50%;
  transform: scale(0.9);
  &amp;.swiper-slide-active {
    transform: scale(1);
  }
}
</code></pre>
<h3 id="3小程序的跳转十层限制不要一直用navigateto这样属于一直前进如果需要跳转回首页或者其他可以使用relaunch逻辑复杂时可自己写顶部导航栏包括返回按钮">3.小程序的跳转十层限制，不要一直用navigateTo，这样属于一直前进，如果需要跳转回首页或者其他可以使用reLaunch，逻辑复杂时可自己写顶部导航栏包括返回按钮。</h3>
<h3 id="4保存海报到本地推荐一波生成小程序海报的插件非常简单方便">4.保存海报到本地：推荐一波生成小程序海报的插件，非常简单方便</h3>
<p>taro-plugin-canvas (Taro环境使用)与wxa-plugin-canvas（普通小程序使用）<br>
tip:如果遇到非常规的情况，需要手写canvas并且宽高尺寸乘2保证清晰度。</p>
<h3 id="5input光标永远停留在最后">5.input光标永远停留在最后：</h3>
<pre><code>var el = document.getElementById(&quot;IPTname&quot;);
var range = document.createRange();
range.selectNodeContents(el);
range.collapse(false);
var sel = window.getSelection();
sel.removeAllRanges();
sel.addRange(range);
</code></pre>
<h3 id="6小程序获取用户授权用户信息用户定位用户相册访问权限等时需要处理拒绝时的情况-生成海报到自己相册的时候如果用户在授权的时候点击了拒绝如果不兼容拒绝授权则直接生成失败">6.小程序获取用户授权（用户信息/用户定位/用户相册访问权限等）时需要处理拒绝时的情况。生成海报到自己相册的时候如果用户在授权的时候点击了拒绝，如果不兼容拒绝授权则直接生成失败。</h3>
<h3 id="7监听移动端键盘弹出和收起事件">7.监听移动端键盘弹出和收起事件。</h3>
<p>在ios设备上,操作表单输入时,键盘弹出时会把页面顶起来,键盘收起时并不会把页面恢复成原来的样子,造成页面样式错乱,利用focusout和focusin事件,可以间接地监听到键盘的收起和弹出事件,然后操作页面滚动到想要的位置.</p>
<p>focusout触发时机:  当元素即将失去焦点时，focusout 事件被触发。focusout 事件和 blur 事件之间的主要区别在于后者不会冒泡。</p>
<p>focusin触发时机:    当元素即将接收 focus 事件时，focusin 事件被触发。 这个事件和 focus 事件的主要区别在于后者不会冒泡。</p>
<p>监听方式:</p>
<pre><code>let scrollTop = 0
//键盘收起
document.body.addEventListener('focusout',()=&gt;{
   document.body.scrollTop=document.documentElement.scrollTop=scrollTop
})
//键盘弹出
document.body.addEventListener('focusin',()=&gt;{
   scrollTop = document.body.scrollTop || document.documentElement.scrollTop
})
</code></pre>
<h3 id="8移动端代码返回上一页windowlocationback失效">8.移动端代码返回上一页（window.location.back()失效）</h3>
<p>尼玛。。移动端返回上一页有时候用window.location.back()不好使，无解。可以使用window.location.href = document.referrer。</p>
<h3 id="9单页面应用跳转路由之后再次使用echarts时不展示">9.单页面应用跳转路由之后再次使用echarts时不展示</h3>
<p>首次使用不展示，可以延迟加载，但是当路由跳转回来之后延迟都不管用，那么需要在init Echarts之前动态设置容器宽高，并且清空父元素，因为再次回来的时候之前的echarts实例已经是存在的了，可在调试中查看详情。</p>
<h3 id="10-视频黑边问题">10. 视频黑边问题</h3>
<p>给video标签（原生video标签）加一个object-fit:fill属性即可解决。要强调的是，千万不要使用Taro的Video标签，很坑，解决了黑边，全屏时又会导致视频变形，不用object:fill的话也能解决黑边，但是全屏时视频的退出全屏样式又会被覆盖。</p>
<h3 id="11-手机锁屏时倒计时停止">11. 手机锁屏时倒计时停止</h3>
<pre><code>window.addEventListener('visibilitychange',() =&gt; {
   if (
     //hidden为锁屏时或页面不展示时，可重新获取时间开始倒计时。
      document.visibilityState =='hidden'
   ) 
})
</code></pre>
<h3 id="12移动端实现省-市-区-街道四级联动">12.移动端实现省-市-区-街道四级联动</h3>
<p>需求是要实现地区四级联动，但是vant的插件只支持三级地区联动，就很尴尬，只能自己写，但是自己写的话UI与交互体验会很差，所以就想办法去和后端对接。其实很简单，写出来只是提醒大家可以这么实现，减少思考与踩坑的时间。三级联动选择完之后会返回地区编码，eg:Array&lt;{code:'110101',name:'东城区'}&gt;,然后去请求后端的接口将地区编码传过去，就能得到其街道的相关信息，然后简单过滤一下，放在Picker选择器中就可以实现。接下来就可以写业务逻辑了。</p>
<h3 id="13ios内webview中vue项目会出现大块白色遮罩">13.ios内webview中vue项目会出现大块白色遮罩</h3>
<p>问题描述：</p>
<p>A页面——&gt;B页面——&gt;ios自带的返回——&gt;白屏出现(像个魔鬼)——&gt;点击或滑动页面——&gt;问题解决</p>
<p>原因是，经过排查，发现在ios 机器上使用webview 开发Vue项目时候，go history (-1)，无法将body 的高度拉掉，使得遮住，触发轻点击，方可消除该遮罩</p>
<p>解决的理论：用于最重要的html 容器是container，然而因为设置html、body高度是100%，从而造成了 container 撑开父级，但浏览器默认滚动的scroll 并不是 container，而是body，某些因素，造成返回history 后，无法复原（ios 的锅），为此，将 container(app.vue中包裹的div，也可以是#app) 进行了绝对定位，并让它重新成为 scroll 的对象，从而解决问题。</p>
<pre><code>html, body {

 width: 100%;

 height: 100%;
 min-height: 100vh;

 margin: 0;

 padding: 0;

 position: relative;

}

.container {

 width: 100%;

height: 100vh;
 min-height: 100vh;

 background: #fff;

 overflow: scroll;

 -webkit-overflow-scrolling: touch;

 position: absolute;

 left:0;

 top:0;

}
</code></pre>
<h3 id="14在ios上a页面分享朋友圈之后跳转到-b-页面或进行别的操作">14.在ios上A页面分享朋友圈之后，跳转到 B 页面（或进行别的操作）</h3>
<p>注：离开 app的 A 页面去微信，再次回到 app 的时候跳转到 B 页面</p>
<p>visibilitychange：当用户最小化窗口或者切换选项卡的时候，api 就会发送visibilitychange事件，让开发者知道页面状态已更改。你可以检测事件并执行某些操作或行为。</p>
<pre><code>//这个方法在分享被触发的时候执行
initVisibilityChange() {
      if (typeof document.visibilityState != &quot;undefined&quot;) {
        this.visibleChange = &quot;visibilitychange&quot;;
        this.vibibleState = &quot;visibilityState&quot;;
      } else if (
        typeof (document as any).webkitVisibilityState != &quot;undefined&quot;
      ) {
        this.visibleChange = &quot;webkitvisibilitychange&quot;;
        this.vibibleState = &quot;webkitVisibilityState&quot;;
      }
      if (this.visibleChange) {
        document.addEventListener(
          this.visibleChange,
          this.onVisibilityChanged,
          false
        );
      }
    },
      /**
     * 从微信返回app可以在这里面处理事情
     */
    onVisibilityChanged(event: any) {
      var hidden = event.target.webkitHidden;
      if ((document as any)[this.vibibleState] == &quot;visible&quot;) {
          this.goRun(); // 做自己需要的逻辑处理
          this.removeVisibilityChange();
      }
    },
     // 移除app后台监听事件
    removeVisibilityChange() {
      document.removeEventListener(
        this.visibleChange,
        this.onVisibilityChanged,
        false
      );
    },
</code></pre>
<h3 id="15-从vue页面跳转到非vue页面点击返回ios设备上页面数据不刷新">15. 从vue页面跳转到非vue页面，点击返回，ios设备上页面数据不刷新。</h3>
<p>比如A页面定义了一个变量为true，点击跳转到非vue项目页面（php），点击返回，查看这个变量，在安卓上依然为ture，但是在ios上就变成了false。</p>
<p>解决方法：</p>
<pre><code>window.onpageshow=function(e){
　　if(e.persisted) {
　　　　window.location.reload()
　　}
};
</code></pre>
<h3 id="16-app点击自带返回按钮关闭页面以及禁用返回的踩坑记录">16. app点击自带返回按钮关闭页面以及禁用返回的踩坑记录</h3>
<p>http://note.youdao.com/s/4qUINhV0 （比较多，有道云链接发出来，希望对大家有帮助）</p>
<h3 id="17-wxchooseimage方法在安卓与ios上取到的base64格式不一样安卓没有dataimagejpgbase64前缀需要单独处理">17. wx.chooseImage方法在安卓与ios上取到的base64格式不一样，安卓没有data:image/jpg;base64前缀，需要单独处理</h3>
<h3 id="18-手机内h5点击input无法唤起自带键盘可以给input添加click事件手动触发focus事件">18. 手机内h5点击input无法唤起自带键盘：可以给input添加click事件手动触发focus事件。</h3>
<h3 id="19-canvas绘制圆角矩形方法">19. canvas绘制圆角矩形方法</h3>
<pre><code>// x、y、w、h与canvas的rect方法参数相同
//r代表圆角大小，1、2、3、4分别代表上左、上右、下右、下左
function drawRoundRect(ctx, x, y, w, h, r1, r2, r3, r4) {
  ctx.beginPath()
  ctx.moveTo(x + r1, y)
  ctx.arcTo(x + w, y, x + w, y + h, r2)
  ctx.arcTo(x + w, y + h, x, y + h, r3)
  ctx.arcTo(x, y + h, x, y, r4)
  ctx.arcTo(x, y, x + w, y, r1)
  ctx.closePath()
}
</code></pre>
<h3 id="20-post导出文件处理">20. POST导出文件处理</h3>
<ul>
<li>fetch请求方法中，增加类型处理，预设请求传入字段控制，返回为：response.blob()；</li>
<li>返回值处理：</li>
</ul>
<pre><code>const blob = new Blob([data], {type: &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;})
    const a = document.createElement(&quot;a&quot;);
    const filename ={
      exportDetail: '推广人员用户明细',
      exportRecord: '推广人员跟进记录明细'
    }
    a.href = URL.createObjectURL(data)
    a.download = filename[type] // 这里填保存成的文件名
    a.click()
    URL.revokeObjectURL(a.href)
　　 a.remove();
</code></pre>
<h3 id="21-解决css瀑布流只能竖向展示问题非排名或排序时可用">21. 解决css瀑布流只能竖向展示问题(非排名或排序时可用)</h3>
<pre><code class="language-css">// 父元素
column-count: 2;
width: 100%;
// 子元素
break-inside: avoid;
</code></pre>
<pre><code class="language-js">const oldList = lists;
const newList = [].concat(
  ...Array.from(
    oldList.reduce(
      (total, cur, index) =&gt; {
        total[index % 2].push(cur);
        return total;
      },
      { 0: [], 1: [], length: 2 }
    )
  )
);
</code></pre>
<h3 id="22-mpvue的坑">22. mpvue的坑</h3>
<ul>
<li>
<p>一定要遵循mpvue官方文档建议，不要将v-for用在组件上面，或者在v-for内嵌套组件，这样成倍增加wx.setData的数据量</p>
</li>
<li>
<p>在开发上拉加载更多的需求时不要使用小程序原生的scroll-view，直接使用page的onReachBottom事件</p>
</li>
<li>
<p>使用swiper时，不要嵌套过多swiper-item，不要在swiper-item中放入太多元素，有瀑布流等无限加载列表需求时，禁止使用swiper，会导致小程序卡死闪退</p>
</li>
<li>
<p>slot只能使用匿名，具名slot及scoped slot不能使用</p>
</li>
<li>
<p>在定义组件data时，不要将与view无关的数据定义到data中，直接定义到外部，特别时监听scroll事件的时候</p>
</li>
<li>
<p>wx对象的方法全部都挂在mpvue对象下，不需要直接调用wx的方法，特别是在兼容h5的时候</p>
</li>
<li>
<p>button open-type是获取用户手机号等需要绑定事件的类型时，不要使用click.stop或catch:tap，这样会导致不会触发获取用户手机号的回调方法</p>
</li>
<li>
<p>所有组件的created生命周期只在小程序加载的时候统一执行，即使使用了v-if也不能在每次加载组件的时候触发</p>
</li>
<li>
<p>如果要自定义tabbar最好自己实现一个，不要使用原生的custom定义，原生custom限制太多且不能使用mpvue实现</p>
</li>
</ul>
<h3 id="23-taro-hooks子组件条件渲染">23. Taro hooks子组件条件渲染</h3>
<p>若是希望子组件props未被重新赋值的情况下不渲染，使用memo包裹，它实现了class中PureComponent的效果，浅比较了一次。</p>
<pre><code>// 子组件
import Taro, { memo } from &quot;@tarojs/taro&quot;;
import { View } from &quot;@tarojs/components&quot;;
 
const Index = ({ data }) =&gt; {
  return (
    &lt;View&gt;
      {console.log(&quot;Test -- rander2&quot;, data)}
      {data.map((item, index) =&gt; {
        return &lt;View key={index}&gt;{item}&lt;/View&gt;;
      })}
    &lt;/View&gt;
  );
};
 
export default memo(Index);
</code></pre>
<p>若是希望在某些特定的prop改变的时候更新子组件</p>
<pre><code>// utils
import Taro from &quot;@tarojs/taro&quot;;
 
/**
  * 子组件条件渲染
  * @param {Function} render - 要渲染的组件函数
  * @param {Array}  observe - 渲染依据，从props接收的数据key，
  */
export const compareRender = (render, observe=[]) =&gt; {
  const compare = (prevProps, nextProps) =&gt; {
    let keep = true;
    for (let i = 0; i &lt; observe.length; i++) {
      if (prevProps[observe[i]] !== nextProps[observe[i]]) {
        keep = false;
        break;
      }
    }
    return keep;
  };
  return Taro.memo(render, compare);
};
</code></pre>
<pre><code>// 子组件
import Taro from &quot;@tarojs/taro&quot;;
import { View } from &quot;@tarojs/components&quot;;
 
import { compareRender } from &quot;@utils&quot;;
 
const Index = ({ data }) =&gt; {
  return (
    &lt;View&gt;
      {console.log(&quot;Test -- rander&quot;, data)}
      {data.map((item, index) =&gt; {
        return &lt;View key={index}&gt;{item}&lt;/View&gt;;
      })}
    &lt;/View&gt;
  );
};
 
export default compareRender(Index, [&quot;data&quot;]);
</code></pre>
<h3 id="24-关于在dva副作用中多个请求同步执行的优化">24. 关于在dva副作用中多个请求同步执行的优化</h3>
<p>经测试：<br>
const res1 = yield call(req1); const res2 = yield call (req2); const res3 = yield call (req3);  三个请求同步执行，平均耗时大约为120ms，页面加载、数据等待时间较长。<br>
优化：<br>
const [ res1, res2, res3] =  yield [ call(req1), call(req2), call(req3) ],  并发请求，平均耗时大约为20ms</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js获取文件大小 window.performance]]></title>
        <id>https://weidadeda.github.io/post/js-huo-qu-wen-jian-da-xiao</id>
        <link href="https://weidadeda.github.io/post/js-huo-qu-wen-jian-da-xiao">
        </link>
        <updated>2022-02-07T09:49:49.000Z</updated>
        <content type="html"><![CDATA[<p>背景：今天 每周例行技术分享 的时候，有位同事说 js 获取不到文件大小：浏览器默认不允许js 执行IO操作。 举了个例子，比如想获取一个图片地址的文件大小，因为之前做过图片上传功能所以比较敏感，感觉应该是可以的，虽然他说网上找过很多资料但是都不行，但是这种东西 只有自己试试才安心嘛~~</p>
<h3 id="失败方案-canvastoblob">失败方案 canvas.toBlob</h3>
<pre><code>function loadImg(url){
    return new Promise((res, rej) =&gt; {
        const img = new Image()
        img.crossOrigin = ''   // 防止img 画在canvas上时报跨域错误
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej()
        }
        img.src = url
    })
}

async function getImgSize(url) {
    const urlArr = url.split('.')
    const mime = &quot;image/&quot; + urlArr[urlArr.length-1]
    const img = await loadImg(url)
    const {width,height} = img
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img,0,0,width,height)
    canvas.toBlob(
        blob =&gt; {
            console.log(url,blob,(blob.size / 1000)+'KB')
        },
        mime
    );
}

getImgSize('https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg')
</code></pre>
<p>看日志输出<br>
<img src="https://weidadeda.github.io/post-images/1644227403808.jpg" alt="" loading="lazy"><br>
看着成了，但实际.... 与 本地 和 Network 差 十万八千里<br>
<img src="https://weidadeda.github.io/post-images/1644227440435.png" alt="" loading="lazy"><br>
<img src="https://weidadeda.github.io/post-images/1644227452558.jpg" alt="" loading="lazy"><br>
我尝试了几个图片,每个图片都比之前要大，而且增大程度不一定,这块估计是canvas画了一遍的原因。。。</p>
<h3 id="失败方法-canvastodataurl-dataurltoblob">失败方法 canvas.toDataURL + dataURLtoBlob</h3>
<pre><code>function loadImg(url){
    return new Promise((res, rej) =&gt; {
        const img = new Image()
        img.crossOrigin = ''   // 防止img 画在canvas上时报跨域错误
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej()
        }
        img.src = url
    })
}

async function getImgSize(url) {
    const urlArr = url.split('.')
    const mime = &quot;image/&quot; + urlArr[urlArr.length-1]
    const img = await loadImg(url)
    const {width,height} = img
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img,0,0,width,height);
    const blob =  dataURLtoBlob(canvas.toDataURL(mime));
    console.log(url,blob,(blob.size / 1000)+'KB')
}
function dataURLtoBlob(dataurl) {
    var arr = dataurl.split(',');
    var _arr = arr[1].substring(0,arr[1].length-2);
    var mime = arr[0].match(/:(.*?);/)[1],
        bstr =atob(_arr),
        n = bstr.length,
        u8arr = new Uint8Array(n);
    while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], {
        type: mime
    });
}

getImgSize('https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg')
</code></pre>
<p>看结果⬇️<br>
<img src="https://weidadeda.github.io/post-images/1644227621781.jpg" alt="" loading="lazy"><br>
。。。看来不能走canvas这条路了</p>
<h3 id="成功方案-performance">成功方案 performance</h3>
<p><img src="https://weidadeda.github.io/post-images/1644227695711.png" alt="" loading="lazy"><br>
难道真的没有办法了嘛？我盯着 浏览器Network 陷入沉思, 突然 Network 资源加载 的size在我眼里 越来越抢眼，貌似有个api可以获取到资源加载~~~~~ 走起</p>
<pre><code>function getImgSize(url){
    return new Promise((res, rej) =&gt; {
        var performance = window.performance || 
            window.msPerformance || 
            window.webkitPerformance;
        if (performance) {
            const img = new Image()
            img.crossOrigin = ''
            img.onload = function() {
                let [imgEntries] = performance.getEntriesByName(url)
                res(imgEntries)
            }
            img.onerror = function() {
                rej('图片加载失败')
            }
            img.src = url
        }else{
            rej('浏览器不持支持performance')
        }
    })
}
let url = 'https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg'
getImgSize(url).then(v=&gt;{
    console.log(v)
    console.log(v.decodedBodySize)
    console.log((v.decodedBodySize / 1000),'KB')
    // transferSize  判断是否缓存
})
</code></pre>
<blockquote>
<p>这块使用 decodedBodySize，因为 css js等资源 decodedBodySize 与本地大小一致<br>
<img src="https://weidadeda.github.io/post-images/1644227863370.png" alt="" loading="lazy"><br>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/decodedBodySize">decodedBodySize-MDN文档</a><br>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/encodedBodySize">encodedBodySize-MDN 文档</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/getEntriesByName">performance.getEntriesByName-MDN文档</a><br>
哈哈哈哈，成了～</p>
</blockquote>
<h3 id="多组数据验证">多组数据验证</h3>
<table>
<thead>
<tr>
<th style="text-align:left">图片地址</th>
<th style="text-align:center">本地size</th>
<th style="text-align:center">canvas.toBlob</th>
<th style="text-align:center">canvas.toDataURL + dataURLtoBlob</th>
<th style="text-align:center">performance</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg</td>
<td style="text-align:center">20519</td>
<td style="text-align:center">36345</td>
<td style="text-align:center">36343</td>
<td style="text-align:center">20519</td>
</tr>
<tr>
<td style="text-align:left">https://images.daojia.com/dop/custom/dda52b42212b6bdea3e12d03ac97ffbe.png</td>
<td style="text-align:center">65511</td>
<td style="text-align:center">164303</td>
<td style="text-align:center">164302</td>
<td style="text-align:center">65511</td>
</tr>
<tr>
<td style="text-align:left">https://images.daojia.com/dop/custom/f8f0528c61e243699c309f5f25eab513.png</td>
<td style="text-align:center">14638</td>
<td style="text-align:center">36394</td>
<td style="text-align:center">36391</td>
<td style="text-align:center">14638</td>
</tr>
</tbody>
</table>
<h4 id="没有看错-performance-与本地的完全一样">没有看错 performance 与本地的完全一样</h4>
<h3 id="不限制于图片">不限制于图片</h3>
<pre><code>function loadJSFile(source) {
    return new Promise((res, rej) =&gt; {
        const node = document.createElement('script')
        node.async = false
        node.src = source

        const supportOnload = 'onload' in node
        if (supportOnload) {
            node.onload = function(){
                res(this)
            }
            node.onerror = () =&gt; {
                rej(`${source}加载失败`)
            }
        } else {
            node.onreadystatechange = function(){
                if (/loaded|complete/i.test(node.readyState)) {
                    res(this)
                }
            }
        }
        document.getElementsByTagName('head')[0].appendChild(node)
    })
}
function loadImgFile(url){
    return new Promise((res, rej) =&gt; {
        const img = new Image()
        img.crossOrigin = ''
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej('图片加载失败')
        }
        img.src = url
    })
}

function loadCSSFile(source) {
    return new Promise((res, rej) =&gt; {
        var head = document.getElementsByTagName('head')[0];
        var link = document.createElement('link');
        link.type = 'text/css';
        link.rel = 'stylesheet';
        link.href = source;
        const supportOnload = 'onload' in link
        if (supportOnload) {
            link.onload = function(){
                res(this)
            }
            link.onerror = () =&gt; {
                rej(`${source}加载失败`)
            }
        } else {
            link.onreadystatechange = function(){
                if (/loaded|complete/i.test(link.readyState)) {
                    res(this)
                }
            }
        }
        head.appendChild(link);
    })
}
function getFileSize(url){
    return new Promise((res, rej) =&gt; {
    var performance = window.performance || 
        window.msPerformance || 
        window.webkitPerformance;
    if (performance) {
        let [imgEntries] = performance.getEntriesByName(url)
        if(imgEntries){
            console.log(imgEntries)
            console.log(imgEntries.decodedBodySize)
            console.log((imgEntries.decodedBodySize / 1000),'KB')
            res(imgEntries)
        }else{
            rej('资源加载有问题')
        }
    }else{
        rej('浏览器不持支持performance')
    }
})
}
(async function (){
    const css = 'https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css';
    await loadCSSFile(css)
    await getFileSize(css)

    const js = 'https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js';
    await loadJSFile(js)
    await getFileSize(js)

    const img = 'https://images.daojia.com/dop/custom/f8f0528c61e243699c309f5f25eab513.png';
    await loadImgFile(img)
    await getFileSize(img)
})()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644228526757.png" alt="" loading="lazy"></figure>
<h3 id="兼容性">兼容性</h3>
<p>最后记得使用<a href="https://caniuse.com/?search=encodedBodySize">caniuse - performance</a>查看一下兼容性</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用yeoman开发一个自己的项目脚手架]]></title>
        <id>https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia</id>
        <link href="https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia">
        </link>
        <updated>2022-02-07T07:37:02.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://weidadeda.github.io/post-images/1644219568486.gif" alt="" loading="lazy"><br>
上面是一个使用脚手架来初始化项目的典型例子。<br>
随着前端工程化的理念不断深入，越来越多的人选择使用脚手架来从零到一搭建自己的项目。其中大家最熟悉的就是create-react-app和vue-cli，它们可以帮助我们初始化配置、生成项目结构、自动安装依赖，最后我们一行指令即可运行项目开始开发，或者进行项目构建（build）。<br>
这些脚手架提供的都是普遍意义上的最佳实践，但是我在开发中发现，随着业务的不断发展，必然会出现需要针对业务开发的实际情况来进行调整。例如：</p>
<ol>
<li>
<p>项目架构的配置<br>
a. webpack/gulp的配置<br>
ⅰ. style/less/sass的选择和处理配置。<br>
ⅱ. Typescript和JavaScript的loader和babel的配置，比如babel-loader和tsc。<br>
ⅲ. 图片的配置，比如需要file-loader或者url-loader。<br>
ⅳ. 静态资源的配置。<br>
ⅴ. 企业内部，真对于某些特定功能的webpack-loader/webpack-plugin，比如打包完图片上传。<br>
b. 是否内置一些第三方框架供上手使用，比如Element-UI，Antd等。<br>
c. 项目的路由的设计和配置。<br>
d. 项目目录结构的设计和配置。<br>
e. 项目通用功能的有关代码，比如登陆和欢迎页等。<br>
f.通过调整插件与配置实现 Webpack 打包性能优化<br>
g.针对生产环境做的单独处理</p>
</li>
<li>
<p>项目开发中的配置<br>
a. eslint。<br>
b. style-lint。<br>
c. prettier。<br>
d. 单元测试jest或者其他单元测试框架。<br>
e. 项目文档的自动生成，比如docz。<br>
f. git相关的，比如git提交的校验，生成changelog<br>
g. npm相关，除非是开发npm包，否则npm相关的不是那么重要<br>
h. 与开发有关的工具，比如打包构建结果的包分析、比如相似代码自动生成</p>
</li>
<li>
<p>项目上线脚本，这个应该是可选项？更优的方法应该是使用内部的例如发布平台之类的工具完成，或者通过jekins或者gitlab-ci进行自动化发布，回滚等操作。上线发布回滚的动作可以完全交给非开发人员完成。<br>
a. 比如由nodejs编写的上线脚本，或者是用于上线的shell脚本。<br>
b. gitlab-ci的配置文件</p>
</li>
</ol>
<p>……<br>
总而言之，随着业务发展，我们往往会沉淀出一套更“个性化”的业务方案。这时候我们最直接的做法就是开发出一个该方案的脚手架来，以便今后能复用这些最佳实践与方案。<br>
那么就需要使用一个工具来帮我们做这些处理，我们使用的就是yoman。<a href="https://yeoman.io/">官网地址</a><br>
我们可以使用yeoman和yeoman的generator来更加便捷实现我们的脚手架，可以说基本是零成本。<br>
先说说Yeoman是什么，它想做什么？<br>
Yeamon帮助你快速的开展一个项目工程，提供最佳实践和工具，来让你保持高效率编码。</p>
<p>他们自己提供了一个构建生态系统，主要通过‘yo’这个命令来构建一个完整的项目或者项目的一部分。</p>
<p>通过官方的生成器，他们建立了一个Yeoman的工作流，这个流是由一个强大的,固定的客户端组建，包含工具和框架帮助开发者快速建立牛逼的web应用。他们尽量提供了开发者所需的东西。比如先下载对应模版项目，然后下载模版项目中的package.json中的包</p>
<p>作为良好文档和深入思考构建过程的思想者，Yeoman包含了检测（静态检测）、测试以及压缩等等一系列工具，让开发者能够更加专注于思考解决方案。</p>
<h3 id="如何使用">如何使用：</h3>
<p>1、npm install -g yo //权限不够，请加上 sudo，一般来说mac都需要。<br>
安装完成之后，你就拥有了1个命令 -- yo 可以选择自定义的，也可以搜索你想要的现成的，这里我们选择自己的。 官网提供的地址：http://yeoman.io/generators/<br>
那我们开始编写一个自己的generators。<br>
2、开发自己的generator<br>
创建项目<br>
全局安装generator-generator，然后使用创建项目，根据提示输出我们的generator项目的名字，yeoman规定项目名字必须以generator开头，所以我们可以选择generator-xxx作为我们的项目名<br>
npm i -g generator-generator<br>
yo generator<br>
创建好项目之后，我们可以发现已经自动为我们配置好了eslint，jest，husky</p>
<p>我们主要需要修改的代码位于generators/app内<br>
● index.js定义了我们使用此generator时的一些操作配置项<br>
● templates内存放的是要生成的项目的项目模板，项目模板也可以放在git上，然后通过download-git-repo下载到本地<br>
验证我们创建的项目</p>
<ol>
<li>在当前项目执行npm link使其被链接到全局</li>
<li>然后找一个目录，终端执行yo，此时便可以发现我们的generator已经出现在了选择列表中。然后选择我们的generator运行即可。等待完成，会发现成功的创建了一个叫做dummyfile.txt的文件夹。<br>
generators/app/index.js<br>
初始化的文件如下。</li>
</ol>
<pre><code>&quot;use strict&quot;;
const Generator = require(&quot;yeoman-generator&quot;);
const chalk = require(&quot;chalk&quot;);
const yosay = require(&quot;yosay&quot;);

module.exports = class extends Generator {
  prompting() {
    // Have Yeoman greet the user.
    this.log(
      yosay(
        `Welcome to the fantastic ${chalk.red(&quot;generator-rc-op&quot;)} generator!`
      )
    );

    const prompts = [
      {
        type: &quot;confirm&quot;,
        name: &quot;someAnswer&quot;,
        message: &quot;Would you like to enable this option?&quot;,
        default: true
      }
    ];

    return this.prompt(prompts).then(props =&gt; {
      // To access props later use this.props.someAnswer;
      this.props = props;
    });
  }

  writing() {
    this.fs.copy(
      this.templatePath(&quot;dummyfile.txt&quot;),
      this.destinationPath(&quot;dummyfile.txt&quot;)
    );
  }

  install() {
    this.installDependencies();
  }
};
</code></pre>
<p>从文件的内容可以看出主要操作是暴露出一个继承自Generator的类，在类的内部定义了部分生命周期方法，供yoeman在适当的时候调用。我们只需要完善这些方法就可以了。</p>
<h3 id="yeoman提供的生命周期如下">yeoman提供的生命周期如下：</h3>
<ol>
<li>initializing：初始化必要的依赖，或者比如检测新版本</li>
<li>prompting：用来处理终端的交互</li>
<li>default：这里指的是自己自定义的方法，而不是名为default的方法，自己定义的方法如果不想被调用，那么需要确保方法名以_为开头。</li>
<li>writing：将经过ejs模板渲染后的内容写入文件系统。</li>
<li>conflicts：勇于解决将文件内容写入文件系统时可能造成的冲突</li>
<li>install：安装项目的依赖，比如npm install 或者 bower install</li>
<li>end：做一些收尾的工作。</li>
</ol>
<p>这些生命周期方法均支持返回Promise来进行异步操作。</p>
<h3 id="内置常用工具">内置常用工具</h3>
<p>终端交互：内置了Inquirer提供终端交互<br>
模板填充：内置了ejs模板<br>
文件操作<br>
● this.fs.copyTpl：用于拷贝并且根据数据使用ejs模板渲染文件。此函数接受三个参数，源文件路径，目标文件路径，传给ejs用于渲染目标问价的数据。<br>
● this.fs.copy：将文件丛源路径复制到目标路径。<br>
● this.destinationPath() ：此函数返回最终生成项目的路径<br>
其他<br>
● this.npmInstall：实现npm isntall</p>
<pre><code>// 部分代码，完整代码见最下方链接
writing() {
    const done = this.async();
    this.log(&quot;⚙  Finish basic configuration.&quot;, chalk.green(&quot;✔&quot;));
    this.log(&quot;📂 Generate the project template and configuration...&quot;);
    let spinner = ora({
      text: `Download the template from ${GIT_BASE}${TPL_REPOSITORY}...`,
      spinner: ORA_SPINNER
    }).start();
    this._downloadTemplate(TPL_REPOSITORY)
      .then(() =&gt; {
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish downloading the template from ${GIT_BASE}${TPL_REPOSITORY}`
        });
        spinner = ora({
          text: `Copy files into the project folder...`,
          spinner: ORA_SPINNER
        }).start();
        const templateRoot = this.destinationPath(this.dirName, &quot;.tmp&quot;);
        this.log(`\n${templateRoot}`, &quot;templateRoot&quot;);
        const resoPath = path.resolve(templateRoot, &quot;../&quot;);
        this.log(resoPath, &quot;resoPath&quot;);
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish copying files into the project folder`
        });
        execSync(`cp -R ${resoPath}/.tmp/* ${resoPath}`, { stdio: &quot;inherit&quot; });
        spinner = ora({
          text: `Clean tmp files and folders...`,
          spinner: ORA_SPINNER
        }).start();
        fs.removeSync(templateRoot);
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish cleaning tmp files and folders`
        });
        // ExecSync(`rm -R ${resoPath}/.tmp`, { stdio: &quot;inherit&quot; });
        // 将新生成的项目的title换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/public/index.html`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/public/index.html`, str);
          }
        );
        // 将新生成的项目的package.json的name换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/package.json`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/package.json`, str);
          }
        );
        done();
      })
      .catch(err =&gt; this.env.error(err));
  }
</code></pre>
<h3 id="其他可能用到的工具">其他可能用到的工具</h3>
<p>● ora：用于创建Spinner，即比如下载模板文件时需要展示的laoding效果。<br>
● chalk：用于打印彩色的信息<br>
● update-notifier<br>
● beeper<br>
● boxen<br>
调试<br>
由于yeoman是通过npm包的形式进行使用的，所以我们可以在我们开发的generator项目的跟目录下，执行npm link 将我们开发的generator链接到全局，这样我们直接使用yo命令查看可以使用的generator，就可以看到我们所开发的generator了，并且是实时生效的</p>
<h3 id="我的代码是在本地的用的npm-link没有上传到github或npm此处贴出其他大佬的项目代码-快动手试一下吧~">我的代码是在本地的，用的npm link，没有上传到github或npm，此处贴出其他大佬的项目代码。快动手试一下吧～</h3>
<p><a href="https://github.com/alienzhou/webpack-kickoff-template">模版完整代码</a>   注意要给ejs写入的空位<br>
<a href="https://github.com/alienzhou/generator-webpack-kickoff">脚手架完整代码</a></p>
<h3 id="参考文章">参考文章：</h3>
<p><a href="https://www.yuque.com/kongdepeng/rgpm60/qrluup">前端自动化工具 - yeoman</a><br>
<a href="https://zhuanlan.zhihu.com/p/66190308">如何快速开发一个自己的项目脚手架？</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用Object.create浅拷贝一个对象]]></title>
        <id>https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang</id>
        <link href="https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang">
        </link>
        <updated>2022-01-21T02:41:42.000Z</updated>
        <content type="html"><![CDATA[<p>// 首先得介绍一下深拷贝和浅拷贝（虽然大家都知道，但毕竟写文章，还是得照顾下不知道的同学）<br>
// 其次问下大家object.assign属于浅拷贝还是深拷贝<br>
// Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型<br>
// Object.getOwnPropertyDescriptors方法配合 Object.create() 方法可以实现浅拷贝。<br>
// <code>// Object.create( // Object.getPrototypeOf(obj), // Object.getOwnPropertyDescriptors(obj) // ); //</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义一个new方法]]></title>
        <id>https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa</id>
        <link href="https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa">
        </link>
        <updated>2022-01-20T06:36:51.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">MDN new</a></p>
<h3 id="一-new的介绍">一、new的介绍</h3>
<p>new是干什么的：</p>
<blockquote>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
</blockquote>
<p>使用new可以少做四件事情：</p>
<p>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；<br>
不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；<br>
不用 return 临时对象，因为 new 会帮你做；<br>
不要给原型想名字了，因为 new 指定名字为 prototype。</p>
<p>new 关键字会进行如下的操作：</p>
<p>创建一个空的简单JavaScript对象（即{}）；<br>
为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；<br>
将步骤1新创建的对象作为this的上下文 ；<br>
如果该函数没有返回对象，则返回this。<br>
（译注：关于对象的 constructor，参见 Object.prototype.constructor）</p>
<p>创建一个用户自定义的对象需要两步：</p>
<p>通过编写函数来定义对象类型。<br>
通过 new 来创建对象实例。<br>
创建一个对象类型，需要创建一个指定其名称和属性的函数；对象的属性可以指向其他对象，看下面的例子：</p>
<p>当代码 new Foo(...) 执行时，会发生以下事情：</p>
<p>一个继承自 Foo.prototype 的新对象被创建。<br>
使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。<br>
由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）<br>
你始终可以对已定义的对象添加新的属性。例如，car1.color = &quot;black&quot; 语句给 car1 添加了一个新的属性 color，并给这个属性赋值 &quot;black&quot;。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，你必须将该属性添加到 Car 对象类型的定义中。</p>
<p>你可以使用 Function.prototype 属性将共享属性添加到以前定义的对象类型。这定义了一个由该函数创建的所有对象共享的属性，而不仅仅是对象类型的其中一个实例。下面的代码将一个值为 null 的 color 属性添加到 car 类型的所有对象，然后仅在实例对象 car1 中用字符串 &quot;black&quot; 覆盖该值</p>
<pre><code>function Car() {}
car1 = new Car();
car2 = new Car();

console.log(car1.color);    // undefined

Car.prototype.color = &quot;original color&quot;;
console.log(car1.color);    // original color

car1.color = 'black';
console.log(car1.color);   // black

console.log(car1.__proto__.color) //original color
console.log(car2.__proto__.color) //original color
console.log(car1.color)  // black
console.log(car2.color) // original color
</code></pre>
<blockquote>
<p>如果你没有使用 new 运算符， 构造函数会像其他的常规函数一样被调用， 并不会创建一个对象。在这种情况下， this 的指向也是不一样的。</p>
</blockquote>
<h3 id="二-自定义一个new">二、自定义一个new</h3>
<pre><code>  // 构造器函数
  let Parent = function (name, age) {
    this.name = name;
    this.age = age;
  };
  Parent.prototype.sayName = function () {
    console.log(this.name);
  };
  //自己定义的new方法
  let newMethod = function (Parent, ...rest) {
    // 1.以构造器的prototype属性为原型，创建新对象；
    let child = Object.create(Parent.prototype);
    // 2.将this和调用参数传给构造器执行
    Parent.apply(child, rest);
    // 3.返回第一步的对象
    return child;
  };
  //创建实例，将构造函数Parent与形参作为参数传入
  const child = newMethod(Parent, 'echo', 26);
  child.sayName() //'echo';

  //最后检验，与使用new的效果相同
  child instanceof Parent//true
  child.hasOwnProperty('name')//true
  child.hasOwnProperty('age')//true
  child.hasOwnProperty('sayName')//false
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js 常用工具 （util.inherits）]]></title>
        <id>https://weidadeda.github.io/post/nodejs-chang-yong-gong-ju-utilinherits</id>
        <link href="https://weidadeda.github.io/post/nodejs-chang-yong-gong-ju-utilinherits">
        </link>
        <updated>2022-01-19T03:27:23.000Z</updated>
        <content type="html"><![CDATA[<p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>
<p>util.inherits<br>
util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。</p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<p>在这里我们只介绍util.inherits 的用法，示例如下：</p>
<pre><code>var util = require('util'); 
function Base() { 
    this.name = 'base'; 
    this.base = 1991; 
    this.sayHello = function() { 
    console.log('Hello ' + this.name); 
    }; 
} 
Base.prototype.showName = function() { 
    console.log(this.name);
}; 
function Sub() { 
    this.name = 'sub'; 
} 
util.inherits(Sub, Base); 
var objBase = new Base(); 
objBase.showName(); 
objBase.sayHello(); 
console.log(objBase); 
var objSub = new Sub(); 
objSub.showName(); 
//objSub.sayHello(); 
console.log(objSub);
</code></pre>
<p>我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：</p>
<pre><code>base 
Hello base 
{ name: 'base', base: 1991, sayHello: [Function] } 
sub 
{ name: 'sub' }
</code></pre>
<p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。</p>
<p>同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：</p>
<pre><code>node.js:201 
throw e; // process.nextTick error, or 'error' event on first tick 
^ 
TypeError: Object #&lt;Sub&gt; has no method 'sayHello' 
at Object.&lt;anonymous&gt; (/home/byvoid/utilinherits.js:29:8) 
at Module._compile (module.js:441:26) 
at Object..js (module.js:459:10) 
at Module.load (module.js:348:31) 
at Function._load (module.js:308:12) 
at Array.0 (module.js:479:10) 
at EventEmitter._tickCallback (node.js:192:40)
</code></pre>
<p>转载自https://www.cnblogs.com/yuwenjing0727/p/8135608.html</p>
]]></content>
    </entry>
</feed>