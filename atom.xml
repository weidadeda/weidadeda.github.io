<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://weidadeda.github.io</id>
    <title>Gridea</title>
    <updated>2022-02-10T02:29:36.002Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://weidadeda.github.io"/>
    <link rel="self" href="https://weidadeda.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://weidadeda.github.io/images/avatar.png</logo>
    <icon>https://weidadeda.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[C端H5或小程序常见问题总结]]></title>
        <id>https://weidadeda.github.io/post/c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie</id>
        <link href="https://weidadeda.github.io/post/c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie">
        </link>
        <updated>2022-02-09T07:59:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1部分机型拍照上传图片旋转问题">1.部分机型拍照上传图片旋转问题：</h3>
<p>直接从图片后面加参数‘?x-oss-process=image/auto-orient,1/resize,m_fixed’（加上参数之后会自动旋转回来，其他参数可参考阿里OSS官方文档https://help.aliyun.com/document_detail/44691.html?spm=a2c4g.11186623.6.1390.750ac1f6HTe92Q）</p>
<h3 id="2swiper3d两边留白效果">2.swiper3D两边留白效果：</h3>
<p>（小程序h5均适用），代码如下，需要注意的是必须给swiper父级元素加overflow-x:hidden</p>
<pre><code>.swiper-container {
  height: 100%;
  width: 600px;
  perspective: 1600px;
  overflow: visible;
  img {
    width: 100%;
    height: 720px;
    border-radius: 20px;
  }
}
.swiper-slide {
  padding: 0 24px;
  box-sizing: border-box;
  text-align: center;
  transition: transform 0.5s;
  transform-origin: 50% 50%;
  transform: scale(0.9);
  &amp;.swiper-slide-active {
    transform: scale(1);
  }
}
</code></pre>
<h3 id="3小程序的跳转十层限制不要一直用navigateto这样属于一直前进如果需要跳转回首页或者其他可以使用relaunch逻辑复杂时可自己写顶部导航栏包括返回按钮">3.小程序的跳转十层限制，不要一直用navigateTo，这样属于一直前进，如果需要跳转回首页或者其他可以使用reLaunch，逻辑复杂时可自己写顶部导航栏包括返回按钮。</h3>
<h3 id="4保存海报到本地推荐一波生成小程序海报的插件非常简单方便">4.保存海报到本地：推荐一波生成小程序海报的插件，非常简单方便</h3>
<p>taro-plugin-canvas (Taro环境使用)与wxa-plugin-canvas（普通小程序使用）<br>
tip:如果遇到非常规的情况，需要手写canvas并且宽高尺寸乘2保证清晰度。</p>
<h3 id="5input光标永远停留在最后">5.input光标永远停留在最后：</h3>
<pre><code>var el = document.getElementById(&quot;IPTname&quot;);
var range = document.createRange();
range.selectNodeContents(el);
range.collapse(false);
var sel = window.getSelection();
sel.removeAllRanges();
sel.addRange(range);
</code></pre>
<h3 id="6小程序获取用户授权用户信息用户定位用户相册访问权限等时需要处理拒绝时的情况-生成海报到自己相册的时候如果用户在授权的时候点击了拒绝如果不兼容拒绝授权则直接生成失败">6.小程序获取用户授权（用户信息/用户定位/用户相册访问权限等）时需要处理拒绝时的情况。生成海报到自己相册的时候如果用户在授权的时候点击了拒绝，如果不兼容拒绝授权则直接生成失败。</h3>
<h3 id="7监听移动端键盘弹出和收起事件">7.监听移动端键盘弹出和收起事件。</h3>
<p>在ios设备上,操作表单输入时,键盘弹出时会把页面顶起来,键盘收起时并不会把页面恢复成原来的样子,造成页面样式错乱,利用focusout和focusin事件,可以间接地监听到键盘的收起和弹出事件,然后操作页面滚动到想要的位置.</p>
<p>focusout触发时机:  当元素即将失去焦点时，focusout 事件被触发。focusout 事件和 blur 事件之间的主要区别在于后者不会冒泡。</p>
<p>focusin触发时机:    当元素即将接收 focus 事件时，focusin 事件被触发。 这个事件和 focus 事件的主要区别在于后者不会冒泡。</p>
<p>监听方式:</p>
<pre><code>let scrollTop = 0
//键盘收起
document.body.addEventListener('focusout',()=&gt;{
   document.body.scrollTop=document.documentElement.scrollTop=scrollTop
})
//键盘弹出
document.body.addEventListener('focusin',()=&gt;{
   scrollTop = document.body.scrollTop || document.documentElement.scrollTop
})
</code></pre>
<h3 id="8移动端代码返回上一页windowlocationback失效">8.移动端代码返回上一页（window.location.back()失效）</h3>
<p>尼玛。。移动端返回上一页有时候用window.location.back()不好使，无解。可以使用window.location.href = document.referrer。</p>
<h3 id="9单页面应用跳转路由之后再次使用echarts时不展示">9.单页面应用跳转路由之后再次使用echarts时不展示</h3>
<p>首次使用不展示，可以延迟加载，但是当路由跳转回来之后延迟都不管用，那么需要在init Echarts之前动态设置容器宽高，并且清空父元素，因为再次回来的时候之前的echarts实例已经是存在的了，可在调试中查看详情。</p>
<h3 id="10-视频黑边问题">10. 视频黑边问题</h3>
<p>给video标签（原生video标签）加一个object-fit:fill属性即可解决。要强调的是，千万不要使用Taro的Video标签，很坑，解决了黑边，全屏时又会导致视频变形，不用object:fill的话也能解决黑边，但是全屏时视频的退出全屏样式又会被覆盖。</p>
<h3 id="11-手机锁屏时倒计时停止">11. 手机锁屏时倒计时停止</h3>
<pre><code>window.addEventListener('visibilitychange',() =&gt; {
   if (
     //hidden为锁屏时或页面不展示时，可重新获取时间开始倒计时。
      document.visibilityState =='hidden'
   ) 
})
</code></pre>
<h3 id="12移动端实现省-市-区-街道四级联动">12.移动端实现省-市-区-街道四级联动</h3>
<p>需求是要实现地区四级联动，但是vant的插件只支持三级地区联动，就很尴尬，只能自己写，但是自己写的话UI与交互体验会很差，所以就想办法去和后端对接。其实很简单，写出来只是提醒大家可以这么实现，减少思考与踩坑的时间。三级联动选择完之后会返回地区编码，eg:Array&lt;{code:'110101',name:'东城区'}&gt;,然后去请求后端的接口将地区编码传过去，就能得到其街道的相关信息，然后简单过滤一下，放在Picker选择器中就可以实现。接下来就可以写业务逻辑了。</p>
<h3 id="13ios内webview中vue项目会出现大块白色遮罩">13.ios内webview中vue项目会出现大块白色遮罩</h3>
<p>问题描述：</p>
<p>A页面——&gt;B页面——&gt;ios自带的返回——&gt;白屏出现(像个魔鬼)——&gt;点击或滑动页面——&gt;问题解决</p>
<p>原因是，经过排查，发现在ios 机器上使用webview 开发Vue项目时候，go history (-1)，无法将body 的高度拉掉，使得遮住，触发轻点击，方可消除该遮罩</p>
<p>解决的理论：用于最重要的html 容器是container，然而因为设置html、body高度是100%，从而造成了 container 撑开父级，但浏览器默认滚动的scroll 并不是 container，而是body，某些因素，造成返回history 后，无法复原（ios 的锅），为此，将 container(app.vue中包裹的div，也可以是#app) 进行了绝对定位，并让它重新成为 scroll 的对象，从而解决问题。</p>
<pre><code>html, body {

 width: 100%;

 height: 100%;
 min-height: 100vh;

 margin: 0;

 padding: 0;

 position: relative;

}

.container {

 width: 100%;

height: 100vh;
 min-height: 100vh;

 background: #fff;

 overflow: scroll;

 -webkit-overflow-scrolling: touch;

 position: absolute;

 left:0;

 top:0;

}
</code></pre>
<h3 id="14在ios上a页面分享朋友圈之后跳转到-b-页面或进行别的操作">14.在ios上A页面分享朋友圈之后，跳转到 B 页面（或进行别的操作）</h3>
<p>注：离开 app的 A 页面去微信，再次回到 app 的时候跳转到 B 页面</p>
<p>visibilitychange：当用户最小化窗口或者切换选项卡的时候，api 就会发送visibilitychange事件，让开发者知道页面状态已更改。你可以检测事件并执行某些操作或行为。</p>
<pre><code>//这个方法在分享被触发的时候执行
initVisibilityChange() {
      if (typeof document.visibilityState != &quot;undefined&quot;) {
        this.visibleChange = &quot;visibilitychange&quot;;
        this.vibibleState = &quot;visibilityState&quot;;
      } else if (
        typeof (document as any).webkitVisibilityState != &quot;undefined&quot;
      ) {
        this.visibleChange = &quot;webkitvisibilitychange&quot;;
        this.vibibleState = &quot;webkitVisibilityState&quot;;
      }
      if (this.visibleChange) {
        document.addEventListener(
          this.visibleChange,
          this.onVisibilityChanged,
          false
        );
      }
    },
      /**
     * 从微信返回app可以在这里面处理事情
     */
    onVisibilityChanged(event: any) {
      var hidden = event.target.webkitHidden;
      if ((document as any)[this.vibibleState] == &quot;visible&quot;) {
          this.goRun(); // 做自己需要的逻辑处理
          this.removeVisibilityChange();
      }
    },
     // 移除app后台监听事件
    removeVisibilityChange() {
      document.removeEventListener(
        this.visibleChange,
        this.onVisibilityChanged,
        false
      );
    },
</code></pre>
<h3 id="15-从vue页面跳转到非vue页面点击返回ios设备上页面数据不刷新">15. 从vue页面跳转到非vue页面，点击返回，ios设备上页面数据不刷新。</h3>
<p>比如A页面定义了一个变量为true，点击跳转到非vue项目页面（php），点击返回，查看这个变量，在安卓上依然为ture，但是在ios上就变成了false。</p>
<p>解决方法：</p>
<pre><code>window.onpageshow=function(e){
　　if(e.persisted) {
　　　　window.location.reload()
　　}
};
</code></pre>
<h3 id="16-app点击自带返回按钮关闭页面以及禁用返回的踩坑记录">16. app点击自带返回按钮关闭页面以及禁用返回的踩坑记录</h3>
<p>http://note.youdao.com/s/4qUINhV0 （比较多，有道云链接发出来，希望对大家有帮助）</p>
<h3 id="17-wxchooseimage方法在安卓与ios上取到的base64格式不一样安卓没有dataimagejpgbase64前缀需要单独处理">17. wx.chooseImage方法在安卓与ios上取到的base64格式不一样，安卓没有data:image/jpg;base64前缀，需要单独处理</h3>
<h3 id="18-手机内h5点击input无法唤起自带键盘可以给input添加click事件手动触发focus事件">18. 手机内h5点击input无法唤起自带键盘：可以给input添加click事件手动触发focus事件。</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js获取文件大小 window.performance]]></title>
        <id>https://weidadeda.github.io/post/js-huo-qu-wen-jian-da-xiao</id>
        <link href="https://weidadeda.github.io/post/js-huo-qu-wen-jian-da-xiao">
        </link>
        <updated>2022-02-07T09:49:49.000Z</updated>
        <content type="html"><![CDATA[<p>背景：今天 每周例行技术分享 的时候，有位同事说 js 获取不到文件大小：浏览器默认不允许js 执行IO操作。 举了个例子，比如想获取一个图片地址的文件大小，因为之前做过图片上传功能所以比较敏感，感觉应该是可以的，虽然他说网上找过很多资料但是都不行，但是这种东西 只有自己试试才安心嘛~~</p>
<h3 id="失败方案-canvastoblob">失败方案 canvas.toBlob</h3>
<pre><code>function loadImg(url){
    return new Promise((res, rej) =&gt; {
        const img = new Image()
        img.crossOrigin = ''   // 防止img 画在canvas上时报跨域错误
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej()
        }
        img.src = url
    })
}

async function getImgSize(url) {
    const urlArr = url.split('.')
    const mime = &quot;image/&quot; + urlArr[urlArr.length-1]
    const img = await loadImg(url)
    const {width,height} = img
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img,0,0,width,height)
    canvas.toBlob(
        blob =&gt; {
            console.log(url,blob,(blob.size / 1000)+'KB')
        },
        mime
    );
}

getImgSize('https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg')
</code></pre>
<p>看日志输出<br>
<img src="https://weidadeda.github.io/post-images/1644227403808.jpg" alt="" loading="lazy"><br>
看着成了，但实际.... 与 本地 和 Network 差 十万八千里<br>
<img src="https://weidadeda.github.io/post-images/1644227440435.png" alt="" loading="lazy"><br>
<img src="https://weidadeda.github.io/post-images/1644227452558.jpg" alt="" loading="lazy"><br>
我尝试了几个图片,每个图片都比之前要大，而且增大程度不一定,这块估计是canvas画了一遍的原因。。。</p>
<h3 id="失败方法-canvastodataurl-dataurltoblob">失败方法 canvas.toDataURL + dataURLtoBlob</h3>
<pre><code>function loadImg(url){
    return new Promise((res, rej) =&gt; {
        const img = new Image()
        img.crossOrigin = ''   // 防止img 画在canvas上时报跨域错误
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej()
        }
        img.src = url
    })
}

async function getImgSize(url) {
    const urlArr = url.split('.')
    const mime = &quot;image/&quot; + urlArr[urlArr.length-1]
    const img = await loadImg(url)
    const {width,height} = img
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img,0,0,width,height);
    const blob =  dataURLtoBlob(canvas.toDataURL(mime));
    console.log(url,blob,(blob.size / 1000)+'KB')
}
function dataURLtoBlob(dataurl) {
    var arr = dataurl.split(',');
    var _arr = arr[1].substring(0,arr[1].length-2);
    var mime = arr[0].match(/:(.*?);/)[1],
        bstr =atob(_arr),
        n = bstr.length,
        u8arr = new Uint8Array(n);
    while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], {
        type: mime
    });
}

getImgSize('https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg')
</code></pre>
<p>看结果⬇️<br>
<img src="https://weidadeda.github.io/post-images/1644227621781.jpg" alt="" loading="lazy"><br>
。。。看来不能走canvas这条路了</p>
<h3 id="成功方案-performance">成功方案 performance</h3>
<p><img src="https://weidadeda.github.io/post-images/1644227695711.png" alt="" loading="lazy"><br>
难道真的没有办法了嘛？我盯着 浏览器Network 陷入沉思, 突然 Network 资源加载 的size在我眼里 越来越抢眼，貌似有个api可以获取到资源加载~~~~~ 走起</p>
<pre><code>function getImgSize(url){
    return new Promise((res, rej) =&gt; {
        var performance = window.performance || 
            window.msPerformance || 
            window.webkitPerformance;
        if (performance) {
            const img = new Image()
            img.crossOrigin = ''
            img.onload = function() {
                let [imgEntries] = performance.getEntriesByName(url)
                res(imgEntries)
            }
            img.onerror = function() {
                rej('图片加载失败')
            }
            img.src = url
        }else{
            rej('浏览器不持支持performance')
        }
    })
}
let url = 'https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg'
getImgSize(url).then(v=&gt;{
    console.log(v)
    console.log(v.decodedBodySize)
    console.log((v.decodedBodySize / 1000),'KB')
    // transferSize  判断是否缓存
})
</code></pre>
<blockquote>
<p>这块使用 decodedBodySize，因为 css js等资源 decodedBodySize 与本地大小一致<br>
<img src="https://weidadeda.github.io/post-images/1644227863370.png" alt="" loading="lazy"><br>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/decodedBodySize">decodedBodySize-MDN文档</a><br>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/encodedBodySize">encodedBodySize-MDN 文档</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/getEntriesByName">performance.getEntriesByName-MDN文档</a><br>
哈哈哈哈，成了～</p>
</blockquote>
<h3 id="多组数据验证">多组数据验证</h3>
<table>
<thead>
<tr>
<th style="text-align:left">图片地址</th>
<th style="text-align:center">本地size</th>
<th style="text-align:center">canvas.toBlob</th>
<th style="text-align:center">canvas.toDataURL + dataURLtoBlob</th>
<th style="text-align:center">performance</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg</td>
<td style="text-align:center">20519</td>
<td style="text-align:center">36345</td>
<td style="text-align:center">36343</td>
<td style="text-align:center">20519</td>
</tr>
<tr>
<td style="text-align:left">https://images.daojia.com/dop/custom/dda52b42212b6bdea3e12d03ac97ffbe.png</td>
<td style="text-align:center">65511</td>
<td style="text-align:center">164303</td>
<td style="text-align:center">164302</td>
<td style="text-align:center">65511</td>
</tr>
<tr>
<td style="text-align:left">https://images.daojia.com/dop/custom/f8f0528c61e243699c309f5f25eab513.png</td>
<td style="text-align:center">14638</td>
<td style="text-align:center">36394</td>
<td style="text-align:center">36391</td>
<td style="text-align:center">14638</td>
</tr>
</tbody>
</table>
<h4 id="没有看错-performance-与本地的完全一样">没有看错 performance 与本地的完全一样</h4>
<h3 id="不限制于图片">不限制于图片</h3>
<pre><code>function loadJSFile(source) {
    return new Promise((res, rej) =&gt; {
        const node = document.createElement('script')
        node.async = false
        node.src = source

        const supportOnload = 'onload' in node
        if (supportOnload) {
            node.onload = function(){
                res(this)
            }
            node.onerror = () =&gt; {
                rej(`${source}加载失败`)
            }
        } else {
            node.onreadystatechange = function(){
                if (/loaded|complete/i.test(node.readyState)) {
                    res(this)
                }
            }
        }
        document.getElementsByTagName('head')[0].appendChild(node)
    })
}
function loadImgFile(url){
    return new Promise((res, rej) =&gt; {
        const img = new Image()
        img.crossOrigin = ''
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej('图片加载失败')
        }
        img.src = url
    })
}

function loadCSSFile(source) {
    return new Promise((res, rej) =&gt; {
        var head = document.getElementsByTagName('head')[0];
        var link = document.createElement('link');
        link.type = 'text/css';
        link.rel = 'stylesheet';
        link.href = source;
        const supportOnload = 'onload' in link
        if (supportOnload) {
            link.onload = function(){
                res(this)
            }
            link.onerror = () =&gt; {
                rej(`${source}加载失败`)
            }
        } else {
            link.onreadystatechange = function(){
                if (/loaded|complete/i.test(link.readyState)) {
                    res(this)
                }
            }
        }
        head.appendChild(link);
    })
}
function getFileSize(url){
    return new Promise((res, rej) =&gt; {
    var performance = window.performance || 
        window.msPerformance || 
        window.webkitPerformance;
    if (performance) {
        let [imgEntries] = performance.getEntriesByName(url)
        if(imgEntries){
            console.log(imgEntries)
            console.log(imgEntries.decodedBodySize)
            console.log((imgEntries.decodedBodySize / 1000),'KB')
            res(imgEntries)
        }else{
            rej('资源加载有问题')
        }
    }else{
        rej('浏览器不持支持performance')
    }
})
}
(async function (){
    const css = 'https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css';
    await loadCSSFile(css)
    await getFileSize(css)

    const js = 'https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js';
    await loadJSFile(js)
    await getFileSize(js)

    const img = 'https://images.daojia.com/dop/custom/f8f0528c61e243699c309f5f25eab513.png';
    await loadImgFile(img)
    await getFileSize(img)
})()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644228526757.png" alt="" loading="lazy"></figure>
<h3 id="兼容性">兼容性</h3>
<p>最后记得使用<a href="https://caniuse.com/?search=encodedBodySize">caniuse - performance</a>查看一下兼容性</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用yeoman开发一个自己的项目脚手架]]></title>
        <id>https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia</id>
        <link href="https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia">
        </link>
        <updated>2022-02-07T07:37:02.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://weidadeda.github.io/post-images/1644219568486.gif" alt="" loading="lazy"><br>
上面是一个使用脚手架来初始化项目的典型例子。<br>
随着前端工程化的理念不断深入，越来越多的人选择使用脚手架来从零到一搭建自己的项目。其中大家最熟悉的就是create-react-app和vue-cli，它们可以帮助我们初始化配置、生成项目结构、自动安装依赖，最后我们一行指令即可运行项目开始开发，或者进行项目构建（build）。<br>
这些脚手架提供的都是普遍意义上的最佳实践，但是我在开发中发现，随着业务的不断发展，必然会出现需要针对业务开发的实际情况来进行调整。例如：</p>
<ol>
<li>
<p>项目架构的配置<br>
a. webpack/gulp的配置<br>
ⅰ. style/less/sass的选择和处理配置。<br>
ⅱ. Typescript和JavaScript的loader和babel的配置，比如babel-loader和tsc。<br>
ⅲ. 图片的配置，比如需要file-loader或者url-loader。<br>
ⅳ. 静态资源的配置。<br>
ⅴ. 企业内部，真对于某些特定功能的webpack-loader/webpack-plugin，比如打包完图片上传。<br>
b. 是否内置一些第三方框架供上手使用，比如Element-UI，Antd等。<br>
c. 项目的路由的设计和配置。<br>
d. 项目目录结构的设计和配置。<br>
e. 项目通用功能的有关代码，比如登陆和欢迎页等。<br>
f.通过调整插件与配置实现 Webpack 打包性能优化<br>
g.针对生产环境做的单独处理</p>
</li>
<li>
<p>项目开发中的配置<br>
a. eslint。<br>
b. style-lint。<br>
c. prettier。<br>
d. 单元测试jest或者其他单元测试框架。<br>
e. 项目文档的自动生成，比如docz。<br>
f. git相关的，比如git提交的校验，生成changelog<br>
g. npm相关，除非是开发npm包，否则npm相关的不是那么重要<br>
h. 与开发有关的工具，比如打包构建结果的包分析、比如相似代码自动生成</p>
</li>
<li>
<p>项目上线脚本，这个应该是可选项？更优的方法应该是使用内部的例如发布平台之类的工具完成，或者通过jekins或者gitlab-ci进行自动化发布，回滚等操作。上线发布回滚的动作可以完全交给非开发人员完成。<br>
a. 比如由nodejs编写的上线脚本，或者是用于上线的shell脚本。<br>
b. gitlab-ci的配置文件</p>
</li>
</ol>
<p>……<br>
总而言之，随着业务发展，我们往往会沉淀出一套更“个性化”的业务方案。这时候我们最直接的做法就是开发出一个该方案的脚手架来，以便今后能复用这些最佳实践与方案。<br>
那么就需要使用一个工具来帮我们做这些处理，我们使用的就是yoman。<a href="https://yeoman.io/">官网地址</a><br>
我们可以使用yeoman和yeoman的generator来更加便捷实现我们的脚手架，可以说基本是零成本。<br>
先说说Yeoman是什么，它想做什么？<br>
Yeamon帮助你快速的开展一个项目工程，提供最佳实践和工具，来让你保持高效率编码。</p>
<p>他们自己提供了一个构建生态系统，主要通过‘yo’这个命令来构建一个完整的项目或者项目的一部分。</p>
<p>通过官方的生成器，他们建立了一个Yeoman的工作流，这个流是由一个强大的,固定的客户端组建，包含工具和框架帮助开发者快速建立牛逼的web应用。他们尽量提供了开发者所需的东西。比如先下载对应模版项目，然后下载模版项目中的package.json中的包</p>
<p>作为良好文档和深入思考构建过程的思想者，Yeoman包含了检测（静态检测）、测试以及压缩等等一系列工具，让开发者能够更加专注于思考解决方案。</p>
<h3 id="如何使用">如何使用：</h3>
<p>1、npm install -g yo //权限不够，请加上 sudo，一般来说mac都需要。<br>
安装完成之后，你就拥有了1个命令 -- yo 可以选择自定义的，也可以搜索你想要的现成的，这里我们选择自己的。 官网提供的地址：http://yeoman.io/generators/<br>
那我们开始编写一个自己的generators。<br>
2、开发自己的generator<br>
创建项目<br>
全局安装generator-generator，然后使用创建项目，根据提示输出我们的generator项目的名字，yeoman规定项目名字必须以generator开头，所以我们可以选择generator-xxx作为我们的项目名<br>
npm i -g generator-generator<br>
yo generator<br>
创建好项目之后，我们可以发现已经自动为我们配置好了eslint，jest，husky</p>
<p>我们主要需要修改的代码位于generators/app内<br>
● index.js定义了我们使用此generator时的一些操作配置项<br>
● templates内存放的是要生成的项目的项目模板，项目模板也可以放在git上，然后通过download-git-repo下载到本地<br>
验证我们创建的项目</p>
<ol>
<li>在当前项目执行npm link使其被链接到全局</li>
<li>然后找一个目录，终端执行yo，此时便可以发现我们的generator已经出现在了选择列表中。然后选择我们的generator运行即可。等待完成，会发现成功的创建了一个叫做dummyfile.txt的文件夹。<br>
generators/app/index.js<br>
初始化的文件如下。</li>
</ol>
<pre><code>&quot;use strict&quot;;
const Generator = require(&quot;yeoman-generator&quot;);
const chalk = require(&quot;chalk&quot;);
const yosay = require(&quot;yosay&quot;);

module.exports = class extends Generator {
  prompting() {
    // Have Yeoman greet the user.
    this.log(
      yosay(
        `Welcome to the fantastic ${chalk.red(&quot;generator-rc-op&quot;)} generator!`
      )
    );

    const prompts = [
      {
        type: &quot;confirm&quot;,
        name: &quot;someAnswer&quot;,
        message: &quot;Would you like to enable this option?&quot;,
        default: true
      }
    ];

    return this.prompt(prompts).then(props =&gt; {
      // To access props later use this.props.someAnswer;
      this.props = props;
    });
  }

  writing() {
    this.fs.copy(
      this.templatePath(&quot;dummyfile.txt&quot;),
      this.destinationPath(&quot;dummyfile.txt&quot;)
    );
  }

  install() {
    this.installDependencies();
  }
};
</code></pre>
<p>从文件的内容可以看出主要操作是暴露出一个继承自Generator的类，在类的内部定义了部分生命周期方法，供yoeman在适当的时候调用。我们只需要完善这些方法就可以了。</p>
<h3 id="yeoman提供的生命周期如下">yeoman提供的生命周期如下：</h3>
<ol>
<li>initializing：初始化必要的依赖，或者比如检测新版本</li>
<li>prompting：用来处理终端的交互</li>
<li>default：这里指的是自己自定义的方法，而不是名为default的方法，自己定义的方法如果不想被调用，那么需要确保方法名以_为开头。</li>
<li>writing：将经过ejs模板渲染后的内容写入文件系统。</li>
<li>conflicts：勇于解决将文件内容写入文件系统时可能造成的冲突</li>
<li>install：安装项目的依赖，比如npm install 或者 bower install</li>
<li>end：做一些收尾的工作。</li>
</ol>
<p>这些生命周期方法均支持返回Promise来进行异步操作。</p>
<h3 id="内置常用工具">内置常用工具</h3>
<p>终端交互：内置了Inquirer提供终端交互<br>
模板填充：内置了ejs模板<br>
文件操作<br>
● this.fs.copyTpl：用于拷贝并且根据数据使用ejs模板渲染文件。此函数接受三个参数，源文件路径，目标文件路径，传给ejs用于渲染目标问价的数据。<br>
● this.fs.copy：将文件丛源路径复制到目标路径。<br>
● this.destinationPath() ：此函数返回最终生成项目的路径<br>
其他<br>
● this.npmInstall：实现npm isntall</p>
<pre><code>// 部分代码，完整代码见最下方链接
writing() {
    const done = this.async();
    this.log(&quot;⚙  Finish basic configuration.&quot;, chalk.green(&quot;✔&quot;));
    this.log(&quot;📂 Generate the project template and configuration...&quot;);
    let spinner = ora({
      text: `Download the template from ${GIT_BASE}${TPL_REPOSITORY}...`,
      spinner: ORA_SPINNER
    }).start();
    this._downloadTemplate(TPL_REPOSITORY)
      .then(() =&gt; {
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish downloading the template from ${GIT_BASE}${TPL_REPOSITORY}`
        });
        spinner = ora({
          text: `Copy files into the project folder...`,
          spinner: ORA_SPINNER
        }).start();
        const templateRoot = this.destinationPath(this.dirName, &quot;.tmp&quot;);
        this.log(`\n${templateRoot}`, &quot;templateRoot&quot;);
        const resoPath = path.resolve(templateRoot, &quot;../&quot;);
        this.log(resoPath, &quot;resoPath&quot;);
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish copying files into the project folder`
        });
        execSync(`cp -R ${resoPath}/.tmp/* ${resoPath}`, { stdio: &quot;inherit&quot; });
        spinner = ora({
          text: `Clean tmp files and folders...`,
          spinner: ORA_SPINNER
        }).start();
        fs.removeSync(templateRoot);
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish cleaning tmp files and folders`
        });
        // ExecSync(`rm -R ${resoPath}/.tmp`, { stdio: &quot;inherit&quot; });
        // 将新生成的项目的title换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/public/index.html`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/public/index.html`, str);
          }
        );
        // 将新生成的项目的package.json的name换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/package.json`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/package.json`, str);
          }
        );
        done();
      })
      .catch(err =&gt; this.env.error(err));
  }
</code></pre>
<h3 id="其他可能用到的工具">其他可能用到的工具</h3>
<p>● ora：用于创建Spinner，即比如下载模板文件时需要展示的laoding效果。<br>
● chalk：用于打印彩色的信息<br>
● update-notifier<br>
● beeper<br>
● boxen<br>
调试<br>
由于yeoman是通过npm包的形式进行使用的，所以我们可以在我们开发的generator项目的跟目录下，执行npm link 将我们开发的generator链接到全局，这样我们直接使用yo命令查看可以使用的generator，就可以看到我们所开发的generator了，并且是实时生效的</p>
<h3 id="我的代码是在本地的用的npm-link没有上传到github或npm此处贴出其他大佬的项目代码-快动手试一下吧~">我的代码是在本地的，用的npm link，没有上传到github或npm，此处贴出其他大佬的项目代码。快动手试一下吧～</h3>
<p><a href="https://github.com/alienzhou/webpack-kickoff-template">模版完整代码</a>   注意要给ejs写入的空位<br>
<a href="https://github.com/alienzhou/generator-webpack-kickoff">脚手架完整代码</a></p>
<h3 id="参考文章">参考文章：</h3>
<p><a href="https://www.yuque.com/kongdepeng/rgpm60/qrluup">前端自动化工具 - yeoman</a><br>
<a href="https://zhuanlan.zhihu.com/p/66190308">如何快速开发一个自己的项目脚手架？</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用Object.create浅拷贝一个对象]]></title>
        <id>https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang</id>
        <link href="https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang">
        </link>
        <updated>2022-01-21T02:41:42.000Z</updated>
        <content type="html"><![CDATA[<p>// 首先得介绍一下深拷贝和浅拷贝（虽然大家都知道，但毕竟写文章，还是得照顾下不知道的同学）<br>
// 其次问下大家object.assign属于浅拷贝还是深拷贝<br>
// Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型<br>
// Object.getOwnPropertyDescriptors方法配合 Object.create() 方法可以实现浅拷贝。<br>
// <code>// Object.create( // Object.getPrototypeOf(obj), // Object.getOwnPropertyDescriptors(obj) // ); //</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义一个new方法]]></title>
        <id>https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa</id>
        <link href="https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa">
        </link>
        <updated>2022-01-20T06:36:51.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">MDN new</a></p>
<h3 id="一-new的介绍">一、new的介绍</h3>
<p>new是干什么的：</p>
<blockquote>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
</blockquote>
<p>使用new可以少做四件事情：</p>
<p>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；<br>
不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；<br>
不用 return 临时对象，因为 new 会帮你做；<br>
不要给原型想名字了，因为 new 指定名字为 prototype。</p>
<p>new 关键字会进行如下的操作：</p>
<p>创建一个空的简单JavaScript对象（即{}）；<br>
为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；<br>
将步骤1新创建的对象作为this的上下文 ；<br>
如果该函数没有返回对象，则返回this。<br>
（译注：关于对象的 constructor，参见 Object.prototype.constructor）</p>
<p>创建一个用户自定义的对象需要两步：</p>
<p>通过编写函数来定义对象类型。<br>
通过 new 来创建对象实例。<br>
创建一个对象类型，需要创建一个指定其名称和属性的函数；对象的属性可以指向其他对象，看下面的例子：</p>
<p>当代码 new Foo(...) 执行时，会发生以下事情：</p>
<p>一个继承自 Foo.prototype 的新对象被创建。<br>
使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。<br>
由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）<br>
你始终可以对已定义的对象添加新的属性。例如，car1.color = &quot;black&quot; 语句给 car1 添加了一个新的属性 color，并给这个属性赋值 &quot;black&quot;。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，你必须将该属性添加到 Car 对象类型的定义中。</p>
<p>你可以使用 Function.prototype 属性将共享属性添加到以前定义的对象类型。这定义了一个由该函数创建的所有对象共享的属性，而不仅仅是对象类型的其中一个实例。下面的代码将一个值为 null 的 color 属性添加到 car 类型的所有对象，然后仅在实例对象 car1 中用字符串 &quot;black&quot; 覆盖该值</p>
<pre><code>function Car() {}
car1 = new Car();
car2 = new Car();

console.log(car1.color);    // undefined

Car.prototype.color = &quot;original color&quot;;
console.log(car1.color);    // original color

car1.color = 'black';
console.log(car1.color);   // black

console.log(car1.__proto__.color) //original color
console.log(car2.__proto__.color) //original color
console.log(car1.color)  // black
console.log(car2.color) // original color
</code></pre>
<blockquote>
<p>如果你没有使用 new 运算符， 构造函数会像其他的常规函数一样被调用， 并不会创建一个对象。在这种情况下， this 的指向也是不一样的。</p>
</blockquote>
<h3 id="二-自定义一个new">二、自定义一个new</h3>
<pre><code>  // 构造器函数
  let Parent = function (name, age) {
    this.name = name;
    this.age = age;
  };
  Parent.prototype.sayName = function () {
    console.log(this.name);
  };
  //自己定义的new方法
  let newMethod = function (Parent, ...rest) {
    // 1.以构造器的prototype属性为原型，创建新对象；
    let child = Object.create(Parent.prototype);
    // 2.将this和调用参数传给构造器执行
    Parent.apply(child, rest);
    // 3.返回第一步的对象
    return child;
  };
  //创建实例，将构造函数Parent与形参作为参数传入
  const child = newMethod(Parent, 'echo', 26);
  child.sayName() //'echo';

  //最后检验，与使用new的效果相同
  child instanceof Parent//true
  child.hasOwnProperty('name')//true
  child.hasOwnProperty('age')//true
  child.hasOwnProperty('sayName')//false
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js 常用工具 （util.inherits）]]></title>
        <id>https://weidadeda.github.io/post/nodejs-chang-yong-gong-ju-utilinherits</id>
        <link href="https://weidadeda.github.io/post/nodejs-chang-yong-gong-ju-utilinherits">
        </link>
        <updated>2022-01-19T03:27:23.000Z</updated>
        <content type="html"><![CDATA[<p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>
<p>util.inherits<br>
util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。</p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<p>在这里我们只介绍util.inherits 的用法，示例如下：</p>
<pre><code>var util = require('util'); 
function Base() { 
    this.name = 'base'; 
    this.base = 1991; 
    this.sayHello = function() { 
    console.log('Hello ' + this.name); 
    }; 
} 
Base.prototype.showName = function() { 
    console.log(this.name);
}; 
function Sub() { 
    this.name = 'sub'; 
} 
util.inherits(Sub, Base); 
var objBase = new Base(); 
objBase.showName(); 
objBase.sayHello(); 
console.log(objBase); 
var objSub = new Sub(); 
objSub.showName(); 
//objSub.sayHello(); 
console.log(objSub);
</code></pre>
<p>我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：</p>
<pre><code>base 
Hello base 
{ name: 'base', base: 1991, sayHello: [Function] } 
sub 
{ name: 'sub' }
</code></pre>
<p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。</p>
<p>同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：</p>
<pre><code>node.js:201 
throw e; // process.nextTick error, or 'error' event on first tick 
^ 
TypeError: Object #&lt;Sub&gt; has no method 'sayHello' 
at Object.&lt;anonymous&gt; (/home/byvoid/utilinherits.js:29:8) 
at Module._compile (module.js:441:26) 
at Object..js (module.js:459:10) 
at Module.load (module.js:348:31) 
at Function._load (module.js:308:12) 
at Array.0 (module.js:479:10) 
at EventEmitter._tickCallback (node.js:192:40)
</code></pre>
<p>转载自https://www.cnblogs.com/yuwenjing0727/p/8135608.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Koa接口参数校验与返回值统一处理]]></title>
        <id>https://weidadeda.github.io/post/koa-jie-kou-can-shu-xiao-yan-yu-fan-hui-zhi-tong-yi-chu-li</id>
        <link href="https://weidadeda.github.io/post/koa-jie-kou-can-shu-xiao-yan-yu-fan-hui-zhi-tong-yi-chu-li">
        </link>
        <updated>2022-01-18T11:03:04.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/node-modules/parameter">parameter地址</a><br>
// Koa接口参数校验与返回值统一处理  将参数校验变成一个路由中间件，正确的话继续执行，错误的话抛出错误异常。<br>
// 在第一个中间件中自定义返回格式这里叫ctx.DATA（ctx上自定义一个对象，对象包含code默认200,msg默认‘成功’,data默认空对象）<br>
// 这里对错误异常做了处理，抛出的是带code码以及与code码对应的msg和错误原因data的对象，此时我们将错误信息赋值给ctx.DATA.data。app中先写一个捕获错误的中间件，这样抛出的错误我们能够捕获到，然后从这里我们给body赋值，这样错误时返回的就是code码和message都有的返回值<br>
// 当成功查找到数据库中的数据时，我们只需要将数据给ctx.DATA.data，那么返回值就是code码为200，msg为成功，data为正确数据的对象了。万一出现了登陆失败，我们也可以改变ctx.DATA.message为登陆失败，改变code码等</p>
<pre><code>/**
 * 数据校验
 * wiki：https://github.com/node-modules/parameter/blob/master/example.js
 * @type {Parameter}
 */
// const { HttpError } = require('../../utils/tool/error')
const util = require('util')
// const ERROR_MSG = require('./errorMsg')
const ERROR_MSG = Object.freeze({
  // en
  // 0: 'fail',
  // 1: 'validation error',
  // 200: 'ok',
  // 400: 'invalid param',
  // 401: 'unauthorized',
  // 403: 'forbidden',
  // 404: 'not found',
  // 500: 'internal server error',
  // 503: 'service busy',

  // zh-cn
  0: '失败',
  1: '验证码错误',
  200: '成功',
  400: '请求出错',
  401: '未授权的请求',
  403: '禁止：禁止执行访问',
  404: '找不到：请检查URL以确保路径正确',
  500: '服务器的内部错误',
  503: '服务不可用'
})

function CustomError(code, msg) {
  Error.call(this, '')

  this.code = code
  this.msg = msg || ERROR_MSG[code] || 'unknown error'

  this.getCodeMsg = function() {
    return {
      code: this.code,
      msg: this.msg
    }
  }
}

util.inherits(CustomError, Error)

function HttpError(code, msg) {
  if ([0, 1, 200, 400, 401, 403, 404, 500, 503].indexOf(code) &lt; 0) {
    throw Error('not an invalid http code')
  }

  CustomError.call(this, code, msg)
}

util.inherits(HttpError, CustomError)

const Parameter = require('parameter')
const parm = new Parameter()

// 自定义校验
parm.addRule('name', function(e, v) {
  let sta = /^[a-z]$/.test(v)
  return sta || '只能输入一个字母'
})

// 路由校验列表
const ruleList = {
  // 登录
  'post/api/login': {
    mobile: { type: 'string', required: true },
    password: { type: 'string', required: true }
  },
  // 获取配置
  'get/api/setting': {
    id: { type: 'string', required: true }
  },
  // 保存配置
  'post/api/setting': {
    id: { type: 'number', required: true },
    title: { type: 'string', required: false },
    report_fix_id: { type: 'string', required: false },
    fix_url: { type: 'string', required: false },
    env: { type: 'string', required: false },
    report: { type: 'number', required: false },
    report_interval: { type: 'number', required: false }
  },
  // CICD
  'post/api/deploy': {
    name: { type: 'string', required: true },
    branch: { type: 'string', required: false },
    env: { type: 'string', required: false }
  },
  // 用户详情
  'get/api/user-details': {
    user_id: { type: 'string', required: true }
  }
}

/**
 * 校验方法
 * @param ctx
 * @param next
 * @returns {Promise&lt;void&gt;}
 */
const parameter = async (ctx, next) =&gt; {
  let errors, data
  let method = 'get'
  if (ctx.request.method === 'GET') {
    data = ctx.query
  } else {
    method = 'post'
    data = ctx.request.body
  }
  console.log(method, data)
  try {
    let name = ctx.req._parsedUrl.pathname
    errors = parm.validate(ruleList[method + name], data)
  } catch (e) {
    throw new HttpError(0, e.toString())
  }
  if (errors &amp;&amp; errors.length) {
    ctx.DATA.data = errors
    throw new HttpError(0, '数据校验未通过')
  }
  await next()
}
module.exports = parameter
</code></pre>
<p>router.js</p>
<pre><code>// 数据校验
const router = require('koa-router')()
const parameter = require('../utils/parameter')
// project
router.get('/api/user-details', parameter, userDetail)
router.get('/api/setting', parameter, getSetting)
router.post('/api/setting', parameter, setSetting)
// common
router.post('/api/login', parameter, login)
// devops
router.post('/api/deploy', parameter, checkToken, deploy)
// swagger
router.get('/api/swagger.json', async function (ctx) {
  ctx.set('Content-Type', 'application/json')
  ctx.body = openapiSpecification
})
// index
router.get('/', index)

module.exports = router
</code></pre>
<p>app.js</p>
<pre><code>const Koa = require('koa')
const app = new Koa()
const views = require('koa-views')
const json = require('koa-json')
const favicon = require('koa-favicon')
const koaBody = require('koa-body')
const logger = require('koa-logger')
const colors = require('colors')
const { resolve } = require('path')
const { koaSwagger } = require('koa2-swagger-ui')
const mysql = require('mysql2')

const conf = require('./config')
const index = require('./routes')

// 允许上传文件
app.use(
  koaBody({
    multipart: true,
    formidable: {
      maxFileSize: 1000 * 1024 * 1024 // 设置上传文件大小最大限制
    }
  })
)

// 网站图标
app.use(favicon(resolve(__dirname, './public', 'favicon.ico')))

// 返回美化json
app.use(json())

// koa-logger
app.use(logger())

// 资源文件
app.use(require('koa-static')(resolve(__dirname, './public')))

// 模板引擎
app.use(views(resolve(__dirname, './views'), { map: { html: 'nunjucks' } }))

// sql特殊字符处理
const toEscapeString = val =&gt; {
  return mysql.escape(val)
}
const toEscapeObject = dat =&gt; {
  for (let key in dat) {
    typeof dat[key] === 'string' &amp;&amp; (dat[key] = toEscapeString(dat[key]))
    typeof dat[key] === 'object' &amp;&amp; toEscapeObject(dat[key])
  }
  return dat
}

// 加入cookie.get、set及自定义返回格式
app.use(async (ctx, next) =&gt; {
  ctx.cookie = {
    set: (k, v, opt) =&gt; {
      opt = Object.assign({}, conf.cookieOptions, opt)
      return ctx.cookies.set(k, v, opt)
    },
    get: (k, opt) =&gt; {
      opt = Object.assign({}, conf.cookieOptions, opt)
      return ctx.cookies.get(k, opt)
    }
  }

  let msg = {
    0: '失败',
    1: '验证码错误',
    200: '成功',
    400: '请求出错',
    401: '未授权的请求',
    403: '禁止：禁止执行访问',
    404: '找不到：请检查URL以确保路径正确',
    500: '服务器的内部错误',
    503: '服务不可用'
  }
  ctx.json = dat =&gt; {
    !dat.message &amp;&amp; (dat.message = msg[dat.code])
    return dat
  }

  // 自定义返回格式
  ctx.DATA = {
    data: {},
    message: '',
    code: 200
  }

  // 状态统一判断
  ctx.state = res =&gt; {
    return !(res &amp;&amp; res.length ? res[0] : res)
  }
  await next()
})

// swagger
app.use(
  koaSwagger({
    routePrefix: '/swagger', // host at /swagger instead of default /docs
    swaggerOptions: {
      url: '/api/swagger.json' // example path to json 其实就是之后swagger-jsdoc生成的文档地址
    }
  })
)
// 错误捕获
app.use((ctx, next) =&gt; {
  return next().catch(err =&gt; {
    console.log(err)
    let msg = err ? err.msg || err.toString() : 'unknown error'
    let code = err ? (err.code &gt;= 0 ? err.code : 500) : 500
    ctx.DATA.code = code
    ctx.DATA.message = msg
    ctx.body = ctx.DATA
    ctx.status =
      [200, 400, 401, 403, 404, 500, 503].indexOf(code) &gt;= 0 ? code : 200
  })
})
// routes
app.use(index.routes(), index.allowedMethods())

app.proxy = true

// koa error-handling 服务端、http错误
app.on('error', (err, ctx) =&gt; {
  console.error('server error', err, ctx)
})

module.exports = app
</code></pre>
<p>controller层的接口文件</p>
<pre><code>const resData = {
    os_type_data,
    ip_data,
    browser_data,
    channel_group_data,
    client_id_group_data,
    sortArrFormat,
    userActions
  }
  // 正常返回写法，一个个的定义很麻烦
  // const successData = {
  //   code: 0,
  //   data: resData,
  //   status: '请求成功'
  // }
  // ctx.body = successData
  
  // 直接把结果赋值，code码和message不用管
  ctx.DATA.data = resData
  ctx.body = ctx.json(ctx.DATA)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KOA中间件与执行顺序]]></title>
        <id>https://weidadeda.github.io/post/koa-zhong-jian-jian-yu-zhi-xing-shun-xu</id>
        <link href="https://weidadeda.github.io/post/koa-zhong-jian-jian-yu-zhi-xing-shun-xu">
        </link>
        <updated>2022-01-18T06:59:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.itying.com/koa/article-index-id-90.html">koa2中文文档</a></p>
<h3 id="一-什么是koa的中间件">一、什么是Koa的中间件</h3>
<p>通俗的讲：中间件就是匹配路由之前或者匹配路由完成做的一系列的操作，我们就可以把它叫做中间件。</p>
<p>在express中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处理请求-响应循环流程中的中间件，一般被命名为 next 的变量。在Koa中中间件和express有点类似。</p>
<p>中间件的功能包括：</p>
<p>执行任何代码。<br>
修改请求和响应对象。<br>
终结请求-响应循环。<br>
调用堆栈中的下一个中间件。</p>
<p>如果我的get、post回调函数中，没有next参数，那么就匹配上第一个路由，就不会往下匹配了。如果想往下匹配的话，那么需要写next()</p>
<h3 id="二-koa应用可使用如下几种中间件">二、Koa应用可使用如下几种中间件：</h3>
<p>应用级中间件<br>
路由级中间件<br>
错误处理中间件<br>
第三方中间件</p>
<h3 id="三-使用">三、使用</h3>
<ul>
<li>
<ol>
<li>async和await<br>
在koa中使用关键词 async 标记的函数是异步函数，<br>
在异步函数中使用 await next(); 处理下一个异步函数。</li>
</ol>
</li>
<li>
<ol start="2">
<li>app.use(async func())<br>
koa的使用方法很简单，将一系列要处理的操作封装到一个个异步函数中，然后用Koa的实例app通过 app.use(async func()) 的形式调用</li>
</ol>
</li>
</ul>
<p>一个koa应用程序如下：</p>
<pre><code>// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:
const Koa = require('koa');
const app = new Koa(); // 创建一个Koa对象表示web app本身:

// 对于任何请求，app将调用该异步函数处理请求：
app.use(async (ctx, next) =&gt; {
    await next();
    ctx.response.type = 'text/html';
    ctx.response.body = '&lt;h1&gt;Hello, koa2!&lt;/h1&gt;';
});

// 在端口3000监听:
app.listen(3000);
console.log('app started at port 3000...');
</code></pre>
<p>可以看到 app.use() 括号里面的参数是一个函数。函数用了异步修饰符 async ，在这个函数内部，又通过关键字 await next() 调用下一个app.use的异步函数。如果这个函数是最后一个需要执行的函数，则内部不需要再写await next（）。</p>
<h3 id="四-koa中间件的执行顺序">四、koa中间件的执行顺序</h3>
<p>Express的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应。<br>
Koa是从第一个中间件开始执行,遇到 await next() 就进入下一个中间件，一直到执行到最后一个中间件。然后再逆序执行上一个中间件 await next() 后面的代码，一直到第一个中间件 await next() 后面的代码执行完毕才发出响应。</p>
<p>koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>
<p>例子：</p>
<pre><code>app.use(async (ctx, next) =&gt; {
    console.log('1'); 
    await next(); // 调用下一个middleware
    console.log('5')
});

app.use(async (ctx, next) =&gt; {
    console.log('2');
    await next(); // 调用下一个middleware
    console.log('4');
});

app.use(async (ctx, next) =&gt; {
    console.log('3');
});
</code></pre>
<p>输出结果： 12345</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[node接口生成接口文档]]></title>
        <id>https://weidadeda.github.io/post/node-jie-kou-sheng-cheng-jie-kou-wen-dang</id>
        <link href="https://weidadeda.github.io/post/node-jie-kou-sheng-cheng-jie-kou-wen-dang">
        </link>
        <updated>2022-01-17T03:21:22.000Z</updated>
        <content type="html"><![CDATA[<p>先看下效果<br>
<img src="https://weidadeda.github.io/post-images/1642391805862.png" alt="" loading="lazy"><br>
这里我用的是koa2+swagger</p>
<h3 id="安装">安装</h3>
<pre><code>// koa2-swagger-ui UI视图组件  swagger-jsdoc 识别写的 /***/ 转 json
npm install koa2-swagger-ui swagger-jsdoc --save
</code></pre>
<p><a href="https://www.npmjs.com/package/koa2-swagger-ui">koa2-swagger-ui npm地址</a> （创建接口文档）<br>
<a href="https://www.npmjs.com/package/swagger-jsdoc">swagger-jsdoc npm地址</a> （这个库读取带有jsdoc注释的源代码，并生成OpenAPI (Swagger)规范。）<br>
<a href="https://www.jianshu.com/p/5365ef83252a">OpenAPI 规范摘要</a></p>
<h3 id="配置">配置</h3>
<p>router.js</p>
<pre><code>const router = require('koa-router')() //引入路由函数
const swaggerJSDoc = require('swagger-jsdoc')
const path = require('path')
const swaggerDefinition = {
  openapi: '3.0.1',
    info: {
        title: 'blog项目访问地址',
        version: '1.0.0',
        description: 'API',
    },
    basePath: '/', // Base path (optional)
    tags: [
      {
        name: 'manage',
        description: '管理系统'
      },
      {
        name: 'client',
        description: '日志上报'
      }
    ],
    schemes: ['http', 'https'],
    securityDefinitions: {
    server_auth: {
      type: 'oauth2',
      description: '登录账号密码鉴权',
      tokenUrl: '',
      flow: 'password',
      scopes: {
        token: 'modify pets in your account'
      }
    },
    token: {
      type: 'apiKey',
      name: 'token',
      in: 'header'
    }
  }
};
const options = {
    swaggerDefinition,
    apis: [path.join(__dirname, './controllers/*.js')], // 包含上述注释的文件（）
};
const swaggerSpec = swaggerJSDoc(options)
// 通过路由获取生成的注解文件
router.get('/swagger.json', async function (ctx) {
    ctx.set('Content-Type', 'application/json');
    ctx.body = swaggerSpec;
})
module.exports = router
</code></pre>
<p>app.js 入口文件</p>
<pre><code>const swagger = require('./router')  // router中做了swagger配置
const { koaSwagger } = require('koa2-swagger-ui')

// 接口文档配置
app.use(swagger.routes(), swagger.allowedMethods())
app.use(koaSwagger({
  routePrefix: '/swagger', // 接口文档访问地址
  swaggerOptions: {
    url: '/swagger.json', // example path to json 其实就是之后swagger-jsdoc生成的文档地址
  }
}))
</code></pre>
<p>启动项目，访问项目接口地址 + swagger ，我的地址是 http://localhost:4002/swagger</p>
<h3 id="注释生成文档">注释生成文档</h3>
<p>在controller层文件每个接口上写注释，注释是以@swagger开头的，swagger-jsdoc 会识别@swagger，然后解析下面的注释，解析完给koa2-swagger-ui显示成页面，总的流程就是这样。<br>
get方式</p>
<pre><code>// 获取博客列表
/**
 * @swagger
 * /api/blog/list:
 *   get:
 *     summary: 获取博客列表
 *     description: 获取博客列表
 *     tags:
 *       - blogs
 *     parameters:
 *       - name: author
 *         in: query
 *         required: false
 *         description: 作者
 *         type: string
 *       - name: keyword
 *         in: query
 *         required: false
 *         description: 搜索关键字
 *         type: string
 *     responses:
 *       200:
 *         description: 成功获取
 */
router.get('/list', async (ctx, next) =&gt; {
  const query = ctx.query
  let author = query.author || ''
  const keyword = query.keyword || ''

  const listData = await getList(author, keyword)
  ctx.body = new SuccessModel(listData)
})
</code></pre>
<p>post方式</p>
<pre><code>/**
 * @swagger
 * definitions:
 *  loginparam:
 *    properties:
 *      username:
 *        type: &quot;string&quot;
 *        default: &quot;shangsan&quot;
 *        description: 用户名
 *      password:
 *        type: &quot;string&quot;
 *        default: &quot;123&quot;
 *        description: 密码
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     ProjectDetail:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *           format: int64
 *         petId:
 *           type: integer
 *           format: int64
 *         quantity:
 *           type: integer
 *           format: int32
 *         shipDate:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /api/user/login:
 *   post:
 *     summary: 登录
 *     description: 登录
 *     tags:
 *       - user
 *     consumes:
 *      - application/json
 *      - application/xml
 *     produces:
 *      - application/json
 *      - application/xml
 *     parameters:
 *       - name: body
 *         in: body
 *         schema:
 *          $ref: '#/definitions/loginparam' （请求参数这里单独抽出，在上面定义）
 *     responses:
 *       200:
 *         description: 发布成功
 *          content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ProjectDetail'（返回参数也是单独抽出定义，这里是随便举个例子）
 *       402:
 *          description: 信息填写不全
 *       403:
 *          description: 参数类型错误
 */

router.post('/login', async (ctx, next) =&gt; {
    // 业务逻辑
})
</code></pre>
<p>返回示例<br>
<img src="https://weidadeda.github.io/post-images/1642412213197.png" alt="" loading="lazy"><br>
基本的接口文档就生成啦，快试一下吧～</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sequelize node连接数据库的ORM]]></title>
        <id>https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm</id>
        <link href="https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm">
        </link>
        <updated>2022-01-14T07:36:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.sequelize.com.cn/">Sequelize 中文文档</a><br>
可以先看文档，文档很全，它的语句帮我们做了很多处理，而且很精简，让我们不用死记硬背sql语句，也不用去库里建表。</p>
<h3 id="连接数据库">连接数据库</h3>
<pre><code>连接到数据库
要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将连接参数分别传递到 Sequelize 构造函数或通过传递一个连接 URI 来完成：

const { Sequelize } = require('sequelize');

// 方法 1: 传递一个连接 URI
const sequelize = new Sequelize('sqlite::memory:') // Sqlite 示例
const sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname') // Postgres 示例

// 方法 2: 分别传递参数 (sqlite)
const sequelize = new Sequelize({
  dialect: 'sqlite',
  storage: 'path/to/database.sqlite'
});

// 方法 3: 分别传递参数 (其它数据库)
const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: /* 选择 'mysql' | 'mariadb' | 'postgres' | 'mssql' 其一 */
});
</code></pre>
<h3 id="定义模型-定义表结构">定义模型 （定义表结构）</h3>
<pre><code>module.exports = function(sequelize, DataTypes) {
  return sequelize.define(
    'project',
    {
      id: {
        type: DataTypes.INTEGER(11),
        allowNull: false,
        primaryKey: true,
        autoIncrement: true
      },
      name: { type: DataTypes.STRING(255), allowNull: true },
      title: { type: DataTypes.STRING(255), allowNull: true },
      report_fix_id: { type: DataTypes.STRING(1000), allowNull: true },
      fix_url: { type: DataTypes.STRING(2000), allowNull: true },
      ignore_key: {
        type: DataTypes.STRING(2000),
        allowNull: true,
        comment: '简化打印对象中比较大的对象'
      },
      env: {
        type: DataTypes.STRING(255),
        allowNull: true,
        comment: '哪些环境能上报日志'
      },
      report_interval: {
        type: DataTypes.INTEGER(11),
        allowNull: true,
        comment: '上报时间间隔'
      },
      ctime: {
        type: DataTypes.INTEGER(10),
        allowNull: true,
        get() {
          return moment
            .unix(this.getDataValue('ctime'))
            .format('YYYY/MM/DD HH:mm:ss')
        }
      },
      del: { type: DataTypes.INTEGER(1), allowNull: true, defaultValue: '0' }
    },
    {
      tableName: 'project'
    }
  )
}
</code></pre>
<h3 id="模型同步-真正从数据库创建">模型同步 （真正从数据库创建）</h3>
<p>定义模型时,你要告诉 Sequelize 有关数据库中表的一些信息. 但是,如果该表实际上不存在于数据库中怎么办？ 如果存在,但具有不同的列,较少的列或任何其他差异,该怎么办？</p>
<p>这就是模型同步的来源.可以通过调用一个异步函数(返回一个Promise)model.sync(options). 通过此调用,Sequelize 将自动对数据库执行 SQL 查询. 请注意,这仅更改数据库中的表,而不更改 JavaScript 端的模型.</p>
<p>User.sync() - 如果表不存在,则创建该表(如果已经存在,则不执行任何操作)</p>
<h4 id="usersync-force-true-将创建表如果表已经存在则将其首先删除-这个不要用也最好别试">User.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除 （这个不要用，也最好别试）</h4>
<p>User.sync({ alter: true }) - 这将检查数据库中表的当前状态(它具有哪些列,它们的数据类型等),然后在表中进行必要的更改以使其与模型匹配.</p>
<pre><code>sequelize
  .authenticate()
  .then(() =&gt; {
    console.log('数据库连接成功'.green)
    // sequelize.sync({ alter: true })
  })
  .catch(err =&gt; {
    console.log('数据库连接失败'.red)
  })
</code></pre>
<h3 id="创建实例修改内容insert">创建实例（修改内容INSERT）</h3>
<p>尽管模型是一个类,但是你不应直接使用 new 运算符来创建实例. 相反,应该使用 build 方法：</p>
<pre><code>const jane = User.build({ name: &quot;Jane&quot; });
console.log(jane instanceof User); // true
console.log(jane.name); // &quot;Jane&quot;
</code></pre>
<p>但是,以上代码根本无法与数据库通信(请注意,它甚至不是异步的)！ 这是因为 build 方法仅创建一个对象,该对象 表示 可以 映射到数据库的数据. 为了将这个实例真正保存(即持久保存)在数据库中,应使用 save 方法：</p>
<pre><code>await jane.save();
console.log('Jane 已保存到数据库!');
</code></pre>
<p>请注意,从上面代码段中的 await 用法来看,save 是一种异步方法. 实际上,几乎每个 Sequelize 方法都是异步的. build 是极少数例外之一.</p>
<p>非常有用的捷径: create 方法<br>
Sequelize提供了 create 方法,该方法将上述的 build 方法和 save 方法合并为一个方法：</p>
<pre><code>const jane = await User.create({ name: &quot;Jane&quot; });
// Jane 现在存在于数据库中！
console.log(jane instanceof User); // true
console.log(jane.name); // &quot;Jane&quot;
</code></pre>
<h3 id="简单-select-查询">简单 SELECT 查询</h3>
<p>你可以使用 findAll 方法从数据库中读取整个表：</p>
<pre><code>// 查询所有用户
const users = await User.findAll();
console.log(users.every(user =&gt; user instanceof User)); // true
console.log(&quot;All users:&quot;, JSON.stringify(users, null, 2));
</code></pre>
<p>相当于sql语句</p>
<pre><code>SELECT * FROM ...
</code></pre>
<p>嗯，写一些建表与查询的流程，照着官网抄也没什么意思。使用这个我们可以很轻松的操作数据库，使我们写node接口的时候效率翻倍～</p>
]]></content>
    </entry>
</feed>