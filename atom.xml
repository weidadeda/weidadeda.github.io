<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://weidadeda.github.io</id>
    <title>Gridea</title>
    <updated>2022-02-07T08:19:26.823Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://weidadeda.github.io"/>
    <link rel="self" href="https://weidadeda.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://weidadeda.github.io/images/avatar.png</logo>
    <icon>https://weidadeda.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[用yeoman开发一个自己的项目脚手架]]></title>
        <id>https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia</id>
        <link href="https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia">
        </link>
        <updated>2022-02-07T07:37:02.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://weidadeda.github.io/post-images/1644219568486.gif" alt="" loading="lazy"><br>
上面是一个使用脚手架来初始化项目的典型例子。<br>
随着前端工程化的理念不断深入，越来越多的人选择使用脚手架来从零到一搭建自己的项目。其中大家最熟悉的就是create-react-app和vue-cli，它们可以帮助我们初始化配置、生成项目结构、自动安装依赖，最后我们一行指令即可运行项目开始开发，或者进行项目构建（build）。<br>
这些脚手架提供的都是普遍意义上的最佳实践，但是我在开发中发现，随着业务的不断发展，必然会出现需要针对业务开发的实际情况来进行调整。例如：</p>
<ol>
<li>
<p>项目架构的配置<br>
a. webpack/gulp的配置<br>
ⅰ. style/less/sass的选择和处理配置。<br>
ⅱ. Typescript和JavaScript的loader和babel的配置，比如babel-loader和tsc。<br>
ⅲ. 图片的配置，比如需要file-loader或者url-loader。<br>
ⅳ. 静态资源的配置。<br>
ⅴ. 企业内部，真对于某些特定功能的webpack-loader/webpack-plugin，比如打包完图片上传。<br>
b. 是否内置一些第三方框架供上手使用，比如Element-UI，Antd等。<br>
c. 项目的路由的设计和配置。<br>
d. 项目目录结构的设计和配置。<br>
e. 项目通用功能的有关代码，比如登陆和欢迎页等。<br>
f.通过调整插件与配置实现 Webpack 打包性能优化<br>
g.针对生产环境做的单独处理</p>
</li>
<li>
<p>项目开发中的配置<br>
a. eslint。<br>
b. style-lint。<br>
c. prettier。<br>
d. 单元测试jest或者其他单元测试框架。<br>
e. 项目文档的自动生成，比如docz。<br>
f. git相关的，比如git提交的校验，生成changelog<br>
g. npm相关，除非是开发npm包，否则npm相关的不是那么重要<br>
h. 与开发有关的工具，比如打包构建结果的包分析、比如相似代码自动生成</p>
</li>
<li>
<p>项目上线脚本，这个应该是可选项？更优的方法应该是使用内部的例如发布平台之类的工具完成，或者通过jekins或者gitlab-ci进行自动化发布，回滚等操作。上线发布回滚的动作可以完全交给非开发人员完成。<br>
a. 比如由nodejs编写的上线脚本，或者是用于上线的shell脚本。<br>
b. gitlab-ci的配置文件</p>
</li>
</ol>
<p>……<br>
总而言之，随着业务发展，我们往往会沉淀出一套更“个性化”的业务方案。这时候我们最直接的做法就是开发出一个该方案的脚手架来，以便今后能复用这些最佳实践与方案。<br>
那么就需要使用一个工具来帮我们做这些处理，我们使用的就是yoman。<a href="https://yeoman.io/">官网地址</a><br>
我们可以使用yeoman和yeoman的generator来更加便捷实现我们的脚手架，可以说基本是零成本。<br>
先说说Yeoman是什么，它想做什么？<br>
Yeamon帮助你快速的开展一个项目工程，提供最佳实践和工具，来让你保持高效率编码。</p>
<p>他们自己提供了一个构建生态系统，主要通过‘yo’这个命令来构建一个完整的项目或者项目的一部分。</p>
<p>通过官方的生成器，他们建立了一个Yeoman的工作流，这个流是由一个强大的,固定的客户端组建，包含工具和框架帮助开发者快速建立牛逼的web应用。他们尽量提供了开发者所需的东西。比如先下载对应模版项目，然后下载模版项目中的package.json中的包</p>
<p>作为良好文档和深入思考构建过程的思想者，Yeoman包含了检测（静态检测）、测试以及压缩等等一系列工具，让开发者能够更加专注于思考解决方案。</p>
<h3 id="如何使用">如何使用：</h3>
<p>1、npm install -g yo //权限不够，请加上 sudo，一般来说mac都需要。<br>
安装完成之后，你就拥有了1个命令 -- yo 可以选择自定义的，也可以搜索你想要的现成的，这里我们选择自己的。 官网提供的地址：http://yeoman.io/generators/<br>
那我们开始编写一个自己的generators。<br>
2、开发自己的generator<br>
创建项目<br>
全局安装generator-generator，然后使用创建项目，根据提示输出我们的generator项目的名字，yeoman规定项目名字必须以generator开头，所以我们可以选择generator-xxx作为我们的项目名<br>
npm i -g generator-generator<br>
yo generator<br>
创建好项目之后，我们可以发现已经自动为我们配置好了eslint，jest，husky</p>
<p>我们主要需要修改的代码位于generators/app内<br>
● index.js定义了我们使用此generator时的一些操作配置项<br>
● templates内存放的是要生成的项目的项目模板，项目模板也可以放在git上，然后通过download-git-repo下载到本地<br>
验证我们创建的项目</p>
<ol>
<li>在当前项目执行npm link使其被链接到全局</li>
<li>然后找一个目录，终端执行yo，此时便可以发现我们的generator已经出现在了选择列表中。然后选择我们的generator运行即可。等待完成，会发现成功的创建了一个叫做dummyfile.txt的文件夹。<br>
generators/app/index.js<br>
初始化的文件如下。</li>
</ol>
<pre><code>&quot;use strict&quot;;
const Generator = require(&quot;yeoman-generator&quot;);
const chalk = require(&quot;chalk&quot;);
const yosay = require(&quot;yosay&quot;);

module.exports = class extends Generator {
  prompting() {
    // Have Yeoman greet the user.
    this.log(
      yosay(
        `Welcome to the fantastic ${chalk.red(&quot;generator-rc-op&quot;)} generator!`
      )
    );

    const prompts = [
      {
        type: &quot;confirm&quot;,
        name: &quot;someAnswer&quot;,
        message: &quot;Would you like to enable this option?&quot;,
        default: true
      }
    ];

    return this.prompt(prompts).then(props =&gt; {
      // To access props later use this.props.someAnswer;
      this.props = props;
    });
  }

  writing() {
    this.fs.copy(
      this.templatePath(&quot;dummyfile.txt&quot;),
      this.destinationPath(&quot;dummyfile.txt&quot;)
    );
  }

  install() {
    this.installDependencies();
  }
};
</code></pre>
<p>从文件的内容可以看出主要操作是暴露出一个继承自Generator的类，在类的内部定义了部分生命周期方法，供yoeman在适当的时候调用。我们只需要完善这些方法就可以了。</p>
<h3 id="yeoman提供的生命周期如下">yeoman提供的生命周期如下：</h3>
<ol>
<li>initializing：初始化必要的依赖，或者比如检测新版本</li>
<li>prompting：用来处理终端的交互</li>
<li>default：这里指的是自己自定义的方法，而不是名为default的方法，自己定义的方法如果不想被调用，那么需要确保方法名以_为开头。</li>
<li>writing：将经过ejs模板渲染后的内容写入文件系统。</li>
<li>conflicts：勇于解决将文件内容写入文件系统时可能造成的冲突</li>
<li>install：安装项目的依赖，比如npm install 或者 bower install</li>
<li>end：做一些收尾的工作。</li>
</ol>
<p>这些生命周期方法均支持返回Promise来进行异步操作。</p>
<h3 id="内置常用工具">内置常用工具</h3>
<p>终端交互：内置了Inquirer提供终端交互<br>
模板填充：内置了ejs模板<br>
文件操作<br>
● this.fs.copyTpl：用于拷贝并且根据数据使用ejs模板渲染文件。此函数接受三个参数，源文件路径，目标文件路径，传给ejs用于渲染目标问价的数据。<br>
● this.fs.copy：将文件丛源路径复制到目标路径。<br>
● this.destinationPath() ：此函数返回最终生成项目的路径<br>
其他<br>
● this.npmInstall：实现npm isntall</p>
<pre><code>// 部分代码，完整代码见最下方链接
writing() {
    const done = this.async();
    this.log(&quot;⚙  Finish basic configuration.&quot;, chalk.green(&quot;✔&quot;));
    this.log(&quot;📂 Generate the project template and configuration...&quot;);
    let spinner = ora({
      text: `Download the template from ${GIT_BASE}${TPL_REPOSITORY}...`,
      spinner: ORA_SPINNER
    }).start();
    this._downloadTemplate(TPL_REPOSITORY)
      .then(() =&gt; {
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish downloading the template from ${GIT_BASE}${TPL_REPOSITORY}`
        });
        spinner = ora({
          text: `Copy files into the project folder...`,
          spinner: ORA_SPINNER
        }).start();
        const templateRoot = this.destinationPath(this.dirName, &quot;.tmp&quot;);
        this.log(`\n${templateRoot}`, &quot;templateRoot&quot;);
        const resoPath = path.resolve(templateRoot, &quot;../&quot;);
        this.log(resoPath, &quot;resoPath&quot;);
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish copying files into the project folder`
        });
        execSync(`cp -R ${resoPath}/.tmp/* ${resoPath}`, { stdio: &quot;inherit&quot; });
        spinner = ora({
          text: `Clean tmp files and folders...`,
          spinner: ORA_SPINNER
        }).start();
        fs.removeSync(templateRoot);
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish cleaning tmp files and folders`
        });
        // ExecSync(`rm -R ${resoPath}/.tmp`, { stdio: &quot;inherit&quot; });
        // 将新生成的项目的title换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/public/index.html`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/public/index.html`, str);
          }
        );
        // 将新生成的项目的package.json的name换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/package.json`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/package.json`, str);
          }
        );
        done();
      })
      .catch(err =&gt; this.env.error(err));
  }
</code></pre>
<h3 id="其他可能用到的工具">其他可能用到的工具</h3>
<p>● ora：用于创建Spinner，即比如下载模板文件时需要展示的laoding效果。<br>
● chalk：用于打印彩色的信息<br>
● update-notifier<br>
● beeper<br>
● boxen<br>
调试<br>
由于yeoman是通过npm包的形式进行使用的，所以我们可以在我们开发的generator项目的跟目录下，执行npm link 将我们开发的generator链接到全局，这样我们直接使用yo命令查看可以使用的generator，就可以看到我们所开发的generator了，并且是实时生效的</p>
<h3 id="我的代码是在本地的用的npm-link没有上传到github或npm此处贴出其他大佬的项目代码-快动手试一下吧~">我的代码是在本地的，用的npm link，没有上传到github或npm，此处贴出其他大佬的项目代码。快动手试一下吧～</h3>
<p><a href="https://github.com/alienzhou/webpack-kickoff-template">模版完整代码</a>   注意要给ejs写入的空位<br>
<a href="https://github.com/alienzhou/generator-webpack-kickoff">脚手架完整代码</a></p>
<h3 id="参考文章">参考文章：</h3>
<p><a href="https://www.yuque.com/kongdepeng/rgpm60/qrluup">前端自动化工具 - yeoman</a><br>
<a href="https://zhuanlan.zhihu.com/p/66190308">如何快速开发一个自己的项目脚手架？</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用Object.create浅拷贝一个对象]]></title>
        <id>https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang</id>
        <link href="https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang">
        </link>
        <updated>2022-01-21T02:41:42.000Z</updated>
        <content type="html"><![CDATA[<p>// 首先得介绍一下深拷贝和浅拷贝（虽然大家都知道，但毕竟写文章，还是得照顾下不知道的同学）<br>
// 其次问下大家object.assign属于浅拷贝还是深拷贝<br>
// Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型<br>
// Object.getOwnPropertyDescriptors方法配合 Object.create() 方法可以实现浅拷贝。<br>
// <code>// Object.create( // Object.getPrototypeOf(obj), // Object.getOwnPropertyDescriptors(obj) // ); //</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义一个new方法]]></title>
        <id>https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa</id>
        <link href="https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa">
        </link>
        <updated>2022-01-20T06:36:51.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">MDN new</a></p>
<h3 id="一-new的介绍">一、new的介绍</h3>
<p>new是干什么的：</p>
<blockquote>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
</blockquote>
<p>使用new可以少做四件事情：</p>
<p>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；<br>
不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；<br>
不用 return 临时对象，因为 new 会帮你做；<br>
不要给原型想名字了，因为 new 指定名字为 prototype。</p>
<p>new 关键字会进行如下的操作：</p>
<p>创建一个空的简单JavaScript对象（即{}）；<br>
为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；<br>
将步骤1新创建的对象作为this的上下文 ；<br>
如果该函数没有返回对象，则返回this。<br>
（译注：关于对象的 constructor，参见 Object.prototype.constructor）</p>
<p>创建一个用户自定义的对象需要两步：</p>
<p>通过编写函数来定义对象类型。<br>
通过 new 来创建对象实例。<br>
创建一个对象类型，需要创建一个指定其名称和属性的函数；对象的属性可以指向其他对象，看下面的例子：</p>
<p>当代码 new Foo(...) 执行时，会发生以下事情：</p>
<p>一个继承自 Foo.prototype 的新对象被创建。<br>
使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。<br>
由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）<br>
你始终可以对已定义的对象添加新的属性。例如，car1.color = &quot;black&quot; 语句给 car1 添加了一个新的属性 color，并给这个属性赋值 &quot;black&quot;。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，你必须将该属性添加到 Car 对象类型的定义中。</p>
<p>你可以使用 Function.prototype 属性将共享属性添加到以前定义的对象类型。这定义了一个由该函数创建的所有对象共享的属性，而不仅仅是对象类型的其中一个实例。下面的代码将一个值为 null 的 color 属性添加到 car 类型的所有对象，然后仅在实例对象 car1 中用字符串 &quot;black&quot; 覆盖该值</p>
<pre><code>function Car() {}
car1 = new Car();
car2 = new Car();

console.log(car1.color);    // undefined

Car.prototype.color = &quot;original color&quot;;
console.log(car1.color);    // original color

car1.color = 'black';
console.log(car1.color);   // black

console.log(car1.__proto__.color) //original color
console.log(car2.__proto__.color) //original color
console.log(car1.color)  // black
console.log(car2.color) // original color
</code></pre>
<blockquote>
<p>如果你没有使用 new 运算符， 构造函数会像其他的常规函数一样被调用， 并不会创建一个对象。在这种情况下， this 的指向也是不一样的。</p>
</blockquote>
<h3 id="二-自定义一个new">二、自定义一个new</h3>
<pre><code>  // 构造器函数
  let Parent = function (name, age) {
    this.name = name;
    this.age = age;
  };
  Parent.prototype.sayName = function () {
    console.log(this.name);
  };
  //自己定义的new方法
  let newMethod = function (Parent, ...rest) {
    // 1.以构造器的prototype属性为原型，创建新对象；
    let child = Object.create(Parent.prototype);
    // 2.将this和调用参数传给构造器执行
    Parent.apply(child, rest);
    // 3.返回第一步的对象
    return child;
  };
  //创建实例，将构造函数Parent与形参作为参数传入
  const child = newMethod(Parent, 'echo', 26);
  child.sayName() //'echo';

  //最后检验，与使用new的效果相同
  child instanceof Parent//true
  child.hasOwnProperty('name')//true
  child.hasOwnProperty('age')//true
  child.hasOwnProperty('sayName')//false
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js 常用工具 （util.inherits）]]></title>
        <id>https://weidadeda.github.io/post/nodejs-chang-yong-gong-ju-utilinherits</id>
        <link href="https://weidadeda.github.io/post/nodejs-chang-yong-gong-ju-utilinherits">
        </link>
        <updated>2022-01-19T03:27:23.000Z</updated>
        <content type="html"><![CDATA[<p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。</p>
<p>util.inherits<br>
util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。</p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<p>在这里我们只介绍util.inherits 的用法，示例如下：</p>
<pre><code>var util = require('util'); 
function Base() { 
    this.name = 'base'; 
    this.base = 1991; 
    this.sayHello = function() { 
    console.log('Hello ' + this.name); 
    }; 
} 
Base.prototype.showName = function() { 
    console.log(this.name);
}; 
function Sub() { 
    this.name = 'sub'; 
} 
util.inherits(Sub, Base); 
var objBase = new Base(); 
objBase.showName(); 
objBase.sayHello(); 
console.log(objBase); 
var objSub = new Sub(); 
objSub.showName(); 
//objSub.sayHello(); 
console.log(objSub);
</code></pre>
<p>我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：</p>
<pre><code>base 
Hello base 
{ name: 'base', base: 1991, sayHello: [Function] } 
sub 
{ name: 'sub' }
</code></pre>
<p>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。</p>
<p>同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：</p>
<pre><code>node.js:201 
throw e; // process.nextTick error, or 'error' event on first tick 
^ 
TypeError: Object #&lt;Sub&gt; has no method 'sayHello' 
at Object.&lt;anonymous&gt; (/home/byvoid/utilinherits.js:29:8) 
at Module._compile (module.js:441:26) 
at Object..js (module.js:459:10) 
at Module.load (module.js:348:31) 
at Function._load (module.js:308:12) 
at Array.0 (module.js:479:10) 
at EventEmitter._tickCallback (node.js:192:40)
</code></pre>
<p>转载自https://www.cnblogs.com/yuwenjing0727/p/8135608.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Koa接口参数校验与返回值统一处理]]></title>
        <id>https://weidadeda.github.io/post/koa-jie-kou-can-shu-xiao-yan-yu-fan-hui-zhi-tong-yi-chu-li</id>
        <link href="https://weidadeda.github.io/post/koa-jie-kou-can-shu-xiao-yan-yu-fan-hui-zhi-tong-yi-chu-li">
        </link>
        <updated>2022-01-18T11:03:04.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/node-modules/parameter">parameter地址</a><br>
// Koa接口参数校验与返回值统一处理  将参数校验变成一个路由中间件，正确的话继续执行，错误的话抛出错误异常。<br>
// 在第一个中间件中自定义返回格式这里叫ctx.DATA（ctx上自定义一个对象，对象包含code默认200,msg默认‘成功’,data默认空对象）<br>
// 这里对错误异常做了处理，抛出的是带code码以及与code码对应的msg和错误原因data的对象，此时我们将错误信息赋值给ctx.DATA.data。app中先写一个捕获错误的中间件，这样抛出的错误我们能够捕获到，然后从这里我们给body赋值，这样错误时返回的就是code码和message都有的返回值<br>
// 当成功查找到数据库中的数据时，我们只需要将数据给ctx.DATA.data，那么返回值就是code码为200，msg为成功，data为正确数据的对象了。万一出现了登陆失败，我们也可以改变ctx.DATA.message为登陆失败，改变code码等</p>
<pre><code>/**
 * 数据校验
 * wiki：https://github.com/node-modules/parameter/blob/master/example.js
 * @type {Parameter}
 */
// const { HttpError } = require('../../utils/tool/error')
const util = require('util')
// const ERROR_MSG = require('./errorMsg')
const ERROR_MSG = Object.freeze({
  // en
  // 0: 'fail',
  // 1: 'validation error',
  // 200: 'ok',
  // 400: 'invalid param',
  // 401: 'unauthorized',
  // 403: 'forbidden',
  // 404: 'not found',
  // 500: 'internal server error',
  // 503: 'service busy',

  // zh-cn
  0: '失败',
  1: '验证码错误',
  200: '成功',
  400: '请求出错',
  401: '未授权的请求',
  403: '禁止：禁止执行访问',
  404: '找不到：请检查URL以确保路径正确',
  500: '服务器的内部错误',
  503: '服务不可用'
})

function CustomError(code, msg) {
  Error.call(this, '')

  this.code = code
  this.msg = msg || ERROR_MSG[code] || 'unknown error'

  this.getCodeMsg = function() {
    return {
      code: this.code,
      msg: this.msg
    }
  }
}

util.inherits(CustomError, Error)

function HttpError(code, msg) {
  if ([0, 1, 200, 400, 401, 403, 404, 500, 503].indexOf(code) &lt; 0) {
    throw Error('not an invalid http code')
  }

  CustomError.call(this, code, msg)
}

util.inherits(HttpError, CustomError)

const Parameter = require('parameter')
const parm = new Parameter()

// 自定义校验
parm.addRule('name', function(e, v) {
  let sta = /^[a-z]$/.test(v)
  return sta || '只能输入一个字母'
})

// 路由校验列表
const ruleList = {
  // 登录
  'post/api/login': {
    mobile: { type: 'string', required: true },
    password: { type: 'string', required: true }
  },
  // 获取配置
  'get/api/setting': {
    id: { type: 'string', required: true }
  },
  // 保存配置
  'post/api/setting': {
    id: { type: 'number', required: true },
    title: { type: 'string', required: false },
    report_fix_id: { type: 'string', required: false },
    fix_url: { type: 'string', required: false },
    env: { type: 'string', required: false },
    report: { type: 'number', required: false },
    report_interval: { type: 'number', required: false }
  },
  // CICD
  'post/api/deploy': {
    name: { type: 'string', required: true },
    branch: { type: 'string', required: false },
    env: { type: 'string', required: false }
  },
  // 用户详情
  'get/api/user-details': {
    user_id: { type: 'string', required: true }
  }
}

/**
 * 校验方法
 * @param ctx
 * @param next
 * @returns {Promise&lt;void&gt;}
 */
const parameter = async (ctx, next) =&gt; {
  let errors, data
  let method = 'get'
  if (ctx.request.method === 'GET') {
    data = ctx.query
  } else {
    method = 'post'
    data = ctx.request.body
  }
  console.log(method, data)
  try {
    let name = ctx.req._parsedUrl.pathname
    errors = parm.validate(ruleList[method + name], data)
  } catch (e) {
    throw new HttpError(0, e.toString())
  }
  if (errors &amp;&amp; errors.length) {
    ctx.DATA.data = errors
    throw new HttpError(0, '数据校验未通过')
  }
  await next()
}
module.exports = parameter
</code></pre>
<p>router.js</p>
<pre><code>// 数据校验
const router = require('koa-router')()
const parameter = require('../utils/parameter')
// project
router.get('/api/user-details', parameter, userDetail)
router.get('/api/setting', parameter, getSetting)
router.post('/api/setting', parameter, setSetting)
// common
router.post('/api/login', parameter, login)
// devops
router.post('/api/deploy', parameter, checkToken, deploy)
// swagger
router.get('/api/swagger.json', async function (ctx) {
  ctx.set('Content-Type', 'application/json')
  ctx.body = openapiSpecification
})
// index
router.get('/', index)

module.exports = router
</code></pre>
<p>app.js</p>
<pre><code>const Koa = require('koa')
const app = new Koa()
const views = require('koa-views')
const json = require('koa-json')
const favicon = require('koa-favicon')
const koaBody = require('koa-body')
const logger = require('koa-logger')
const colors = require('colors')
const { resolve } = require('path')
const { koaSwagger } = require('koa2-swagger-ui')
const mysql = require('mysql2')

const conf = require('./config')
const index = require('./routes')

// 允许上传文件
app.use(
  koaBody({
    multipart: true,
    formidable: {
      maxFileSize: 1000 * 1024 * 1024 // 设置上传文件大小最大限制
    }
  })
)

// 网站图标
app.use(favicon(resolve(__dirname, './public', 'favicon.ico')))

// 返回美化json
app.use(json())

// koa-logger
app.use(logger())

// 资源文件
app.use(require('koa-static')(resolve(__dirname, './public')))

// 模板引擎
app.use(views(resolve(__dirname, './views'), { map: { html: 'nunjucks' } }))

// sql特殊字符处理
const toEscapeString = val =&gt; {
  return mysql.escape(val)
}
const toEscapeObject = dat =&gt; {
  for (let key in dat) {
    typeof dat[key] === 'string' &amp;&amp; (dat[key] = toEscapeString(dat[key]))
    typeof dat[key] === 'object' &amp;&amp; toEscapeObject(dat[key])
  }
  return dat
}

// 加入cookie.get、set及自定义返回格式
app.use(async (ctx, next) =&gt; {
  ctx.cookie = {
    set: (k, v, opt) =&gt; {
      opt = Object.assign({}, conf.cookieOptions, opt)
      return ctx.cookies.set(k, v, opt)
    },
    get: (k, opt) =&gt; {
      opt = Object.assign({}, conf.cookieOptions, opt)
      return ctx.cookies.get(k, opt)
    }
  }

  let msg = {
    0: '失败',
    1: '验证码错误',
    200: '成功',
    400: '请求出错',
    401: '未授权的请求',
    403: '禁止：禁止执行访问',
    404: '找不到：请检查URL以确保路径正确',
    500: '服务器的内部错误',
    503: '服务不可用'
  }
  ctx.json = dat =&gt; {
    !dat.message &amp;&amp; (dat.message = msg[dat.code])
    return dat
  }

  // 自定义返回格式
  ctx.DATA = {
    data: {},
    message: '',
    code: 200
  }

  // 状态统一判断
  ctx.state = res =&gt; {
    return !(res &amp;&amp; res.length ? res[0] : res)
  }
  await next()
})

// swagger
app.use(
  koaSwagger({
    routePrefix: '/swagger', // host at /swagger instead of default /docs
    swaggerOptions: {
      url: '/api/swagger.json' // example path to json 其实就是之后swagger-jsdoc生成的文档地址
    }
  })
)
// 错误捕获
app.use((ctx, next) =&gt; {
  return next().catch(err =&gt; {
    console.log(err)
    let msg = err ? err.msg || err.toString() : 'unknown error'
    let code = err ? (err.code &gt;= 0 ? err.code : 500) : 500
    ctx.DATA.code = code
    ctx.DATA.message = msg
    ctx.body = ctx.DATA
    ctx.status =
      [200, 400, 401, 403, 404, 500, 503].indexOf(code) &gt;= 0 ? code : 200
  })
})
// routes
app.use(index.routes(), index.allowedMethods())

app.proxy = true

// koa error-handling 服务端、http错误
app.on('error', (err, ctx) =&gt; {
  console.error('server error', err, ctx)
})

module.exports = app
</code></pre>
<p>controller层的接口文件</p>
<pre><code>const resData = {
    os_type_data,
    ip_data,
    browser_data,
    channel_group_data,
    client_id_group_data,
    sortArrFormat,
    userActions
  }
  // 正常返回写法，一个个的定义很麻烦
  // const successData = {
  //   code: 0,
  //   data: resData,
  //   status: '请求成功'
  // }
  // ctx.body = successData
  
  // 直接把结果赋值，code码和message不用管
  ctx.DATA.data = resData
  ctx.body = ctx.json(ctx.DATA)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KOA中间件与执行顺序]]></title>
        <id>https://weidadeda.github.io/post/koa-zhong-jian-jian-yu-zhi-xing-shun-xu</id>
        <link href="https://weidadeda.github.io/post/koa-zhong-jian-jian-yu-zhi-xing-shun-xu">
        </link>
        <updated>2022-01-18T06:59:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.itying.com/koa/article-index-id-90.html">koa2中文文档</a></p>
<h3 id="一-什么是koa的中间件">一、什么是Koa的中间件</h3>
<p>通俗的讲：中间件就是匹配路由之前或者匹配路由完成做的一系列的操作，我们就可以把它叫做中间件。</p>
<p>在express中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处理请求-响应循环流程中的中间件，一般被命名为 next 的变量。在Koa中中间件和express有点类似。</p>
<p>中间件的功能包括：</p>
<p>执行任何代码。<br>
修改请求和响应对象。<br>
终结请求-响应循环。<br>
调用堆栈中的下一个中间件。</p>
<p>如果我的get、post回调函数中，没有next参数，那么就匹配上第一个路由，就不会往下匹配了。如果想往下匹配的话，那么需要写next()</p>
<h3 id="二-koa应用可使用如下几种中间件">二、Koa应用可使用如下几种中间件：</h3>
<p>应用级中间件<br>
路由级中间件<br>
错误处理中间件<br>
第三方中间件</p>
<h3 id="三-使用">三、使用</h3>
<ul>
<li>
<ol>
<li>async和await<br>
在koa中使用关键词 async 标记的函数是异步函数，<br>
在异步函数中使用 await next(); 处理下一个异步函数。</li>
</ol>
</li>
<li>
<ol start="2">
<li>app.use(async func())<br>
koa的使用方法很简单，将一系列要处理的操作封装到一个个异步函数中，然后用Koa的实例app通过 app.use(async func()) 的形式调用</li>
</ol>
</li>
</ul>
<p>一个koa应用程序如下：</p>
<pre><code>// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:
const Koa = require('koa');
const app = new Koa(); // 创建一个Koa对象表示web app本身:

// 对于任何请求，app将调用该异步函数处理请求：
app.use(async (ctx, next) =&gt; {
    await next();
    ctx.response.type = 'text/html';
    ctx.response.body = '&lt;h1&gt;Hello, koa2!&lt;/h1&gt;';
});

// 在端口3000监听:
app.listen(3000);
console.log('app started at port 3000...');
</code></pre>
<p>可以看到 app.use() 括号里面的参数是一个函数。函数用了异步修饰符 async ，在这个函数内部，又通过关键字 await next() 调用下一个app.use的异步函数。如果这个函数是最后一个需要执行的函数，则内部不需要再写await next（）。</p>
<h3 id="四-koa中间件的执行顺序">四、koa中间件的执行顺序</h3>
<p>Express的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应。<br>
Koa是从第一个中间件开始执行,遇到 await next() 就进入下一个中间件，一直到执行到最后一个中间件。然后再逆序执行上一个中间件 await next() 后面的代码，一直到第一个中间件 await next() 后面的代码执行完毕才发出响应。</p>
<p>koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware，这些middleware可以组合起来，完成很多有用的功能。</p>
<p>例子：</p>
<pre><code>app.use(async (ctx, next) =&gt; {
    console.log('1'); 
    await next(); // 调用下一个middleware
    console.log('5')
});

app.use(async (ctx, next) =&gt; {
    console.log('2');
    await next(); // 调用下一个middleware
    console.log('4');
});

app.use(async (ctx, next) =&gt; {
    console.log('3');
});
</code></pre>
<p>输出结果： 12345</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[node接口生成接口文档]]></title>
        <id>https://weidadeda.github.io/post/node-jie-kou-sheng-cheng-jie-kou-wen-dang</id>
        <link href="https://weidadeda.github.io/post/node-jie-kou-sheng-cheng-jie-kou-wen-dang">
        </link>
        <updated>2022-01-17T03:21:22.000Z</updated>
        <content type="html"><![CDATA[<p>先看下效果<br>
<img src="https://weidadeda.github.io/post-images/1642391805862.png" alt="" loading="lazy"><br>
这里我用的是koa2+swagger</p>
<h3 id="安装">安装</h3>
<pre><code>// koa2-swagger-ui UI视图组件  swagger-jsdoc 识别写的 /***/ 转 json
npm install koa2-swagger-ui swagger-jsdoc --save
</code></pre>
<p><a href="https://www.npmjs.com/package/koa2-swagger-ui">koa2-swagger-ui npm地址</a> （创建接口文档）<br>
<a href="https://www.npmjs.com/package/swagger-jsdoc">swagger-jsdoc npm地址</a> （这个库读取带有jsdoc注释的源代码，并生成OpenAPI (Swagger)规范。）<br>
<a href="https://www.jianshu.com/p/5365ef83252a">OpenAPI 规范摘要</a></p>
<h3 id="配置">配置</h3>
<p>router.js</p>
<pre><code>const router = require('koa-router')() //引入路由函数
const swaggerJSDoc = require('swagger-jsdoc')
const path = require('path')
const swaggerDefinition = {
  openapi: '3.0.1',
    info: {
        title: 'blog项目访问地址',
        version: '1.0.0',
        description: 'API',
    },
    basePath: '/', // Base path (optional)
    tags: [
      {
        name: 'manage',
        description: '管理系统'
      },
      {
        name: 'client',
        description: '日志上报'
      }
    ],
    schemes: ['http', 'https'],
    securityDefinitions: {
    server_auth: {
      type: 'oauth2',
      description: '登录账号密码鉴权',
      tokenUrl: '',
      flow: 'password',
      scopes: {
        token: 'modify pets in your account'
      }
    },
    token: {
      type: 'apiKey',
      name: 'token',
      in: 'header'
    }
  }
};
const options = {
    swaggerDefinition,
    apis: [path.join(__dirname, './controllers/*.js')], // 包含上述注释的文件（）
};
const swaggerSpec = swaggerJSDoc(options)
// 通过路由获取生成的注解文件
router.get('/swagger.json', async function (ctx) {
    ctx.set('Content-Type', 'application/json');
    ctx.body = swaggerSpec;
})
module.exports = router
</code></pre>
<p>app.js 入口文件</p>
<pre><code>const swagger = require('./router')  // router中做了swagger配置
const { koaSwagger } = require('koa2-swagger-ui')

// 接口文档配置
app.use(swagger.routes(), swagger.allowedMethods())
app.use(koaSwagger({
  routePrefix: '/swagger', // 接口文档访问地址
  swaggerOptions: {
    url: '/swagger.json', // example path to json 其实就是之后swagger-jsdoc生成的文档地址
  }
}))
</code></pre>
<p>启动项目，访问项目接口地址 + swagger ，我的地址是 http://localhost:4002/swagger</p>
<h3 id="注释生成文档">注释生成文档</h3>
<p>在controller层文件每个接口上写注释，注释是以@swagger开头的，swagger-jsdoc 会识别@swagger，然后解析下面的注释，解析完给koa2-swagger-ui显示成页面，总的流程就是这样。<br>
get方式</p>
<pre><code>// 获取博客列表
/**
 * @swagger
 * /api/blog/list:
 *   get:
 *     summary: 获取博客列表
 *     description: 获取博客列表
 *     tags:
 *       - blogs
 *     parameters:
 *       - name: author
 *         in: query
 *         required: false
 *         description: 作者
 *         type: string
 *       - name: keyword
 *         in: query
 *         required: false
 *         description: 搜索关键字
 *         type: string
 *     responses:
 *       200:
 *         description: 成功获取
 */
router.get('/list', async (ctx, next) =&gt; {
  const query = ctx.query
  let author = query.author || ''
  const keyword = query.keyword || ''

  const listData = await getList(author, keyword)
  ctx.body = new SuccessModel(listData)
})
</code></pre>
<p>post方式</p>
<pre><code>/**
 * @swagger
 * definitions:
 *  loginparam:
 *    properties:
 *      username:
 *        type: &quot;string&quot;
 *        default: &quot;shangsan&quot;
 *        description: 用户名
 *      password:
 *        type: &quot;string&quot;
 *        default: &quot;123&quot;
 *        description: 密码
 */

/**
 * @swagger
 * components:
 *   schemas:
 *     ProjectDetail:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *           format: int64
 *         petId:
 *           type: integer
 *           format: int64
 *         quantity:
 *           type: integer
 *           format: int32
 *         shipDate:
 *           type: string
 *           format: date-time
 */

/**
 * @swagger
 * /api/user/login:
 *   post:
 *     summary: 登录
 *     description: 登录
 *     tags:
 *       - user
 *     consumes:
 *      - application/json
 *      - application/xml
 *     produces:
 *      - application/json
 *      - application/xml
 *     parameters:
 *       - name: body
 *         in: body
 *         schema:
 *          $ref: '#/definitions/loginparam' （请求参数这里单独抽出，在上面定义）
 *     responses:
 *       200:
 *         description: 发布成功
 *          content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ProjectDetail'（返回参数也是单独抽出定义，这里是随便举个例子）
 *       402:
 *          description: 信息填写不全
 *       403:
 *          description: 参数类型错误
 */

router.post('/login', async (ctx, next) =&gt; {
    // 业务逻辑
})
</code></pre>
<p>返回示例<br>
<img src="https://weidadeda.github.io/post-images/1642412213197.png" alt="" loading="lazy"><br>
基本的接口文档就生成啦，快试一下吧～</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sequelize node连接数据库的ORM]]></title>
        <id>https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm</id>
        <link href="https://weidadeda.github.io/post/sequelize-node-lian-jie-shu-ju-ku-de-orm">
        </link>
        <updated>2022-01-14T07:36:06.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.sequelize.com.cn/">Sequelize 中文文档</a><br>
可以先看文档，文档很全，它的语句帮我们做了很多处理，而且很精简，让我们不用死记硬背sql语句，也不用去库里建表。</p>
<h3 id="连接数据库">连接数据库</h3>
<pre><code>连接到数据库
要连接到数据库,必须创建一个 Sequelize 实例. 这可以通过将连接参数分别传递到 Sequelize 构造函数或通过传递一个连接 URI 来完成：

const { Sequelize } = require('sequelize');

// 方法 1: 传递一个连接 URI
const sequelize = new Sequelize('sqlite::memory:') // Sqlite 示例
const sequelize = new Sequelize('postgres://user:pass@example.com:5432/dbname') // Postgres 示例

// 方法 2: 分别传递参数 (sqlite)
const sequelize = new Sequelize({
  dialect: 'sqlite',
  storage: 'path/to/database.sqlite'
});

// 方法 3: 分别传递参数 (其它数据库)
const sequelize = new Sequelize('database', 'username', 'password', {
  host: 'localhost',
  dialect: /* 选择 'mysql' | 'mariadb' | 'postgres' | 'mssql' 其一 */
});
</code></pre>
<h3 id="定义模型-定义表结构">定义模型 （定义表结构）</h3>
<pre><code>module.exports = function(sequelize, DataTypes) {
  return sequelize.define(
    'project',
    {
      id: {
        type: DataTypes.INTEGER(11),
        allowNull: false,
        primaryKey: true,
        autoIncrement: true
      },
      name: { type: DataTypes.STRING(255), allowNull: true },
      title: { type: DataTypes.STRING(255), allowNull: true },
      report_fix_id: { type: DataTypes.STRING(1000), allowNull: true },
      fix_url: { type: DataTypes.STRING(2000), allowNull: true },
      ignore_key: {
        type: DataTypes.STRING(2000),
        allowNull: true,
        comment: '简化打印对象中比较大的对象'
      },
      env: {
        type: DataTypes.STRING(255),
        allowNull: true,
        comment: '哪些环境能上报日志'
      },
      report_interval: {
        type: DataTypes.INTEGER(11),
        allowNull: true,
        comment: '上报时间间隔'
      },
      ctime: {
        type: DataTypes.INTEGER(10),
        allowNull: true,
        get() {
          return moment
            .unix(this.getDataValue('ctime'))
            .format('YYYY/MM/DD HH:mm:ss')
        }
      },
      del: { type: DataTypes.INTEGER(1), allowNull: true, defaultValue: '0' }
    },
    {
      tableName: 'project'
    }
  )
}
</code></pre>
<h3 id="模型同步-真正从数据库创建">模型同步 （真正从数据库创建）</h3>
<p>定义模型时,你要告诉 Sequelize 有关数据库中表的一些信息. 但是,如果该表实际上不存在于数据库中怎么办？ 如果存在,但具有不同的列,较少的列或任何其他差异,该怎么办？</p>
<p>这就是模型同步的来源.可以通过调用一个异步函数(返回一个Promise)model.sync(options). 通过此调用,Sequelize 将自动对数据库执行 SQL 查询. 请注意,这仅更改数据库中的表,而不更改 JavaScript 端的模型.</p>
<p>User.sync() - 如果表不存在,则创建该表(如果已经存在,则不执行任何操作)</p>
<h4 id="usersync-force-true-将创建表如果表已经存在则将其首先删除-这个不要用也最好别试">User.sync({ force: true }) - 将创建表,如果表已经存在,则将其首先删除 （这个不要用，也最好别试）</h4>
<p>User.sync({ alter: true }) - 这将检查数据库中表的当前状态(它具有哪些列,它们的数据类型等),然后在表中进行必要的更改以使其与模型匹配.</p>
<pre><code>sequelize
  .authenticate()
  .then(() =&gt; {
    console.log('数据库连接成功'.green)
    // sequelize.sync({ alter: true })
  })
  .catch(err =&gt; {
    console.log('数据库连接失败'.red)
  })
</code></pre>
<h3 id="创建实例修改内容insert">创建实例（修改内容INSERT）</h3>
<p>尽管模型是一个类,但是你不应直接使用 new 运算符来创建实例. 相反,应该使用 build 方法：</p>
<pre><code>const jane = User.build({ name: &quot;Jane&quot; });
console.log(jane instanceof User); // true
console.log(jane.name); // &quot;Jane&quot;
</code></pre>
<p>但是,以上代码根本无法与数据库通信(请注意,它甚至不是异步的)！ 这是因为 build 方法仅创建一个对象,该对象 表示 可以 映射到数据库的数据. 为了将这个实例真正保存(即持久保存)在数据库中,应使用 save 方法：</p>
<pre><code>await jane.save();
console.log('Jane 已保存到数据库!');
</code></pre>
<p>请注意,从上面代码段中的 await 用法来看,save 是一种异步方法. 实际上,几乎每个 Sequelize 方法都是异步的. build 是极少数例外之一.</p>
<p>非常有用的捷径: create 方法<br>
Sequelize提供了 create 方法,该方法将上述的 build 方法和 save 方法合并为一个方法：</p>
<pre><code>const jane = await User.create({ name: &quot;Jane&quot; });
// Jane 现在存在于数据库中！
console.log(jane instanceof User); // true
console.log(jane.name); // &quot;Jane&quot;
</code></pre>
<h3 id="简单-select-查询">简单 SELECT 查询</h3>
<p>你可以使用 findAll 方法从数据库中读取整个表：</p>
<pre><code>// 查询所有用户
const users = await User.findAll();
console.log(users.every(user =&gt; user instanceof User)); // true
console.log(&quot;All users:&quot;, JSON.stringify(users, null, 2));
</code></pre>
<p>相当于sql语句</p>
<pre><code>SELECT * FROM ...
</code></pre>
<p>嗯，写一些建表与查询的流程，照着官网抄也没什么意思。使用这个我们可以很轻松的操作数据库，使我们写node接口的时候效率翻倍～</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端使用Nacos]]></title>
        <id>https://weidadeda.github.io/post/sequelize</id>
        <link href="https://weidadeda.github.io/post/sequelize">
        </link>
        <updated>2022-01-14T07:36:06.000Z</updated>
        <content type="html"><![CDATA[<p>官网介绍：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。<br>
<a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">Nacos中文文档</a></p>
<blockquote>
<p>概览<br>
欢迎来到 Nacos 的世界！<br>
Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。<br>
Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p>
</blockquote>
<p>这个东西主要用于微服务，但我作为一个前端，只用了它的配置管理功能，虽然有点大材小用，但确实方便,而且还可以通过网页去直接查看数据结构。</p>
<p>假设前端要搞一个平台，但是并没有后端支持，那么权限管理以及一些必要的数据获取该怎么做呢，我们想到的肯定是node起服务，然后写接口，然后连接数据库。从而实现数据的增删改查。</p>
<p>但有一种更简单的方式，就是在服务器的docker中下载一个nacos,把数据放到nacos中管理，这样数据依然在我们的服务器上，并且不需要我们自己去写接口，nacos提供了openApi，我们直接调用接口就可以，是不是很方便呢。下面开始安装：</p>
<h3 id="nacos-docker-快速开始">Nacos Docker 快速开始</h3>
<p>操作步骤<br>
Clone 项目</p>
<pre><code>git clone https://github.com/nacos-group/nacos-docker.git
cd nacos-docker
</code></pre>
<p>单机模式 Derby</p>
<pre><code>docker-compose -f example/standalone-derby.yaml up
</code></pre>
<p>单机模式 MySQL</p>
<p>如果希望使用MySQL5.7</p>
<pre><code>docker-compose -f example/standalone-mysql-5.7.yaml up
</code></pre>
<p>如果希望使用MySQL8</p>
<pre><code>docker-compose -f example/standalone-mysql-8.yaml up
</code></pre>
<p>集群模式</p>
<pre><code>docker-compose -f example/cluster-hostname.yaml up 
</code></pre>
<p>服务注册</p>
<p>curl -X POST 'http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080'<br>
服务发现</p>
<p>curl -X GET 'http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName'<br>
发布配置</p>
<p>curl -X POST &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=helloWorld&quot;<br>
获取配置</p>
<p>curl -X GET &quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&quot;<br>
Nacos 控制台</p>
<p>link：http://127.0.0.1:8848/nacos/（因为是在服务器上，所以可以直接使用对应的域名或者ip来访问）</p>
<h3 id="注意这里要用openapi提供的字段信息多了tenant字段-有哪里不明白的可以看下开头的官方文档哈">注意，这里要用openApi提供的字段信息，多了tenant字段。有哪里不明白的可以看下开头的官方文档哈。</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql查询语句]]></title>
        <id>https://weidadeda.github.io/post/mysql-cha-xun-yu-ju</id>
        <link href="https://weidadeda.github.io/post/mysql-cha-xun-yu-ju">
        </link>
        <updated>2022-01-14T06:46:38.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.mysqlzh.com/doc/124.html">mysql中文文档</a></p>
<h3 id="1查询记录">1.查询记录</h3>
<pre><code>select*from 表名 [where 条件];

eg:select*from students;//查询 students 表中所有记录，所有字段的值都显示出来

select field1,field2,...fieldn... from 表名 [where 条件];

eg:select id,name,age from students;//查询 students 表中所有记录, 只显示出 id，name，age三个字段的值
</code></pre>
<p>1.“*”表示将所有的字段都显示出来</p>
<p>2.用逗号分割，列出需要显示的字段</p>
<h3 id="2查询不重复的记录">2.查询不重复的记录</h3>
<pre><code>select distinct 字段 from 表名;

eg: select distinct name from students;//查询名字不相同的学生;
　　select distinct name,age from students;//查询名字和年龄同时不同的学生
　　
　　1.distinct必须放在最开头
　　2.distinct只能使用需要去重的字段进行操作。  ----也就是说我sidtinct了name,age两个字段，我后面想根据id进行排序，是不可以的，因为只能name,age两个字段进行操作.
　　3.distinct去重多个字段时，含义是：几个字段 同时重复 时才会被 过滤。
</code></pre>
<h3 id="3条件查询">3.条件查询</h3>
<pre><code>select 字段 from 表名 where 条件;

eg:select * from student where sex='男' and age&gt;20; //查询性别是男，并且年龄大于20岁的人。

where后面的条件可以用&gt;、&lt;、&gt;=、&lt;=、!=等多种比较运算符，多个条件之间可以用or、and等逻辑运算符
</code></pre>
<h3 id="4排序和限制">4.排序和限制</h3>
<pre><code>排序
select * from 表名 [where 条件] [ order by  field1 [desc/asc],field2 [desc/asc]... ];

eg:select *from student order by age desc;//查询学生表并按年龄降序排列。

1.desc 降序排列，asc 升序排列
2.order by 后面可以跟多个不同的排序字段，每个排序字段都可以有不同的排序顺序。
3.如果排序字段的值一样，则相同的字段按照第二个排序字段进行排序。
4.如果只有一个排序字段，则字段相同的记录将会无序排列。
</code></pre>
<pre><code>限制
select ... [limit 起始偏移量,行数];

eg:select * from student order by mark desc limit 5;//取出成绩前五名的学生(省略了起始偏移量，此时默认为0)

1.默认情况下，起始偏移量为0，只写记录行数就可以。
</code></pre>
<h3 id="5聚合">5.聚合</h3>
<pre><code>select 字段 fun_name from 表名 [where 条件] [group by field1,field2...] [with rollup] [having 条件];

eg:

1.fun_name 表示要做的聚合操作，也就是说聚合函数，常用的有 : sum(求和)、count(*)(记录数)、max(最大值)、min(最小值)。
2.group by关键字 表示要进行分类聚合的字段。比如要按照部门分类统计员工数量，部门就应该写在group by 后面。
3.with rollup 是可选语法，表明是否对分类聚合后的结果进行再汇总
4.having 关键字表示对分类后的结果再进行条件过滤。
</code></pre>
<p>公司员工表A如下 (编号，姓，名，薪水) ：<br>
<img src="https://weidadeda.github.io/post-images/1642143111386.png" alt="" loading="lazy"></p>
<pre><code>统计总人数
select count(1) from A;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1642143169839.png" alt="" loading="lazy"></figure>
<pre><code>统计各个姓的人数
select xing,count(1) from A group by xing;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://weidadeda.github.io/post-images/1642143194061.png" alt="" loading="lazy"></figure>
<pre><code>既要统计各个姓的人数，又统计总人数
select xing,count(1) from A group by xing with rollup;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://weidadeda.github.io/post-images/1642143250933.png" alt="" loading="lazy"></figure>
<pre><code>统计人数大4的姓
select xing,count(1) from A group by xing having count(1)&gt;4;
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://weidadeda.github.io/post-images/1642143298558.png" alt="" loading="lazy"></figure>
<pre><code>统计薪水总额，最低薪资，最高薪资
select count(1),min(salary),max(salary) from A;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://weidadeda.github.io/post-images/1642143319528.png" alt="" loading="lazy"></figure>
<h3 id="6为表和字段取别名">6.为表和字段取别名</h3>
<p>在查询数据时，可以为表和字段取别名，这个别名可以代替指定的表和字段。如果表名很长，用起来不方便，则可以用一个别名来代替，语法如下：(as关键字可省略)</p>
<pre><code>select * from 表名 [as] 别名  （为表取别名）
</code></pre>
<pre><code>SELECT 字段名 [AS] 别名[,字段名 [AS] 别名,……] FROM 表名; (为字段取别名)
</code></pre>
]]></content>
    </entry>
</feed>