<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://weidadeda.github.io</id>
    <title>大伟的博客</title>
    <updated>2022-02-15T11:11:32.585Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://weidadeda.github.io"/>
    <link rel="self" href="https://weidadeda.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://weidadeda.github.io/images/avatar.png</logo>
    <icon>https://weidadeda.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 大伟的博客</rights>
    <entry>
        <title type="html"><![CDATA[自定义一个WebPack的插件]]></title>
        <id>https://weidadeda.github.io/post/zi-ding-yi-yi-ge-webpack-de-cha-jian</id>
        <link href="https://weidadeda.github.io/post/zi-ding-yi-yi-ge-webpack-de-cha-jian">
        </link>
        <updated>2022-02-14T10:32:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-webpack插件的基本原理">1、webpack插件的基本原理</h3>
<p>我们知道，webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。<br>
webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好。<br>
<a href="https://www.webpackjs.com/contribute/writing-a-plugin/">官网提供的自定义插件文档</a></p>
<blockquote>
<p>tapable 是一个类似于 Node.js 中的 EventEmitter的库，但更专注于自定义事件的触发和处理。webpack 通过 tapable 将实现与流程解耦，所有具体实现通过插件的形式存在。</p>
</blockquote>
<ul>
<li>tapable作为webpack的主模块，需要单独抽一篇出来讲。需要注意的是，如果你要写sdk需要向外层吐露数据的话，建议还是用EventEmitter库，不建议用tapable，因为它销毁全部注册事件不是很容易。<br>
好了，写webpack插件必须要了解tapable，这里我们先简单介绍一下它的几个常用的钩子，其他的可以网上查，这里有篇写的还不错<a href="https://blog.csdn.net/mafan121/article/details/113120081">tapable详解</a></li>
</ul>
<pre><code>const {
  SyncHook,
  SyncBailHook,
  SyncWaterfallHook,
  SyncLoopHook,
  AsyncParallelHook,
  AsyncParallelBailHook,
  AsyncSeriesHook,
  AsyncSeriesBailHook,
  AsyncSeriesWaterfallHook
} = require('tapable');
</code></pre>
<h3 id="tapable通过tap注册一个事件通过call执行该钩子注册的所有事件-tapable的每个hooks都tap一个或多个事件-tapasynccallasync-tappromisepromise用于注册同步执行的异步事件callasync用在并行执行的异步钩子完成后再执行该函数">tapable通过tap注册一个事件，通过call执行该钩子注册的所有事件。tapable的每个hooks都tap一个或多个事件。tapAsync/callAsync、tapPromise/Promise用于注册同步执行的异步事件，callAsync用在并行执行的异步钩子完成后再执行该函数。</h3>
<p>具体使用举个例子（比如SyncHook，依次执行注册事件，无法中断）</p>
<pre><code> const hook = new SyncHook(['name', 'sex'])
  /*
  tap(options,function):
  options是事件描述，可以为一个字符串，也可以为一个对象,为对象时必须包含name属性，描述该插件名称。
  function:回调函数
  */
  // 打印我的名字
  hook.tap('printName', (name) =&gt; {
    console.log('my name is ' + name);
  })
  hook.tap('printSex', (name, sex) =&gt; {
    console.log('I’m a ' + sex);
  })
  // call(arg1,arg2,...)
  hook.call('张三', 'man');

  执行结果：

    my name is 张三

    I’m a man
</code></pre>
<p>好了，说了一堆tapable了，该说webpack插件了。</p>
<p>webpack 插件由以下组成：</p>
<ul>
<li>一个 JavaScript 命名函数。</li>
<li>在插件函数的 prototype 上定义一个 apply 方法。</li>
<li>指定一个绑定到 webpack 自身的事件钩子。</li>
<li>处理 webpack 内部实例的特定数据。</li>
<li>功能完成后调用 webpack 提供的回调。</li>
</ul>
<p>下面是官网的简单例子：</p>
<pre><code class="language-js">// 一个 JavaScript 命名函数。
function MyExampleWebpackPlugin() {

};

// 在插件函数的 prototype 上定义一个 `apply` 方法。
MyExampleWebpackPlugin.prototype.apply = function(compiler) {
  // 指定一个挂载到 webpack 自身的事件钩子。
  compiler.plugin('webpacksEventHook', function(compilation /* 处理 webpack 内部实例的特定数据。*/, callback) {
    console.log(&quot;This is an example plugin!!!&quot;);

    // 功能完成后调用 webpack 提供的回调。
    callback();
  });
};
</code></pre>
<p>在我们使用该plugin的时候，相关调用及配置代码如下：</p>
<pre><code class="language-js">const MyExampleWebpackPlugin = require('./MyExampleWebpackPlugin');
module.exports = {
  plugins: [
    new MyExampleWebpackPlugin(options)
  ]
};
</code></pre>
<p>我开始说了一大堆tapable，其实就是为了说明白webpack插件的原理</p>
<p>用代码说明吧，一个compiler.js，一个main.js<br>
compiler.js</p>
<pre><code class="language-js">// 需要做的事情如下：
// 1. 定义一个 Compiler 类，接收一个options对象参数，该参数是从main.js中的MyPlugin类的实列对象。该对象下有 apply函数。

// 2. 在该类中我们定义了run方法，我们在main.js 中执行该run函数就可以自动执行对应的插件了。

const { SyncHook, AsyncParallelHook } = require('tapable');

class Compiler {
  constructor(options) {
    this.hooks = {
      kzSyncHook: new SyncHook(['name', 'age']),
      kzAsyncHook: new AsyncParallelHook(['name', 'age'])
    };
    let plugins = options.plugins;
    if (plugins &amp;&amp; plugins.length &gt; 0) {
      plugins.forEach(plugin =&gt; plugin.apply(this));
    }
  }
  run() {
    console.log('开始执行了---------');
    this.kzSyncHook('我是小明', 81);
    this.kzAsyncHook('我是小红', 91);
  }
  kzSyncHook(name, age) {
    this.hooks.kzSyncHook.call(name, age);
  }
  kzAsyncHook(name, age) {
    this.hooks.kzAsyncHook.callAsync(name, age);
  }
}

module.exports = Compiler;
</code></pre>
<p>main.js</p>
<pre><code class="language-js">// 需要做的事情如下：
// 1. 引入 compiler.js 文件。
// 2. 定义一个自己的插件，比如叫 MyPlugin 类，该类下有 apply 函数。该函数有一个 compiler 参数，该参数就是我们的 compiler.js 中的实列对象。然后我们会使用 compiler 实列对象去调用 compiler.js 里面的函数。因此就可以自动执行了。
const Compiler = require('./compiler');

class MyPlugin {
  constructor() {
    
  }
  apply(compiler) {
    compiler.hooks.kzSyncHook.tap(&quot;eventName1&quot;, (name, age) =&gt; {
      console.log(`同步事件eventName1： ${name} this year ${age} 周岁了, 可是还是单身`);
    });
    compiler.hooks.kzAsyncHook.tapAsync('eventName2', (name, age) =&gt; {
      setTimeout(() =&gt; {
        console.log(`异步事件eventName2： ${name} this year ${age}周岁了，可是还是单身`);
      }, 1000)
    });
  }
}

const myPlugin = new MyPlugin();

const options = {
  plugins: [myPlugin]
};

const compiler = new Compiler(options);
compiler.run();
</code></pre>
<p>看到没，这种使用方式是不是和官网的使用方式很相似～这回知道原理了吧～</p>
<p>现在看官网的简单例子，webpack启动后，在读取配置的过程中会先执行 new MyExampleWebpackPlugin(options) 初始化MyExampleWebpackPlugin来获得一个实例。<br>
然后我们会把该实例当做参数传递给我们的Compiler对象，然后会实例化 Compiler类(这个逻辑可以结合看我们上面实现了一个简单的demo中 的main.js和compiler.js的代码结合起来理解)。在Compiler类中，我们会获取到options的这个参数，该参数是一个对象，该对象下有一个 plugins 这个属性。<br>
然后遍历该属性，然后依次执行 某项插件中的apply方法，即：myExampleWebpackPlugin.apply(compiler); 给插件传递compiler对象。插件实例获取该compiler对象后，就可以通过 compiler.plugin('事件名称', '回调函数'); 监听到webpack广播出来的事件.(这个地方我们可以看我们上面的main.js中的如下代码可以看到, 在我们的main.js代码中有这样代码：compiler.hooks.kzSyncHook.tap(&quot;eventName1&quot;, (name, age) =&gt; {}));</p>
<p>如上就是一个简单的Plugin的插件原理(切记：结合上面的demo中main.js和compiller.js来理解效果会更好)。</p>
<h3 id="2-compiler-和-compilation">2、Compiler 和 Compilation</h3>
<p>在开发Plugin时我们最常用的两个对象就是 Compiler 和 Compilation, 他们是Plugin和webpack之间的桥梁。</p>
<blockquote>
<p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p>
</blockquote>
<blockquote>
<p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p>
</blockquote>
<h4 id="compiler对象">Compiler对象</h4>
<p>Compiler对象包含了Webpack环境所有的配置信息，包含options，loaders, plugins这些项，这个对象在webpack启动时候被实例化，它是全局唯一的。我们可以把它理解为webpack的实例。</p>
<p>基本源码可以看如下：</p>
<pre><code>// webpack/lib/webpack.js
const Compiler = require(&quot;./Compiler&quot;)

const webpack = (options, callback) =&gt; {
  ...
  // 初始化 webpack 各配置参数
  options = new WebpackOptionsDefaulter().process(options);

  // 初始化 compiler 对象，这里 options.context 为 process.cwd()
  let compiler = new Compiler(options.context);

  compiler.options = options                               // 往 compiler 添加初始化参数

  new NodeEnvironmentPlugin().apply(compiler)              // 往 compiler 添加 Node 环境相关方法

  for (const plugin of options.plugins) {
    plugin.apply(compiler);
  }
  ...
}
</code></pre>
<blockquote>
<p><a href="https://github.com/webpack/webpack/blob/10282ea20648b465caec6448849f24fc34e1ba3e/lib/webpack.js#L30">源码可以点击这里</a></p>
</blockquote>
<p>如上我们可以看到，Compiler对象包含了所有的webpack可配置的内容。开发插件时，我们可以从 compiler 对象中拿到所有和 webpack 主环境相关的内容。</p>
<h4 id="compilation对象">compilation对象</h4>
<p>compilation 对象包含了当前的模块资源、编译生成资源、文件的变化等。当webpack在开发模式下运行时，每当检测到一个文件发生改变的时候，那么一次新的 Compilation将会被创建。从而生成一组新的编译资源。</p>
<p>Compiler对象 与 Compilation 对象 的区别是：Compiler代表了是整个webpack从启动到关闭的生命周期。Compilation 对象只代表了一次新的编译。</p>
<p>Compiler对象的事件钩子:</p>
<pre><code>钩子               作用                     参数               类型
after-plugins     设置完一组初始化插件之后    compiler          sync
after-resolvers   设置完 resolvers 之后     compiler          sync
run               在读取记录之前             compiler          async
compile           在创建新 compilation之前  compilationParams  sync
compilation       compilation 创建完成      compilation        sync
emit              在生成资源并输出到目录之前  compilation        async
after-emit        在生成资源并输出到目录之后  compilation        async
done              完成编译                  stats              sync
</code></pre>
<blockquote>
<p><a href="https://github.com/webpack/webpack/blob/eca7bad8de54c39b9cb8b138793362b8a17ac11b/lib/Compiler.js#L32">源码地址</a></p>
</blockquote>
<h4 id="理解webpack中的事件流">理解webpack中的事件流</h4>
<p>我们可以把webpack理解为一条生产线，需要经过一系列处理流程后才能将源文件转换成输出结果。<br>
这条生产线上的每个处理流程的职责都是单一的，多个流程之间会存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。</p>
<p>我们的插件就像一个插入到生产线中的一个功能，在特定的时机对生产线上的资源会做处理。webpack它是通过 Tapable来组织这条复杂的生产线的。</p>
<p>webpack在运行的过程中会广播事件，插件只需要关心监听它的事件，就能加入到这条生产线中。然后会执行相关的操作。<br>
webpack的事件流机制它能保证了插件的有序性，使整个系统的扩展性好。事件流机制使用了观察者模式来实现的。比如如下代码：</p>
<pre><code>/*
 * 广播事件
 * myPlugin-name 为事件名称
 * params 为附带的参数
*/

compiler.apply('myPlugin-name', params); // myPlugin-name随便写，就是一个名字

/*
 * 监听名称为 'myPlugin-name' 的事件，当 myPlugin-name 事件发生时，函数就会执行。
*/

compiler.hooks.myPlugin-name.tap('myPlugin-name', function(params) {
  
});
</code></pre>
<h3 id="插件中常用的api">插件中常用的API</h3>
<h4 id="compiler生命周期钩子">compiler生命周期钩子</h4>
<p><a href="https://www.webpackjs.com/api/compiler-hooks/">官方文档</a></p>
<blockquote>
<p>Compiler 支持可以监控文件系统的<a href="https://www.webpackjs.com/api/node/#watching">监听(watching)</a>机制，并且在文件修改时重新编译。当处于监听模式(watch mode)时，compiler 会触发诸如 watchRun, watchClose 和 invalid 等额外的事件。通常用于开发环境中使用，也常常会在 webpack-dev-server 这些工具的底层之下调用，由此开发人员无须每次都使用手动方式重新编译。还可以通过 CLI 进入监听模式。</p>
</blockquote>
<p>相关钩子：<br>
以下生命周期钩子函数，是由 compiler 暴露，可以通过如下方式访问：</p>
<pre><code>compiler.hooks.someHook.tap(...)
</code></pre>
<p>取决于不同的钩子类型，也可以在某些钩子上访问 tapAsync 和 tapPromise。</p>
<table>
<thead>
<tr>
<th style="text-align:center">生命周期</th>
<th style="text-align:center">对应hooks</th>
<th style="text-align:center">执行时机</th>
<th style="text-align:center">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">entryOption</td>
<td style="text-align:center">SyncBailHook</td>
<td style="text-align:center">在 entry 配置项处理过之后，执行插件。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">afterPlugins</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">设置完初始插件之后，执行插件。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">afterResolvers</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">resolver 安装完成之后，执行插件。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">environment</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">environment 准备好之后，执行插件。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">afterEnvironment</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">environment 安装完成之后，执行插件。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">beforeRun</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">compiler.run() 执行之前，添加一个钩子。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">开始读取 records 之前，钩入(hook into) compiler。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">watchRun</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">监听模式下，一个新的编译(compilation)触发之后，执行一个插件，但是是在实际编译开始之前。</td>
<td style="text-align:center">compiler</td>
</tr>
<tr>
<td style="text-align:center">normalModuleFactory</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">NormalModuleFactory 创建之后，执行插件。</td>
<td style="text-align:center">normalModuleFactory</td>
</tr>
<tr>
<td style="text-align:center">contextModuleFactory</td>
<td style="text-align:center"></td>
<td style="text-align:center">ContextModuleFactory 创建之后，执行插件。</td>
<td style="text-align:center">contextModuleFactory</td>
</tr>
<tr>
<td style="text-align:center">beforeCompile</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">编译(compilation)参数创建之后，执行插件。</td>
<td style="text-align:center">compilationParams</td>
</tr>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">一个新的编译(compilation)创建之后，钩入(hook into) compiler。</td>
<td style="text-align:center">compilationParams</td>
</tr>
<tr>
<td style="text-align:center">thisCompilation</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">触发 compilation 事件之前执行（查看下面的 compilation）</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">compilation</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">编译(compilation)创建之后，执行插件</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">make</td>
<td style="text-align:center">AsyncParallelHook</td>
<td style="text-align:center"></td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">afterCompile</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center"></td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">shouldEmit</td>
<td style="text-align:center">SyncBailHook</td>
<td style="text-align:center">此时返回 true/false。</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">needAdditionalPass</td>
<td style="text-align:center">SyncBailHook</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">emit</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">生成资源到 output 目录之前。</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">afterEmit</td>
<td style="text-align:center">AsyncSeriesHook</td>
<td style="text-align:center">生成资源到 output 目录之后。</td>
<td style="text-align:center">compilation</td>
</tr>
<tr>
<td style="text-align:center">done</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">编译(compilation)完成</td>
<td style="text-align:center">stats</td>
</tr>
<tr>
<td style="text-align:center">failed</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">编译(compilation)失败</td>
<td style="text-align:center">error</td>
</tr>
<tr>
<td style="text-align:center">invalid</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">监听模式下，编译无效时</td>
<td style="text-align:center">fileName, changeTime</td>
</tr>
<tr>
<td style="text-align:center">watchClose</td>
<td style="text-align:center">SyncHook</td>
<td style="text-align:center">监听模式停止</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="读取输出资源-模块及依赖">读取输出资源、模块及依赖</h4>
<p>在我们的emit钩子事件发生时，表示的含义是：源文件的转换和组装已经完成了，在这里事件钩子里面我们可以读取到最终将输出的资源、代码块、模块及对应的依赖文件。并且我们还可以输出资源文件的内容。比如插件代码如下:</p>
<pre><code class="language-js">class MyPlugin {
  apply(compiler) {
    compiler.plugin('emit', function(compilation, callback) {
      // compilation.chunks 是存放了所有的代码块，是一个数组，我们需要遍历
      compilation.chunks.forEach(function(chunk) {
        /*
         * chunk 代表一个代码块，代码块它是由多个模块组成的。
         * 我们可以通过 chunk.forEachModule 能读取组成代码块的每个模块
        */
        chunk.forEachModule(function(module) {
          // module 代表一个模块。
          // module.fileDependencies 存放当前模块的所有依赖的文件路径，它是一个数组
          module.fileDependencies.forEach(function(filepath) {
            console.log(filepath);
          });
        });
        /*
         webpack 会根据chunk去生成输出的文件资源，每个chunk都对应一个及以上的输出文件。
         比如在 Chunk中包含了css 模块并且使用了 ExtractTextPlugin 时，
         那么该Chunk 就会生成 .js 和 .css 两个文件
        */
        chunk.files.forEach(function(filename) {
          // compilation.assets 是存放当前所有即将输出的资源。
          // 调用一个输出资源的 source() 方法能获取到输出资源的内容
          const source = compilation.assets[filename].source();
        });
      });
      /*
       该事件是异步事件，因此要调用 callback 来通知本次的 webpack事件监听结束。
       如果我们没有调用callback(); 那么webpack就会一直卡在这里不会往后执行。
      */
      callback();
    })
  }
}
</code></pre>
<h4 id="监听文件变化">监听文件变化</h4>
<p>webpack读取文件的时候，它会从入口模块去读取，然后依次找出所有的依赖模块。当入口模块或依赖的模块发生改变的时候，那么就会触发一次新的 Compilation。</p>
<p>在我们开发插件的时候，我们需要知道是那个文件发生改变，导致了新的Compilation, 我们可以添加如下代码进行监听。</p>
<pre><code class="language-js">// 当依赖的文件发生改变的时候 会触发 watch-run 事件
class MyPlugin {
  apply(compiler) {
    compiler.plugin('watch-run', (watching, callback) =&gt; {
      // 获取发生变换的文件列表
      const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes;
      // changedFiles 格式为键值对的形式，当键为发生变化的文件路径
      if (changedFiles[filePath] !== undefined) {
        // 对应的文件就发生了变化了
      }
      callback();
    });

    /*
     默认情况下Webpack只会监听入口文件或其依赖的模块是否发生变化，但是在有些情况下比如html文件发生改变的时候，那么webpack
     就会去监听html文件的变化。因此就不会重新触发新的 Compilation。因此为了监听html文件的变化，我们需要把html文件加入到
     依赖列表中。因此我们需要添加如下代码：
    */
    compiler.plugin('after-compile', (compilation, callback) =&gt; {
      /*
       如下的参数filePath是html文件路径，我们把HTML文件添加到文件依赖表中，然后我们的webpack会去监听html模块文件，
       html模板文件发生改变的时候，会重新启动下重新编译一个新的 Compilation.
      */
      compilation.fileDependencies.push(filePath);
      callback();
    })
  }
}
</code></pre>
<h4 id="修改输出资源">修改输出资源</h4>
<p>我们在第一点说过：在我们的emit钩子事件发生时，表示的含义是：源文件的转换和组装已经完成了，在这里事件钩子里面我们可以读取到最终将输出的资源、代码块、模块及对应的依赖文件。因此如果我们现在要修改输出资源的内容的话，我们可以在emit事件中去做修改。那么所有输出的资源会存放在 compilation.assets中，compilation.assets是一个键值对，键为需要输出的文件名，值为文件对应的内容。如下代码：</p>
<pre><code class="language-js">class MyPlugin {
  apply(compiler) {
    compiler.plugin('emit', (compilation, callback) =&gt; {
      // 设置名称为 fileName 的输出资源
      compilation.assets[fileName] = {
        // 返回文件内容
        source: () =&gt; {
          // fileContent 即可以代表文本文件的字符串，也可以是代表二进制文件的buffer
          return fileContent;
        },
        // 返回文件大小
        size: () =&gt; {
          return Buffer.byteLength(fileContent, 'utf8');
        }
      };
      callback();
    });
    // 读取 compilation.assets 代码如下：
    compiler.plugin('emit', (compilation, callback) =&gt; {
      // 读取名称为 fileName 的输出资源
      const asset = compilation.assets[fileName];
      // 获取输出资源的内容
      asset.source();
      // 获取输出资源的文件大小
      asset.size();
      callback();
    });
  }
}
</code></pre>
<h4 id="判断webpack使用了哪些插件">判断webpack使用了哪些插件</h4>
<p>在我们开发一个插件的时候，我们需要根据当前配置是否使用了其他某个插件，我们可以通过读取webpack某个插件配置的情况，比如来判断我们当前是否使用了 HtmlWebpackPlugin 插件。代码如下：</p>
<pre><code class="language-js">/*
 判断当前配置使用了 HtmlWebpackPlugin 插件。
 compiler参数即为 webpack 在 apply(compiler) 中传入的参数
*/

function hasHtmlWebpackPlugin(compiler) {
  // 获取当前配置下所有的插件列表
  const plugins = compiler.options.plugins;
  // 去plugins中寻找有没有 HtmlWebpackPlugin 的实列
  return plugins.find(plugin =&gt; plugin.__proto__.constructor === HtmlWebpackPlugin) !== null;
}
</code></pre>
<h3 id="实战">实战</h3>
<h4 id="实现一个打印日志的logwebpackplugin插件">实现一个打印日志的LogWebpackPlugin插件</h4>
<pre><code class="language-js">// 这个文件为了观看更直观，先放到webpack.config.js中，真正使用时可以将你的自定义webpack插件封装到你们的前端组件库中。
class LogWebpackPlugin {
  constructor(doneCallback, emitCallback) {
    this.emitCallback = emitCallback
    this.doneCallback = doneCallback
  }
  apply(compiler) {
    compiler.hooks.emit.tap('LogWebpackPlugin', () =&gt; {
      // 在 emit 事件中回调 emitCallback
      this.emitCallback();
    });
    compiler.hooks.done.tap('LogWebpackPlugin', (err) =&gt; {
      // 在 done 事件中回调 doneCallback
      this.doneCallback();
    });
    compiler.hooks.compilation.tap('LogWebpackPlugin', () =&gt; {
      // compilation（'编译器'对'编译ing'这个事件的监听）
      console.log(&quot;The compiler is starting a new compilation...&quot;)
    });
    compiler.hooks.compile.tap('LogWebpackPlugin', () =&gt; {
      // compile（'编译器'对'开始编译'这个事件的监听）
      console.log(&quot;The compiler is starting to compile...&quot;)
    });
  }
}


// 使用
module.exports = {
  plugins: [
    new LogWebpackPlugin(() =&gt; {
      // Webpack 模块完成转换成功
      console.log('emit 事件发生啦，所有模块的转换和代码块对应的文件已经生成好~')
    } , () =&gt; {
      // Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作
      console.log('done 事件发生啦，成功构建完成~')
    })
  ]
}
</code></pre>
<h4 id="编写去除生成-bundlejs-中多余的注释的插件">编写去除生成 bundle.js 中多余的注释的插件</h4>
<pre><code class="language-js">class MyPlugin {
  constructor(options) {
    this.options = options;
    this.externalModules = {};
  }
  apply(compiler) {
    var reg = /(&quot;([^\\\&quot;]*(\\.)?)*&quot;)|('([^\\\']*(\\.)?)*')|(\/{2,}.*?(\r|\n))|(\/\*(\n|.)*?\*\/)|(\/\*\*\*\*\*\*\/)/g;
    compiler.hooks.emit.tap('CodeBeautify', (compilation) =&gt; {
      Object.keys(compilation.assets).forEach((data) =&gt; {
        console.log(data);
        let content = compilation.assets[data].source(); // 获取处理的文本
        content = content.replace(reg, function (word) { // 去除注释后的文本
          return /^\/{2,}/.test(word) || /^\/\*!/.test(word) || /^\/\*{3,}\//.test(word) ? &quot;&quot; : word;
        });
        compilation.assets[data] = {
          source() {
            return content;
          },
          size() {
            return content.length;
          }
        }
      });
    });
  }
}
module.exports = MyPlugin;
</code></pre>
<p>这个js代码的真正的含义才是我们今天要讲到的，这个插件最主要作用是 去除注释后的文本。</p>
<ol>
<li>
<p>第一步，我们使用 compiler.hooks.emit 钩子函数。在生成资源并输出到目录之前触发该函数，也就是说将编译好的代码发射到指定的stream中就会触发，然后我们从回调函数返回的 compilation 对象上可以拿到编译好的 stream.</p>
</li>
<li>
<p>访问compilation对象，compilation内部会返回很多内部对象，这边先不打印了，因为打印的话直接会卡死掉，要等很长时间才会打印出来，你们自己可以试试；然后我们遍历 assets.</p>
</li>
</ol>
<pre><code class="language-js">Object.keys(compilation.assets).forEach((data) =&gt; {
  console.log(compilation.assets);
  console.log(8888)
  console.log(data);
});
</code></pre>
<p>如下图所示：<br>
<img src="https://weidadeda.github.io/post-images/1644922971138.png" alt="" loading="lazy"></p>
<ul>
<li>assets 数组对象中的key是资源名。在如上代码，我们通过 Object.key()方法拿到了。如下所示：<pre><code>main.css
bundle.js
index.html
</code></pre>
</li>
<li>然后我们调用 compilation.assets[data].source(); 可以获取资源的内容。</li>
<li>使用正则，去掉注释，如下代码：<pre><code class="language-js">Object.keys(compilation.assets).forEach((data) =&gt; {
  let content = compilation.assets[data].source(); // 获取处理的文本
  content = content.replace(reg, function (word) { // 去除注释后的文本
      return /^\/{2,}/.test(word) || /^\/\*!/.test(word) || /^\/\*{3,}\//.test(word) ? &quot;&quot; : word;
  });
});
</code></pre>
</li>
<li>更新 compilation.assets[data] 对象，如下代码：<pre><code class="language-js">compilation.assets[data] = {
  source() {
      return content;
  },
  size() {
      return content.length;
  }
}
</code></pre>
</li>
<li>最后使用<pre><code class="language-js">module.exports = {
  plugins:[
      new MyPlugin(),
  ]
}
</code></pre>
</li>
</ul>
<p>最后扩展：简单看了几个插件之后，是不是可以考虑做些其他的事情，比如删除console.log、或者构建完成时做一些文件上传cdn的操作，马上动手吧～</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[短信短链接唤起APP]]></title>
        <id>https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app</id>
        <link href="https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app">
        </link>
        <updated>2022-02-10T07:59:08.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644479995097.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信公众号获取openid等一系列流程]]></title>
        <id>https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng</id>
        <link href="https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng">
        </link>
        <updated>2022-02-08T12:49:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="先说下为什么要获取-openid">先说下为什么要获取 openid?</h3>
<p>因为用户管理类接口可以通过openid可以获取用户的一些信息的.</p>
<h3 id="说到-openid-必须先说微信授权登录的过程">说到 openid 必须先说微信授权登录的过程</h3>
<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644479416142.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>前端需要在进入路由的是beaforEach的时候，先去判断链接上有没有 openid</p>
</li>
<li>
<p>如果没有，就去跳转到服务端给的一个地址。如果有，就继续往下走（next())</p>
</li>
<li>
<p>这个时候服务端会往下面的链接（https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect来获取code）上跳转，去引导用户去点击授权，用户授权之后就会重定向到 redirect_uri（服务端的地址）</p>
</li>
<li>
<p>利用 code 获取 openid 之后(服务端去做)，服务端会跳转到前端页面(带上openid)</p>
</li>
</ul>
<p>下面作为了解：</p>
<p>微信授权使用的是 OAuth2.0授权方式。主要有以下简略的步骤：<br>
第一步：用户同意授权，获取 code<br>
　　第二步：通过 code获取网页授权access_token<br>
　　第三步：刷新access_token（如果需要）<br>
　　第四步：拉取用户信息(需scope为 snsapi_userinfo)</p>
<h3 id="下面来具体api表示下怎么获取的-code-和-openid-吧">下面来具体api表示下怎么获取的 code 和 openid 吧</h3>
<h3 id="一获取code">一：获取code:</h3>
<p>通过https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect来获取code<br>
参数：<br>
APPID：应用唯一标识<br>
redirect_uri：授权后重定向的回调链接地址，用户同意后，code 会自动添加到后面。（请使用urlEncode对链接进行处理 （$url = urlencode('')） ）<br>
scope：是应用授权作用域 （一般有两种：一种是静默方式（snsapi_base); 一种是非静默方式（snsapi_userinfo），需要用户去手动同意才能获取用户信息）</p>
<p>微信中尤其提醒：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问</p>
<p>** code 是微信自动生成的。并且放在redirect_uri（重定向后的回调链接地址）后面,并且带上code和state参数</p>
<p>上面提到了 code。那么 code又是什么呢？<br>
code:作为换取 access_token的票据，每次用户授权带上的 code 都不一样。5分钟未被使用自动过期（过期的这里下面有讲）</p>
<h3 id="二然后授权成功之后-得到-code-就用-code-去获取access_token">二：然后授权成功之后。得到 code。就用 code 去获取access_token</h3>
<p>https://api.weixin.qq.com/sns/oauth2/access_token?appid=wx41cb8dbd827a16e9&amp;secret=d4624c36b6795d1d99dcf0547af5443d&amp;code=00137323023ab55775be09d6d8e75ffA&amp;grant_type=authorization_code<br>
参数说明：<br>
appid：应用唯一标识<br>
code：上一步已经获取到了<br>
secret：应用密钥AppSecret，在微信开放平台提交应用审核通过后获得</p>
<p>正确的返回<br>
&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, // 接口调用凭证 &quot;expires_in&quot;:7200, // access_token接口调用凭证超时时间 &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, // 用户刷新access_token &quot;openid&quot;:&quot;OPENID&quot;, // 授权用户唯一标识 &quot;scope&quot;:&quot;SCOPE&quot;, // 作用域 等</p>
<h3 id="三通过access_token-openid获取用户信息">三：通过access_token、openid获取用户信息</h3>
<p>https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID<br>
就会得到用户的信息：<br>
得到参数：<br>
openid：用户的唯一标识<br>
nickname：用户昵称<br>
sex： 男女<br>
等。。。<br>
特别注意：<br>
1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）； 2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为； 3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。 建议将secret、用户数据（如access_token）放在App云端服务器，由云端中转接口调用请求。</p>
<h3 id="最后总结下详细的步骤">最后总结下详细的步骤：</h3>
<ul>
<li>1．用户关注微信公众账号。</li>
<li>2．微信公众账号提供用户请求授权页面URL。</li>
<li>3．用户点击授权页面URL，将向服务器发起请求</li>
<li>4．服务器询问用户是否同意授权给微信公众账号(scope为snsapi_base时无此步骤)</li>
<li>5．用户同意(scope为snsapi_base时无此步骤)</li>
<li>6．服务器将CODE通过回调传给微信公众账号</li>
<li>7．微信公众账号获得CODE</li>
<li>8．微信公众账号通过CODE向服务器请求Access Token</li>
<li>9．服务器返回Access Token和OpenID给微信公众账号</li>
<li>10．微信公众账号通过Access Token向服务器请求用户信息(scope为snsapi_base时无此步骤)</li>
<li>11．服务器将用户信息回送给微信公众账号(scope为snsapi_base时无此步骤)</li>
</ul>
<p>公众号链接(官网更权威)：<br>
https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</p>
<p>https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Airbnb CSS / Sass 规范指南]]></title>
        <id>https://weidadeda.github.io/post/airbnb-css-sass-gui-fan-zhi-nan</id>
        <link href="https://weidadeda.github.io/post/airbnb-css-sass-gui-fan-zhi-nan">
        </link>
        <updated>2022-01-05T08:18:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><em>用更合理的方式写 CSS 和 Sass</em> 翻译自<a href="https://github.com/airbnb/css">Airbnb CSS / Sass Styleguide</a></p>
</blockquote>
<h3 id="术语">术语</h3>
<h4 id="规则声明">规则声明</h4>
<p>我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子：</p>
<pre><code class="language-css">.listing {
  font-size: 18px;
  line-height: 1.2;
}
</code></pre>
<h4 id="选择器">选择器</h4>
<p>在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子：</p>
<pre><code class="language-css">.my-element-class {
  /* ... */
}

[aria-hidden] {
  /* ... */
}
</code></pre>
<h4 id="属性">属性</h4>
<p>最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子：</p>
<pre><code class="language-css">/* some selector */ {
  background: #f1f1f1;
  color: #333;
}
</code></pre>
<h3 id="css格式">CSS格式</h3>
<ul>
<li>使用 2 个空格作为缩进。</li>
<li>类名建议使用破折号代替驼峰法。如果你使用 BEM，也可以使用下划线（参见下面的 <a href="#oocss-and-bem">OOCSS 和 BEM</a>）。</li>
<li>不要使用 ID 选择器。</li>
<li>在一个规则声明中应用了多个选择器时，每个选择器独占一行。</li>
<li>在规则声明的左大括号 { 前加上一个空格。</li>
<li>在属性的冒号 : 后面加上一个空格，前面不加空格。</li>
<li>规则声明的右大括号 } 独占一行。</li>
<li>规则声明之间用空行分隔开。</li>
</ul>
<h4 id="bad">Bad</h4>
<pre><code class="language-css">.avatar{
    border-radius:50%;
    border:2px solid white; }
.no, .nope, .not_good {
    // ...
}
#lol-no {
  // ...
}
</code></pre>
<h4 id="good">Good</h4>
<pre><code class="language-css">.avatar {
  border-radius: 50%;
  border: 2px solid white;
}

.one,
.selector,
.per-line {
  // ...
}
</code></pre>
<h3 id="注释">注释</h3>
<ul>
<li>建议使用行注释 (在 Sass 中是 //) 代替块注释。</li>
<li>建议注释独占一行。避免行末注释。</li>
<li>给没有自注释的代码写上详细说明，比如：<br>
为什么用到了 z-index<br>
兼容性处理或者针对特定浏览器的 hack</li>
</ul>
<h3 id="id-选择器">ID 选择器</h3>
<p>在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高优先级，而且 ID 选择器是不可重用的。</p>
<p>想要了解关于这个主题的更多内容，参见 <a href="https://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/">CSS Wizardry</a> 的文章，文章中有关于如何处理优先级的内容。</p>
<h3 id="javascript-钩子">JavaScript 钩子</h3>
<p>避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。</p>
<p>我们推荐在创建用于特定 JavaScript 的类名时，添加 .js- 前缀：</p>
<pre><code class="language-html">&lt;button class=&quot;btn btn-primary js-request-to-book&quot;&gt;Request to Book&lt;/button&gt;
</code></pre>
<h3 id="边框">边框</h3>
<p>在定义无边框样式时，使用 0 代替 none。</p>
<h4 id="bad-2">Bad</h4>
<pre><code class="language-css">.foo {
  border: none;
}
</code></pre>
<h4 id="good-2">Good</h4>
<pre><code class="language-css">.foo {
  border: 0;
}
</code></pre>
<h3 id="sass">Sass</h3>
<p>语法<br>
使用 .scss 的语法，不使用 .sass 原本的语法。<br>
CSS 和 @include 声明按照以下逻辑排序（参见下文）</p>
<pre><code class="language-html">&lt;a name=&quot;ordering-of-property-declarations&quot;&gt;&lt;/a&gt;
</code></pre>
<h3 id="属性声明的排序">属性声明的排序</h3>
<h4 id="属性声明">属性声明</h4>
<p>首先列出除去 @include 和嵌套选择器之外的所有属性声明。</p>
<p><code>.btn-green { background: green; font-weight: bold; // ... }</code></p>
<h4 id="include-声明">@include 声明</h4>
<p>紧随后面的是 @include，这样可以使得整个选择器的可读性更高。</p>
<p><code>.btn-green { background: green; font-weight: bold; @include transition(background 0.5s ease); // ... }</code></p>
<h4 id="嵌套选择器">嵌套选择器</h4>
<p>_如果有必要_用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。</p>
<p>` .btn { background: green; font-weight: bold; @include transition(background 0.5s ease);</p>
<p>.icon { margin-right: 10px; } } `</p>
<h3 id="变量">变量</h3>
<p>变量名应使用破折号（例如 $my-variable）代替 camelCased 和 snake_cased 风格。对于仅用在当前文件的变量，可以在变量名之前添加下划线前缀（例如 $_my-variable）。</p>
<h3 id="mixins">Mixins</h3>
<p>为了让代码遵循 DRY 原则（Don't Repeat Yourself）、增强清晰性或抽象化复杂性，应该使用 mixin，这与那些命名良好的函数的作用是异曲同工的。虽然 mixin 可以不接收参数，但要注意，假如你不压缩负载（比如通过 gzip），这样会导致最终的样式包含不必要的代码重复。</p>
<h3 id="扩展指令">扩展指令</h3>
<p>应避免使用 @extend 指令，因为它并不直观，而且具有潜在风险，特别是用在嵌套选择器的时候。即便是在顶层占位符选择器使用扩展，如果选择器的顺序最终会改变，也可能会导致问题。（比如，如果它们存在于其他文件，而加载顺序发生了变化）。其实，使用 @extend 所获得的大部分优化效果，gzip 压缩已经帮助你做到了，因此你只需要通过 mixin 让样式表更符合 DRY 原则就足够了。</p>
<h3 id="嵌套选择器-2">嵌套选择器</h3>
<p>请不要让嵌套选择器的深度超过 3 层！</p>
<pre><code class="language-sass">.page-container {
  .content {
    .profile {
      // STOP!
    }
  }
}
</code></pre>
<p>当遇到以上情况的时候，你也许是这样写 CSS 的：</p>
<ul>
<li>与 HTML 强耦合的（也是脆弱的）<em>—或者—</em></li>
<li>过于具体（强大）<em>—或者—</em></li>
<li>没有重用</li>
</ul>
<h5 id="再说一遍-永远不要嵌套-id-选择器-永远不要嵌套-id-选择器-永远不要嵌套-id-选择器">再说一遍: 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！</h5>
<p>如果你始终坚持要使用 ID 选择器（劝你三思），那也不应该嵌套它们。如果你正打算这么做，你需要先重新检查你的标签，或者指明原因。如果你想要写出风格良好的 HTML 和 CSS，你是不应该这样做的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端常用的命名规范]]></title>
        <id>https://weidadeda.github.io/post/qian-duan-chang-yong-de-ming-ming-gui-fan</id>
        <link href="https://weidadeda.github.io/post/qian-duan-chang-yong-de-ming-ming-gui-fan">
        </link>
        <updated>2021-12-20T11:20:48.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>目录 全小写中划线</li>
<li>文件 全小写中划线</li>
<li>类名 大驼峰</li>
<li>变量 小驼峰</li>
<li>常量 全大写 下划线风格</li>
<li>特殊变量</li>
<li>css类名 小写中划线</li>
<li>单词拼音不允许</li>
<li>复杂函数和公用函数必须加注释</li>
<li>函数的参数最多不能超过三个</li>
<li>url 全小写 中划线</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[瀑布流计算js源码]]></title>
        <id>https://weidadeda.github.io/post/pu-bu-liu-ji-suan-js-yuan-ma</id>
        <link href="https://weidadeda.github.io/post/pu-bu-liu-ji-suan-js-yuan-ma">
        </link>
        <updated>2021-11-24T14:38:44.000Z</updated>
        <content type="html"><![CDATA[<p>遇到问题时的解决方法及使用注意事项：</p>
<p>1、下拉刷新会导致瀑布流顺序错乱，重新new一下瀑布流即可。</p>
<p>2、图片宽高必须要让服务端返，前端去获取数据太多会导致性能非常慢。</p>
<p>3、dom加载时获取小程序的某个dom的宽度（列宽）为空，放在wx.nextTick中即可。还获取不到，就需要看自己要获取的dom是否已加载。</p>
<p>4、此代码抗揍，如果出问题先从自身找问题，再仔细阅读一遍此代码。</p>
<pre><code>class Waterfall {
  constructor(options) {
    this.initWaterfall(options);
  }
    /**
   * 初始化瀑布流
   * @param {Object} options
   * @param {Array&lt;Object&gt;} options.columns {width} - 此参数主要定义每列的宽度
   */
  initWaterfall(options) {
    this.columns = options.columns;
    this.formatedData = [];
    for (let column of options.columns) {
      this.formatedData.push({
        width: column.width,
        height: 0
      });
    }
  }
  imageUrlFeild = 'imageUrl'
 
  /**
   * 格式化从数据中获取图片url的方法
   * @param {Function | String | Number} fn - 若为函数，则需要返回瀑布流每项数据对应的图片字段
   */
 
  formatGetImageUrlMethod(fn) {
    this.imageUrlFeild = typeof fn === 'function' ? fn() : fn
  }
 
  /**
   * 向瀑布流中填充数据
   * @param {Object}  resource - 单个瀑布流项的数据源
   */
  getResourceInfo(resource) {
    const _self = this
    return new Promise(resolve =&gt; {
      if (resource[_self.imageUrlFeild]) {
        // getImageInfo方法在小程序中使用，h5中暂未测试，不过一般都是让服务端直接返回图片宽高，所以这个方法一般用不到，如果需要用到的话，必须加一层loading阻止用户操作
        wx.getImageInfo({
          src: resource[_self.imageUrlFeild],
          success(res) {
            resolve(res)
          },
          fail() {
            resolve()
          }
        })
      } else {
        resolve()
      }
    })
  }
 
  /**
   * 向瀑布流中补充数据
   * @param {Boolean} extraVal 瀑布流的卡片中图片之外的内容
   * @param {Array&lt;resource&gt;}  resources
   */
 
  async addResources(resources, extraVal) {
    // let promiseArray = []
    let newResourcesArray = Array.apply(null, Array(this.columns.length)).map(
      _ =&gt; []
    )
    for (let resource of resources) {
      // promiseArray.push(this.getResourceInfo(resource))
      // let imageInfo
      // imageInfo = await this.getResourceInfo(resource)
      const width = Number(resource.width) || 100;
      const height = Number(resource.height) || 100;
      // 获取最短列的索引
      const index = this.getShortestColumn();
      // 卡片宽度
      const imageWidth = this.formatedData[index].width;
      // 附加的卡片高度在这里是写死的，每个项目会有不同高度
      const extraHeight = extraVal ? extraVal : 0;
      // 获取卡片高度
      const cardHeight = imageWidth / (width / height) + extraHeight;
      // 当前列总高度
      this.formatedData[index].height += cardHeight;
      // 返回卡片高度
      resource.cardHeight = cardHeight;
      // 返回图片高度
      resource.computedHeight = cardHeight - extraVal;
      // 返回当前列的数组
      newResourcesArray[index].push(resource);
    }
    return newResourcesArray
  }
 
  /**
   * 最重要的地方
   * 获取当前数据中填充最短的列
   * 返回最短列的索引
   */
  getShortestColumn() {
    let minHeight = Infinity
    let minHeightColumnIndex = 0
    for (let index = this.formatedData.length - 1; index &gt; -1; index--) {
      //从后往前遍历，防止每列的高度相同的情况
      const height = this.formatedData[index].height
      if (height &lt;= minHeight) {
        minHeightColumnIndex = index
        minHeight = height
      }
    }
    return minHeightColumnIndex
  }
}
 
export default Waterfall;
 
 
// 例：双列瀑布流
let newList = new Waterfall({
      columns: [
        {
          width: 列宽
        },
        {
          width: 列宽
        }
      ]
    });
newList.addResources(lists, 卡片内除图片的额外高度).then(res =&gt; {});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Taro 小程序直播组件 LivePlayer 注意事项]]></title>
        <id>https://weidadeda.github.io/post/taro-xiao-cheng-xu-zhi-bo-zu-jian-liveplayer-zhu-yi-shi-xiang</id>
        <link href="https://weidadeda.github.io/post/taro-xiao-cheng-xu-zhi-bo-zu-jian-liveplayer-zhu-yi-shi-xiang">
        </link>
        <updated>2021-11-15T13:49:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-直播组件优先开通实时音频和视频管理后台申请对应的证书">1、直播组件优先开通实时音频和视频（管理后台），申请对应的证书</h3>
<h3 id="2-直播组件需要做系统权限验证麦克风和相机引导用户打开权限不然部分手机加载失败-insertliveplayerfailaccess-denied-因为权限有三个状态undefined-denied-authorizedauthorized代表系统权限已开">2、直播组件需要做【系统】权限验证，（麦克风和相机）,引导用户打开权限，不然部分手机加载失败（ insertLivePlayer:fail:access denied） 因为权限有三个状态(undefined、denied、authorized)，authorized代表系统权限已开</h3>
<pre><code>export const getSystemInfo = (keys: Tkey[], content = '') =&gt; {
  return new Promise((resolve) =&gt; {
    const systemInfo = wx.getAppAuthorizeSetting();
    console.log('system', systemInfo);
    if (!systemInfo) {
      return resolve({ code: -1, msg: '获取系统权限失败~' });
    }
    keys.forEach((item) =&gt; {
      if (systemInfo[item] !== 'authorized') {
        Taro.showModal({
          content,
          success: (res) =&gt; {
            if (res.confirm) {
              wx.openAppAuthorizeSetting({
                success: () =&gt; {
                  return resolve({ code: 100, msg: '打开系统授权页成功~' });
                },
                fail: () =&gt; {
                  return resolve({ code: 101, msg: '打开系统授权页失败~' });
                }
              });
            } else {
              return resolve({ code: 403, msg: '用户点击取消~' });
            }
          }
        });
        return resolve({ code: 401, msg: '权限没打开~' });
      }
    });
    return resolve({ code: 0, msg: '用户已开通对应权限~' });
  });
};
 
// 获取系统权限
      const res: any = await getSystemInfo(
        ['cameraAuthorized', 'microphoneAuthorized'],
        '检测到您没有打开麦克风和相机权限，部分功能将没法使用~'
      );
</code></pre>
<h3 id="3-直播组件同层渲染在全屏下失效需要单独处理全屏做coverviewcoverimage做原生覆盖能力处理不是全屏就同层渲染全屏处理时候顶层容器和直接子节点需要设置-visiblityvisiblepositionrelativez-index99999-必须得处理不然android-的coverview覆盖不了原生直播组件">3、直播组件同层渲染在全屏下失效，需要单独处理，全屏做CoverView\CoverImage做原生覆盖能力处理，不是全屏就同层渲染，全屏处理时候顶层容器和直接子节点需要设置 visiblity:visible;position:relative;z-index:99999; 必须得处理，不然android 的CoverView覆盖不了原生直播组件。</h3>
<pre><code>.cover-main{
    position: absolute;
    visibility: visible;
    z-index: 999999;
}
 
&lt;CoverView className={style['cover-main']}&gt;
                &lt;CoverView className={style['cover-main']}&gt;
                  &lt;CoverView className={style['live-control']} onClick={showTips}&gt;&lt;/CoverView&gt;
 
        {fullScreenFlag &amp;&amp; (
        &lt;&gt;
            {/*广告*/}
            &lt;Curtain /&gt;

            {/* 封面*/}
            {startStatus === false ? (
            &lt;CoverView className={style.cannot_see}&gt;
                &lt;CoverImage className={style.cannot_see_img} src={readyImg}&gt;&lt;/CoverImage&gt;
            &lt;/CoverView&gt;
            ) : teachStatus === false ? (
            &lt;CoverView className={style.cannot_see}&gt;
                &lt;CoverImage className={style.cannot_see_img} src={outImg}&gt;&lt;/CoverImage&gt;
            &lt;/CoverView&gt;
            ) : null}

            {/* 倒计时*/}
            {time &gt;= 1800 ? &lt;CountDown time={time} /&gt; : null}
        &lt;/&gt;
        )}

        {/*控制*/}
        &lt;CoverView
        className={`${style.control} ${tips ? style['up-ani'] : style['down-ani']}`}
        &gt;
        &lt;CoverView className={style.info}&gt;
            &lt;CoverView&gt;直播&lt;/CoverView&gt;
        &lt;/CoverView&gt;
        &lt;CoverView className={style['full-screen']} onClick={handleFullScreen}&gt;
            &lt;CoverImage
            className={style.icon}
            src={fullScreenFlag ? tuichuquanping : quanping}
            &gt;&lt;/CoverImage&gt;
            &lt;CoverView&gt;{fullScreenFlag ? '小屏播放' : '全屏播放'}&lt;/CoverView&gt;
        &lt;/CoverView&gt;
        &lt;/CoverView&gt;
    &lt;/CoverView&gt;
    &lt;/CoverView&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用yeoman开发一个自己的项目脚手架]]></title>
        <id>https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia</id>
        <link href="https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia">
        </link>
        <updated>2021-10-19T12:37:02.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://weidadeda.github.io/post-images/1644219568486.gif" alt="" loading="lazy"><br>
上面是一个使用脚手架来初始化项目的典型例子。<br>
随着前端工程化的理念不断深入，越来越多的人选择使用脚手架来从零到一搭建自己的项目。其中大家最熟悉的就是create-react-app和vue-cli，它们可以帮助我们初始化配置、生成项目结构、自动安装依赖，最后我们一行指令即可运行项目开始开发，或者进行项目构建（build）。<br>
这些脚手架提供的都是普遍意义上的最佳实践，但是我在开发中发现，随着业务的不断发展，必然会出现需要针对业务开发的实际情况来进行调整。例如：</p>
<ol>
<li>
<p>项目架构的配置<br>
a. webpack/gulp的配置<br>
ⅰ. style/less/sass的选择和处理配置。<br>
ⅱ. Typescript和JavaScript的loader和babel的配置，比如babel-loader和tsc。<br>
ⅲ. 图片的配置，比如需要file-loader或者url-loader。<br>
ⅳ. 静态资源的配置。<br>
ⅴ. 企业内部，真对于某些特定功能的webpack-loader/webpack-plugin，比如打包完图片上传。<br>
b. 是否内置一些第三方框架供上手使用，比如Element-UI，Antd等。<br>
c. 项目的路由的设计和配置。<br>
d. 项目目录结构的设计和配置。<br>
e. 项目通用功能的有关代码，比如登陆和欢迎页等。<br>
f.通过调整插件与配置实现 Webpack 打包性能优化<br>
g.针对生产环境做的单独处理</p>
</li>
<li>
<p>项目开发中的配置<br>
a. eslint。<br>
b. style-lint。<br>
c. prettier。<br>
d. 单元测试jest或者其他单元测试框架。<br>
e. 项目文档的自动生成，比如docz。<br>
f. git相关的，比如git提交的校验，生成changelog<br>
g. npm相关，除非是开发npm包，否则npm相关的不是那么重要<br>
h. 与开发有关的工具，比如打包构建结果的包分析、比如相似代码自动生成</p>
</li>
<li>
<p>项目上线脚本，这个应该是可选项？更优的方法应该是使用内部的例如发布平台之类的工具完成，或者通过jekins或者gitlab-ci进行自动化发布，回滚等操作。上线发布回滚的动作可以完全交给非开发人员完成。<br>
a. 比如由nodejs编写的上线脚本，或者是用于上线的shell脚本。<br>
b. gitlab-ci的配置文件</p>
</li>
</ol>
<p>……<br>
总而言之，随着业务发展，我们往往会沉淀出一套更“个性化”的业务方案。这时候我们最直接的做法就是开发出一个该方案的脚手架来，以便今后能复用这些最佳实践与方案。<br>
那么就需要使用一个工具来帮我们做这些处理，我们使用的就是yoman。<a href="https://yeoman.io/">官网地址</a><br>
我们可以使用yeoman和yeoman的generator来更加便捷实现我们的脚手架，可以说基本是零成本。<br>
先说说Yeoman是什么，它想做什么？<br>
Yeamon帮助你快速的开展一个项目工程，提供最佳实践和工具，来让你保持高效率编码。</p>
<p>他们自己提供了一个构建生态系统，主要通过‘yo’这个命令来构建一个完整的项目或者项目的一部分。</p>
<p>通过官方的生成器，他们建立了一个Yeoman的工作流，这个流是由一个强大的,固定的客户端组建，包含工具和框架帮助开发者快速建立牛逼的web应用。他们尽量提供了开发者所需的东西。比如先下载对应模版项目，然后下载模版项目中的package.json中的包</p>
<p>作为良好文档和深入思考构建过程的思想者，Yeoman包含了检测（静态检测）、测试以及压缩等等一系列工具，让开发者能够更加专注于思考解决方案。</p>
<h3 id="如何使用">如何使用：</h3>
<p>1、npm install -g yo //权限不够，请加上 sudo，一般来说mac都需要。<br>
安装完成之后，你就拥有了1个命令 -- yo 可以选择自定义的，也可以搜索你想要的现成的，这里我们选择自己的。 官网提供的地址：http://yeoman.io/generators/<br>
那我们开始编写一个自己的generators。<br>
2、开发自己的generator<br>
创建项目<br>
全局安装generator-generator，然后使用创建项目，根据提示输出我们的generator项目的名字，yeoman规定项目名字必须以generator开头，所以我们可以选择generator-xxx作为我们的项目名<br>
npm i -g generator-generator<br>
yo generator<br>
创建好项目之后，我们可以发现已经自动为我们配置好了eslint，jest，husky</p>
<p>我们主要需要修改的代码位于generators/app内<br>
● index.js定义了我们使用此generator时的一些操作配置项<br>
● templates内存放的是要生成的项目的项目模板，项目模板也可以放在git上，然后通过download-git-repo下载到本地<br>
验证我们创建的项目</p>
<ol>
<li>在当前项目执行npm link使其被链接到全局</li>
<li>然后找一个目录，终端执行yo，此时便可以发现我们的generator已经出现在了选择列表中。然后选择我们的generator运行即可。等待完成，会发现成功的创建了一个叫做dummyfile.txt的文件夹。<br>
generators/app/index.js<br>
初始化的文件如下。</li>
</ol>
<pre><code>&quot;use strict&quot;;
const Generator = require(&quot;yeoman-generator&quot;);
const chalk = require(&quot;chalk&quot;);
const yosay = require(&quot;yosay&quot;);

module.exports = class extends Generator {
  prompting() {
    // Have Yeoman greet the user.
    this.log(
      yosay(
        `Welcome to the fantastic ${chalk.red(&quot;generator-rc-op&quot;)} generator!`
      )
    );

    const prompts = [
      {
        type: &quot;confirm&quot;,
        name: &quot;someAnswer&quot;,
        message: &quot;Would you like to enable this option?&quot;,
        default: true
      }
    ];

    return this.prompt(prompts).then(props =&gt; {
      // To access props later use this.props.someAnswer;
      this.props = props;
    });
  }

  writing() {
    this.fs.copy(
      this.templatePath(&quot;dummyfile.txt&quot;),
      this.destinationPath(&quot;dummyfile.txt&quot;)
    );
  }

  install() {
    this.installDependencies();
  }
};
</code></pre>
<p>从文件的内容可以看出主要操作是暴露出一个继承自Generator的类，在类的内部定义了部分生命周期方法，供yoeman在适当的时候调用。我们只需要完善这些方法就可以了。</p>
<h3 id="yeoman提供的生命周期如下">yeoman提供的生命周期如下：</h3>
<ol>
<li>initializing：初始化必要的依赖，或者比如检测新版本</li>
<li>prompting：用来处理终端的交互</li>
<li>default：这里指的是自己自定义的方法，而不是名为default的方法，自己定义的方法如果不想被调用，那么需要确保方法名以_为开头。</li>
<li>writing：将经过ejs模板渲染后的内容写入文件系统。</li>
<li>conflicts：勇于解决将文件内容写入文件系统时可能造成的冲突</li>
<li>install：安装项目的依赖，比如npm install 或者 bower install</li>
<li>end：做一些收尾的工作。</li>
</ol>
<p>这些生命周期方法均支持返回Promise来进行异步操作。</p>
<h3 id="内置常用工具">内置常用工具</h3>
<p>终端交互：内置了Inquirer提供终端交互<br>
模板填充：内置了ejs模板<br>
文件操作<br>
● this.fs.copyTpl：用于拷贝并且根据数据使用ejs模板渲染文件。此函数接受三个参数，源文件路径，目标文件路径，传给ejs用于渲染目标问价的数据。<br>
● this.fs.copy：将文件丛源路径复制到目标路径。<br>
● this.destinationPath() ：此函数返回最终生成项目的路径<br>
其他<br>
● this.npmInstall：实现npm isntall</p>
<pre><code>// 部分代码，完整代码见最下方链接
writing() {
    const done = this.async();
    this.log(&quot;⚙  Finish basic configuration.&quot;, chalk.green(&quot;✔&quot;));
    this.log(&quot;📂 Generate the project template and configuration...&quot;);
    let spinner = ora({
      text: `Download the template from ${GIT_BASE}${TPL_REPOSITORY}...`,
      spinner: ORA_SPINNER
    }).start();
    this._downloadTemplate(TPL_REPOSITORY)
      .then(() =&gt; {
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish downloading the template from ${GIT_BASE}${TPL_REPOSITORY}`
        });
        spinner = ora({
          text: `Copy files into the project folder...`,
          spinner: ORA_SPINNER
        }).start();
        const templateRoot = this.destinationPath(this.dirName, &quot;.tmp&quot;);
        this.log(`\n${templateRoot}`, &quot;templateRoot&quot;);
        const resoPath = path.resolve(templateRoot, &quot;../&quot;);
        this.log(resoPath, &quot;resoPath&quot;);
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish copying files into the project folder`
        });
        execSync(`cp -R ${resoPath}/.tmp/* ${resoPath}`, { stdio: &quot;inherit&quot; });
        spinner = ora({
          text: `Clean tmp files and folders...`,
          spinner: ORA_SPINNER
        }).start();
        fs.removeSync(templateRoot);
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish cleaning tmp files and folders`
        });
        // ExecSync(`rm -R ${resoPath}/.tmp`, { stdio: &quot;inherit&quot; });
        // 将新生成的项目的title换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/public/index.html`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/public/index.html`, str);
          }
        );
        // 将新生成的项目的package.json的name换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/package.json`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/package.json`, str);
          }
        );
        done();
      })
      .catch(err =&gt; this.env.error(err));
  }
</code></pre>
<h3 id="其他可能用到的工具">其他可能用到的工具</h3>
<p>● ora：用于创建Spinner，即比如下载模板文件时需要展示的laoding效果。<br>
● chalk：用于打印彩色的信息<br>
● update-notifier<br>
● beeper<br>
● boxen<br>
调试<br>
由于yeoman是通过npm包的形式进行使用的，所以我们可以在我们开发的generator项目的跟目录下，执行npm link 将我们开发的generator链接到全局，这样我们直接使用yo命令查看可以使用的generator，就可以看到我们所开发的generator了，并且是实时生效的</p>
<h3 id="我的代码是在本地的用的npm-link没有上传到github或npm此处贴出其他大佬的项目代码-快动手试一下吧~">我的代码是在本地的，用的npm link，没有上传到github或npm，此处贴出其他大佬的项目代码。快动手试一下吧～</h3>
<p><a href="https://github.com/alienzhou/webpack-kickoff-template">模版完整代码</a>   注意要给ejs写入的空位<br>
<a href="https://github.com/alienzhou/generator-webpack-kickoff">脚手架完整代码</a></p>
<h3 id="参考文章">参考文章：</h3>
<p><a href="https://www.yuque.com/kongdepeng/rgpm60/qrluup">前端自动化工具 - yeoman</a><br>
<a href="https://zhuanlan.zhihu.com/p/66190308">如何快速开发一个自己的项目脚手架？</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C端H5或小程序常见问题总结]]></title>
        <id>https://weidadeda.github.io/post/c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie</id>
        <link href="https://weidadeda.github.io/post/c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie">
        </link>
        <updated>2021-10-13T13:59:28.000Z</updated>
        <content type="html"><![CDATA[<p>开发C端时遇到的一些问题与解决方法，都记录下来，希望对你也有帮助。</p>
<h3 id="1部分机型拍照上传图片旋转问题">1.部分机型拍照上传图片旋转问题：</h3>
<p>直接从图片后面加参数‘?x-oss-process=image/auto-orient,1/resize,m_fixed’（加上参数之后会自动旋转回来，其他参数可参考阿里OSS官方文档https://help.aliyun.com/document_detail/44691.html?spm=a2c4g.11186623.6.1390.750ac1f6HTe92Q）</p>
<h3 id="2swiper3d两边留白效果">2.swiper3D两边留白效果：</h3>
<p>（小程序h5均适用），代码如下，需要注意的是必须给swiper父级元素加overflow-x:hidden</p>
<pre><code>.swiper-container {
  height: 100%;
  width: 600px;
  perspective: 1600px;
  overflow: visible;
  img {
    width: 100%;
    height: 720px;
    border-radius: 20px;
  }
}
.swiper-slide {
  padding: 0 24px;
  box-sizing: border-box;
  text-align: center;
  transition: transform 0.5s;
  transform-origin: 50% 50%;
  transform: scale(0.9);
  &amp;.swiper-slide-active {
    transform: scale(1);
  }
}
</code></pre>
<h3 id="3小程序的跳转十层限制不要一直用navigateto这样属于一直前进如果需要跳转回首页或者其他可以使用relaunch逻辑复杂时可自己写顶部导航栏包括返回按钮">3.小程序的跳转十层限制，不要一直用navigateTo，这样属于一直前进，如果需要跳转回首页或者其他可以使用reLaunch，逻辑复杂时可自己写顶部导航栏包括返回按钮。</h3>
<h3 id="4保存海报到本地推荐一波生成小程序海报的插件非常简单方便">4.保存海报到本地：推荐一波生成小程序海报的插件，非常简单方便</h3>
<p>taro-plugin-canvas (Taro环境使用)与wxa-plugin-canvas（普通小程序使用）<br>
tip:如果遇到非常规的情况，需要手写canvas并且宽高尺寸乘2保证清晰度。</p>
<h3 id="5input光标永远停留在最后">5.input光标永远停留在最后：</h3>
<pre><code>var el = document.getElementById(&quot;IPTname&quot;);
var range = document.createRange();
range.selectNodeContents(el);
range.collapse(false);
var sel = window.getSelection();
sel.removeAllRanges();
sel.addRange(range);
</code></pre>
<h3 id="6小程序获取用户授权用户信息用户定位用户相册访问权限等时需要处理拒绝时的情况-生成海报到自己相册的时候如果用户在授权的时候点击了拒绝如果不兼容拒绝授权则直接生成失败">6.小程序获取用户授权（用户信息/用户定位/用户相册访问权限等）时需要处理拒绝时的情况。生成海报到自己相册的时候如果用户在授权的时候点击了拒绝，如果不兼容拒绝授权则直接生成失败。</h3>
<h3 id="7监听移动端键盘弹出和收起事件">7.监听移动端键盘弹出和收起事件。</h3>
<p>在ios设备上,操作表单输入时,键盘弹出时会把页面顶起来,键盘收起时并不会把页面恢复成原来的样子,造成页面样式错乱,利用focusout和focusin事件,可以间接地监听到键盘的收起和弹出事件,然后操作页面滚动到想要的位置.</p>
<p>focusout触发时机:  当元素即将失去焦点时，focusout 事件被触发。focusout 事件和 blur 事件之间的主要区别在于后者不会冒泡。</p>
<p>focusin触发时机:    当元素即将接收 focus 事件时，focusin 事件被触发。 这个事件和 focus 事件的主要区别在于后者不会冒泡。</p>
<p>监听方式:</p>
<pre><code>let scrollTop = 0
//键盘收起
document.body.addEventListener('focusout',()=&gt;{
   document.body.scrollTop=document.documentElement.scrollTop=scrollTop
})
//键盘弹出
document.body.addEventListener('focusin',()=&gt;{
   scrollTop = document.body.scrollTop || document.documentElement.scrollTop
})
</code></pre>
<h3 id="8移动端代码返回上一页windowlocationback失效">8.移动端代码返回上一页（window.location.back()失效）</h3>
<p>尼玛。。移动端返回上一页有时候用window.location.back()不好使，无解。可以使用window.location.href = document.referrer。</p>
<h3 id="9单页面应用跳转路由之后再次使用echarts时不展示">9.单页面应用跳转路由之后再次使用echarts时不展示</h3>
<p>首次使用不展示，可以延迟加载，但是当路由跳转回来之后延迟都不管用，那么需要在init Echarts之前动态设置容器宽高，并且清空父元素，因为再次回来的时候之前的echarts实例已经是存在的了，可在调试中查看详情。</p>
<h3 id="10-视频黑边问题">10. 视频黑边问题</h3>
<p>给video标签（原生video标签）加一个object-fit:fill属性即可解决。要强调的是，千万不要使用Taro的Video标签，很坑，解决了黑边，全屏时又会导致视频变形，不用object:fill的话也能解决黑边，但是全屏时视频的退出全屏样式又会被覆盖。</p>
<h3 id="11-手机锁屏时倒计时停止">11. 手机锁屏时倒计时停止</h3>
<pre><code>window.addEventListener('visibilitychange',() =&gt; {
   if (
     //hidden为锁屏时或页面不展示时，可重新获取时间开始倒计时。
      document.visibilityState =='hidden'
   ) 
})
</code></pre>
<h3 id="12移动端实现省-市-区-街道四级联动">12.移动端实现省-市-区-街道四级联动</h3>
<p>需求是要实现地区四级联动，但是vant的插件只支持三级地区联动，就很尴尬，只能自己写，但是自己写的话UI与交互体验会很差，所以就想办法去和后端对接。其实很简单，写出来只是提醒大家可以这么实现，减少思考与踩坑的时间。三级联动选择完之后会返回地区编码，eg:Array&lt;{code:'110101',name:'东城区'}&gt;,然后去请求后端的接口将地区编码传过去，就能得到其街道的相关信息，然后简单过滤一下，放在Picker选择器中就可以实现。接下来就可以写业务逻辑了。</p>
<h3 id="13ios内webview中vue项目会出现大块白色遮罩">13.ios内webview中vue项目会出现大块白色遮罩</h3>
<p>问题描述：</p>
<p>A页面——&gt;B页面——&gt;ios自带的返回——&gt;白屏出现(像个魔鬼)——&gt;点击或滑动页面——&gt;问题解决</p>
<p>原因是，经过排查，发现在ios 机器上使用webview 开发Vue项目时候，go history (-1)，无法将body 的高度拉掉，使得遮住，触发轻点击，方可消除该遮罩</p>
<p>解决的理论：用于最重要的html 容器是container，然而因为设置html、body高度是100%，从而造成了 container 撑开父级，但浏览器默认滚动的scroll 并不是 container，而是body，某些因素，造成返回history 后，无法复原（ios 的锅），为此，将 container(app.vue中包裹的div，也可以是#app) 进行了绝对定位，并让它重新成为 scroll 的对象，从而解决问题。</p>
<pre><code>html, body {

 width: 100%;

 height: 100%;
 min-height: 100vh;

 margin: 0;

 padding: 0;

 position: relative;

}

.container {

 width: 100%;

height: 100vh;
 min-height: 100vh;

 background: #fff;

 overflow: scroll;

 -webkit-overflow-scrolling: touch;

 position: absolute;

 left:0;

 top:0;

}
</code></pre>
<h3 id="14在ios上a页面分享朋友圈之后跳转到-b-页面或进行别的操作">14.在ios上A页面分享朋友圈之后，跳转到 B 页面（或进行别的操作）</h3>
<p>注：离开 app的 A 页面去微信，再次回到 app 的时候跳转到 B 页面</p>
<p>visibilitychange：当用户最小化窗口或者切换选项卡的时候，api 就会发送visibilitychange事件，让开发者知道页面状态已更改。你可以检测事件并执行某些操作或行为。</p>
<pre><code>//这个方法在分享被触发的时候执行
initVisibilityChange() {
      if (typeof document.visibilityState != &quot;undefined&quot;) {
        this.visibleChange = &quot;visibilitychange&quot;;
        this.vibibleState = &quot;visibilityState&quot;;
      } else if (
        typeof (document as any).webkitVisibilityState != &quot;undefined&quot;
      ) {
        this.visibleChange = &quot;webkitvisibilitychange&quot;;
        this.vibibleState = &quot;webkitVisibilityState&quot;;
      }
      if (this.visibleChange) {
        document.addEventListener(
          this.visibleChange,
          this.onVisibilityChanged,
          false
        );
      }
    },
      /**
     * 从微信返回app可以在这里面处理事情
     */
    onVisibilityChanged(event: any) {
      var hidden = event.target.webkitHidden;
      if ((document as any)[this.vibibleState] == &quot;visible&quot;) {
          this.goRun(); // 做自己需要的逻辑处理
          this.removeVisibilityChange();
      }
    },
     // 移除app后台监听事件
    removeVisibilityChange() {
      document.removeEventListener(
        this.visibleChange,
        this.onVisibilityChanged,
        false
      );
    },
</code></pre>
<h3 id="15-从vue页面跳转到非vue页面点击返回ios设备上页面数据不刷新">15. 从vue页面跳转到非vue页面，点击返回，ios设备上页面数据不刷新。</h3>
<p>比如A页面定义了一个变量为true，点击跳转到非vue项目页面（php），点击返回，查看这个变量，在安卓上依然为ture，但是在ios上就变成了false。</p>
<p>解决方法：</p>
<pre><code>window.onpageshow=function(e){
　　if(e.persisted) {
　　　　window.location.reload()
　　}
};
</code></pre>
<h3 id="16-app点击自带返回按钮关闭页面以及禁用返回的踩坑记录">16. app点击自带返回按钮关闭页面以及禁用返回的踩坑记录</h3>
<p>http://note.youdao.com/s/4qUINhV0 （比较多，有道云链接发出来，希望对大家有帮助）</p>
<h3 id="17-wxchooseimage方法在安卓与ios上取到的base64格式不一样安卓没有dataimagejpgbase64前缀需要单独处理">17. wx.chooseImage方法在安卓与ios上取到的base64格式不一样，安卓没有data:image/jpg;base64前缀，需要单独处理</h3>
<h3 id="18-手机内h5点击input无法唤起自带键盘可以给input添加click事件手动触发focus事件">18. 手机内h5点击input无法唤起自带键盘：可以给input添加click事件手动触发focus事件。</h3>
<h3 id="19-canvas绘制圆角矩形方法">19. canvas绘制圆角矩形方法</h3>
<pre><code>// x、y、w、h与canvas的rect方法参数相同
//r代表圆角大小，1、2、3、4分别代表上左、上右、下右、下左
function drawRoundRect(ctx, x, y, w, h, r1, r2, r3, r4) {
  ctx.beginPath()
  ctx.moveTo(x + r1, y)
  ctx.arcTo(x + w, y, x + w, y + h, r2)
  ctx.arcTo(x + w, y + h, x, y + h, r3)
  ctx.arcTo(x, y + h, x, y, r4)
  ctx.arcTo(x, y, x + w, y, r1)
  ctx.closePath()
}
</code></pre>
<h3 id="20-post导出文件处理">20. POST导出文件处理</h3>
<ul>
<li>fetch请求方法中，增加类型处理，预设请求传入字段控制，返回为：response.blob()；</li>
<li>返回值处理：</li>
</ul>
<pre><code>const blob = new Blob([data], {type: &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;})
    const a = document.createElement(&quot;a&quot;);
    const filename ={
      exportDetail: '推广人员用户明细',
      exportRecord: '推广人员跟进记录明细'
    }
    a.href = URL.createObjectURL(data)
    a.download = filename[type] // 这里填保存成的文件名
    a.click()
    URL.revokeObjectURL(a.href)
　　 a.remove();
</code></pre>
<h3 id="21-解决css瀑布流只能竖向展示问题非排名或排序时可用">21. 解决css瀑布流只能竖向展示问题(非排名或排序时可用)</h3>
<pre><code class="language-css">// 父元素
column-count: 2;
width: 100%;
// 子元素
break-inside: avoid;
</code></pre>
<pre><code class="language-js">const oldList = lists;
const newList = [].concat(
  ...Array.from(
    oldList.reduce(
      (total, cur, index) =&gt; {
        total[index % 2].push(cur);
        return total;
      },
      { 0: [], 1: [], length: 2 }
    )
  )
);
</code></pre>
<h3 id="22-mpvue的坑">22. mpvue的坑</h3>
<ul>
<li>
<p>一定要遵循mpvue官方文档建议，不要将v-for用在组件上面，或者在v-for内嵌套组件，这样成倍增加wx.setData的数据量</p>
</li>
<li>
<p>在开发上拉加载更多的需求时不要使用小程序原生的scroll-view，直接使用page的onReachBottom事件</p>
</li>
<li>
<p>使用swiper时，不要嵌套过多swiper-item，不要在swiper-item中放入太多元素，有瀑布流等无限加载列表需求时，禁止使用swiper，会导致小程序卡死闪退</p>
</li>
<li>
<p>slot只能使用匿名，具名slot及scoped slot不能使用</p>
</li>
<li>
<p>在定义组件data时，不要将与view无关的数据定义到data中，直接定义到外部，特别时监听scroll事件的时候</p>
</li>
<li>
<p>wx对象的方法全部都挂在mpvue对象下，不需要直接调用wx的方法，特别是在兼容h5的时候</p>
</li>
<li>
<p>button open-type是获取用户手机号等需要绑定事件的类型时，不要使用click.stop或catch:tap，这样会导致不会触发获取用户手机号的回调方法</p>
</li>
<li>
<p>所有组件的created生命周期只在小程序加载的时候统一执行，即使使用了v-if也不能在每次加载组件的时候触发</p>
</li>
<li>
<p>如果要自定义tabbar最好自己实现一个，不要使用原生的custom定义，原生custom限制太多且不能使用mpvue实现</p>
</li>
</ul>
<h3 id="23-taro-hooks子组件条件渲染">23. Taro hooks子组件条件渲染</h3>
<p>若是希望子组件props未被重新赋值的情况下不渲染，使用memo包裹，它实现了class中PureComponent的效果，浅比较了一次。</p>
<pre><code>// 子组件
import Taro, { memo } from &quot;@tarojs/taro&quot;;
import { View } from &quot;@tarojs/components&quot;;
 
const Index = ({ data }) =&gt; {
  return (
    &lt;View&gt;
      {console.log(&quot;Test -- rander2&quot;, data)}
      {data.map((item, index) =&gt; {
        return &lt;View key={index}&gt;{item}&lt;/View&gt;;
      })}
    &lt;/View&gt;
  );
};
 
export default memo(Index);
</code></pre>
<p>若是希望在某些特定的prop改变的时候更新子组件</p>
<pre><code>// utils
import Taro from &quot;@tarojs/taro&quot;;
 
/**
  * 子组件条件渲染
  * @param {Function} render - 要渲染的组件函数
  * @param {Array}  observe - 渲染依据，从props接收的数据key，
  */
export const compareRender = (render, observe=[]) =&gt; {
  const compare = (prevProps, nextProps) =&gt; {
    let keep = true;
    for (let i = 0; i &lt; observe.length; i++) {
      if (prevProps[observe[i]] !== nextProps[observe[i]]) {
        keep = false;
        break;
      }
    }
    return keep;
  };
  return Taro.memo(render, compare);
};
</code></pre>
<pre><code>// 子组件
import Taro from &quot;@tarojs/taro&quot;;
import { View } from &quot;@tarojs/components&quot;;
 
import { compareRender } from &quot;@utils&quot;;
 
const Index = ({ data }) =&gt; {
  return (
    &lt;View&gt;
      {console.log(&quot;Test -- rander&quot;, data)}
      {data.map((item, index) =&gt; {
        return &lt;View key={index}&gt;{item}&lt;/View&gt;;
      })}
    &lt;/View&gt;
  );
};
 
export default compareRender(Index, [&quot;data&quot;]);
</code></pre>
<h3 id="24-关于在dva副作用中多个请求同步执行的优化">24. 关于在dva副作用中多个请求同步执行的优化</h3>
<p>经测试：<br>
const res1 = yield call(req1); const res2 = yield call (req2); const res3 = yield call (req3);  三个请求同步执行，平均耗时大约为120ms，页面加载、数据等待时间较长。<br>
优化：<br>
const [ res1, res2, res3] =  yield [ call(req1), call(req2), call(req3) ],  并发请求，平均耗时大约为20ms</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义一个new方法]]></title>
        <id>https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa</id>
        <link href="https://weidadeda.github.io/post/zi-ding-yi-yi-ge-new-fang-fa">
        </link>
        <updated>2021-10-07T12:36:51.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">MDN new</a></p>
<h3 id="一-new的介绍">一、new的介绍</h3>
<p>new是干什么的：</p>
<blockquote>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
</blockquote>
<p>使用new可以少做四件事情：</p>
<p>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；<br>
不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；<br>
不用 return 临时对象，因为 new 会帮你做；<br>
不要给原型想名字了，因为 new 指定名字为 prototype。</p>
<p>new 关键字会进行如下的操作：</p>
<p>创建一个空的简单JavaScript对象（即{}）；<br>
为步骤1新创建的对象添加属性__proto__，将该属性链接至构造函数的原型对象 ；<br>
将步骤1新创建的对象作为this的上下文 ；<br>
如果该函数没有返回对象，则返回this。<br>
（译注：关于对象的 constructor，参见 Object.prototype.constructor）</p>
<p>创建一个用户自定义的对象需要两步：</p>
<p>通过编写函数来定义对象类型。<br>
通过 new 来创建对象实例。<br>
创建一个对象类型，需要创建一个指定其名称和属性的函数；对象的属性可以指向其他对象，看下面的例子：</p>
<p>当代码 new Foo(...) 执行时，会发生以下事情：</p>
<p>一个继承自 Foo.prototype 的新对象被创建。<br>
使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。<br>
由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）<br>
你始终可以对已定义的对象添加新的属性。例如，car1.color = &quot;black&quot; 语句给 car1 添加了一个新的属性 color，并给这个属性赋值 &quot;black&quot;。但是，这不会影响任何其他对象。要将新属性添加到相同类型的所有对象，你必须将该属性添加到 Car 对象类型的定义中。</p>
<p>你可以使用 Function.prototype 属性将共享属性添加到以前定义的对象类型。这定义了一个由该函数创建的所有对象共享的属性，而不仅仅是对象类型的其中一个实例。下面的代码将一个值为 null 的 color 属性添加到 car 类型的所有对象，然后仅在实例对象 car1 中用字符串 &quot;black&quot; 覆盖该值</p>
<pre><code>function Car() {}
car1 = new Car();
car2 = new Car();

console.log(car1.color);    // undefined

Car.prototype.color = &quot;original color&quot;;
console.log(car1.color);    // original color

car1.color = 'black';
console.log(car1.color);   // black

console.log(car1.__proto__.color) //original color
console.log(car2.__proto__.color) //original color
console.log(car1.color)  // black
console.log(car2.color) // original color
</code></pre>
<blockquote>
<p>如果你没有使用 new 运算符， 构造函数会像其他的常规函数一样被调用， 并不会创建一个对象。在这种情况下， this 的指向也是不一样的。</p>
</blockquote>
<h3 id="二-自定义一个new">二、自定义一个new</h3>
<pre><code>  // 构造器函数
  let Parent = function (name, age) {
    this.name = name;
    this.age = age;
  };
  Parent.prototype.sayName = function () {
    console.log(this.name);
  };
  //自己定义的new方法
  let newMethod = function (Parent, ...rest) {
    // 1.以构造器的prototype属性为原型，创建新对象；
    let child = Object.create(Parent.prototype);
    // 2.将this和调用参数传给构造器执行
    Parent.apply(child, rest);
    // 3.返回第一步的对象
    return child;
  };
  //创建实例，将构造函数Parent与形参作为参数传入
  const child = newMethod(Parent, 'echo', 26);
  child.sayName() //'echo';

  //最后检验，与使用new的效果相同
  child instanceof Parent//true
  child.hasOwnProperty('name')//true
  child.hasOwnProperty('age')//true
  child.hasOwnProperty('sayName')//false
</code></pre>
]]></content>
    </entry>
</feed>