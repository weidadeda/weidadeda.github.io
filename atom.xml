<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://weidadeda.github.io</id>
    <title>Gridea</title>
    <updated>2022-02-10T08:29:31.392Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://weidadeda.github.io"/>
    <link rel="self" href="https://weidadeda.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://weidadeda.github.io/images/avatar.png</logo>
    <icon>https://weidadeda.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Airbnb CSS / Sass 规范指南]]></title>
        <id>https://weidadeda.github.io/post/airbnb-css-sass-gui-fan-zhi-nan</id>
        <link href="https://weidadeda.github.io/post/airbnb-css-sass-gui-fan-zhi-nan">
        </link>
        <updated>2022-02-10T08:18:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><em>用更合理的方式写 CSS 和 Sass</em> 翻译自<a href="https://github.com/airbnb/css">Airbnb CSS / Sass Styleguide</a></p>
</blockquote>
<h3 id="术语">术语</h3>
<h4 id="规则声明">规则声明</h4>
<p>我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子：</p>
<pre><code class="language-css">.listing {
  font-size: 18px;
  line-height: 1.2;
}
</code></pre>
<h4 id="选择器">选择器</h4>
<p>在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子：</p>
<pre><code class="language-css">.my-element-class {
  /* ... */
}

[aria-hidden] {
  /* ... */
}
</code></pre>
<h4 id="属性">属性</h4>
<p>最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子：</p>
<pre><code class="language-css">/* some selector */ {
  background: #f1f1f1;
  color: #333;
}
</code></pre>
<h3 id="css格式">CSS格式</h3>
<ul>
<li>使用 2 个空格作为缩进。</li>
<li>类名建议使用破折号代替驼峰法。如果你使用 BEM，也可以使用下划线（参见下面的 <a href="#oocss-and-bem">OOCSS 和 BEM</a>）。</li>
<li>不要使用 ID 选择器。</li>
<li>在一个规则声明中应用了多个选择器时，每个选择器独占一行。</li>
<li>在规则声明的左大括号 { 前加上一个空格。</li>
<li>在属性的冒号 : 后面加上一个空格，前面不加空格。</li>
<li>规则声明的右大括号 } 独占一行。</li>
<li>规则声明之间用空行分隔开。</li>
</ul>
<h4 id="bad">Bad</h4>
<pre><code class="language-css">.avatar{
    border-radius:50%;
    border:2px solid white; }
.no, .nope, .not_good {
    // ...
}
#lol-no {
  // ...
}
</code></pre>
<h4 id="good">Good</h4>
<pre><code class="language-css">.avatar {
  border-radius: 50%;
  border: 2px solid white;
}

.one,
.selector,
.per-line {
  // ...
}
</code></pre>
<h3 id="注释">注释</h3>
<ul>
<li>建议使用行注释 (在 Sass 中是 //) 代替块注释。</li>
<li>建议注释独占一行。避免行末注释。</li>
<li>给没有自注释的代码写上详细说明，比如：<br>
为什么用到了 z-index<br>
兼容性处理或者针对特定浏览器的 hack</li>
</ul>
<h3 id="id-选择器">ID 选择器</h3>
<p>在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高优先级，而且 ID 选择器是不可重用的。</p>
<p>想要了解关于这个主题的更多内容，参见 <a href="https://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/">CSS Wizardry</a> 的文章，文章中有关于如何处理优先级的内容。</p>
<h3 id="javascript-钩子">JavaScript 钩子</h3>
<p>避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。</p>
<p>我们推荐在创建用于特定 JavaScript 的类名时，添加 .js- 前缀：</p>
<pre><code class="language-html">&lt;button class=&quot;btn btn-primary js-request-to-book&quot;&gt;Request to Book&lt;/button&gt;
</code></pre>
<h3 id="边框">边框</h3>
<p>在定义无边框样式时，使用 0 代替 none。</p>
<h4 id="bad-2">Bad</h4>
<pre><code class="language-css">.foo {
  border: none;
}
</code></pre>
<h4 id="good-2">Good</h4>
<pre><code class="language-css">.foo {
  border: 0;
}
</code></pre>
<h3 id="sass">Sass</h3>
<p>语法<br>
使用 .scss 的语法，不使用 .sass 原本的语法。<br>
CSS 和 @include 声明按照以下逻辑排序（参见下文）</p>
<pre><code class="language-html">&lt;a name=&quot;ordering-of-property-declarations&quot;&gt;&lt;/a&gt;
</code></pre>
<h3 id="属性声明的排序">属性声明的排序</h3>
<h4 id="属性声明">属性声明</h4>
<p>首先列出除去 @include 和嵌套选择器之外的所有属性声明。</p>
<p><code>.btn-green { background: green; font-weight: bold; // ... }</code></p>
<h4 id="include-声明">@include 声明</h4>
<p>紧随后面的是 @include，这样可以使得整个选择器的可读性更高。</p>
<p><code>.btn-green { background: green; font-weight: bold; @include transition(background 0.5s ease); // ... }</code></p>
<h4 id="嵌套选择器">嵌套选择器</h4>
<p>_如果有必要_用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。</p>
<p>` .btn { background: green; font-weight: bold; @include transition(background 0.5s ease);</p>
<p>.icon { margin-right: 10px; } } `</p>
<h3 id="变量">变量</h3>
<p>变量名应使用破折号（例如 $my-variable）代替 camelCased 和 snake_cased 风格。对于仅用在当前文件的变量，可以在变量名之前添加下划线前缀（例如 $_my-variable）。</p>
<h3 id="mixins">Mixins</h3>
<p>为了让代码遵循 DRY 原则（Don't Repeat Yourself）、增强清晰性或抽象化复杂性，应该使用 mixin，这与那些命名良好的函数的作用是异曲同工的。虽然 mixin 可以不接收参数，但要注意，假如你不压缩负载（比如通过 gzip），这样会导致最终的样式包含不必要的代码重复。</p>
<h3 id="扩展指令">扩展指令</h3>
<p>应避免使用 @extend 指令，因为它并不直观，而且具有潜在风险，特别是用在嵌套选择器的时候。即便是在顶层占位符选择器使用扩展，如果选择器的顺序最终会改变，也可能会导致问题。（比如，如果它们存在于其他文件，而加载顺序发生了变化）。其实，使用 @extend 所获得的大部分优化效果，gzip 压缩已经帮助你做到了，因此你只需要通过 mixin 让样式表更符合 DRY 原则就足够了。</p>
<h3 id="嵌套选择器-2">嵌套选择器</h3>
<p>请不要让嵌套选择器的深度超过 3 层！</p>
<pre><code class="language-sass">.page-container {
  .content {
    .profile {
      // STOP!
    }
  }
}
</code></pre>
<p>当遇到以上情况的时候，你也许是这样写 CSS 的：</p>
<ul>
<li>与 HTML 强耦合的（也是脆弱的）<em>—或者—</em></li>
<li>过于具体（强大）<em>—或者—</em></li>
<li>没有重用</li>
</ul>
<h5 id="再说一遍-永远不要嵌套-id-选择器-永远不要嵌套-id-选择器-永远不要嵌套-id-选择器">再说一遍: 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！ 永远不要嵌套 ID 选择器！</h5>
<p>如果你始终坚持要使用 ID 选择器（劝你三思），那也不应该嵌套它们。如果你正打算这么做，你需要先重新检查你的标签，或者指明原因。如果你想要写出风格良好的 HTML 和 CSS，你是不应该这样做的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端常用的命名规范]]></title>
        <id>https://weidadeda.github.io/post/qian-duan-chang-yong-de-ming-ming-gui-fan</id>
        <link href="https://weidadeda.github.io/post/qian-duan-chang-yong-de-ming-ming-gui-fan">
        </link>
        <updated>2022-02-10T08:15:48.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>目录 全小写中划线</li>
<li>文件 全小写中划线</li>
<li>类名 大驼峰</li>
<li>变量 小驼峰</li>
<li>常量 全大写 下划线风格</li>
<li>特殊变量</li>
<li>css类名 小写中划线</li>
<li>单词拼音不允许</li>
<li>复杂函数和公用函数必须加注释</li>
<li>函数的参数最多不能超过三个</li>
<li>url 全小写 中划线</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[短信短链接唤起APP]]></title>
        <id>https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app</id>
        <link href="https://weidadeda.github.io/post/duan-xin-duan-lian-jie-huan-qi-app">
        </link>
        <updated>2022-02-10T07:59:08.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644479995097.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信公众号获取openid等一系列流程]]></title>
        <id>https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng</id>
        <link href="https://weidadeda.github.io/post/wei-xin-gong-zhong-hao-huo-qu-openid-deng-yi-xi-lie-liu-cheng">
        </link>
        <updated>2022-02-10T07:49:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="先说下为什么要获取-openid">先说下为什么要获取 openid?</h3>
<p>因为用户管理类接口可以通过openid可以获取用户的一些信息的.</p>
<h3 id="说到-openid-必须先说微信授权登录的过程">说到 openid 必须先说微信授权登录的过程</h3>
<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644479416142.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>前端需要在进入路由的是beaforEach的时候，先去判断链接上有没有 openid</p>
</li>
<li>
<p>如果没有，就去跳转到服务端给的一个地址。如果有，就继续往下走（next())</p>
</li>
<li>
<p>这个时候服务端会往下面的链接（https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect来获取code）上跳转，去引导用户去点击授权，用户授权之后就会重定向到 redirect_uri（服务端的地址）</p>
</li>
<li>
<p>利用 code 获取 openid 之后(服务端去做)，服务端会跳转到前端页面(带上openid)</p>
</li>
</ul>
<p>下面作为了解：</p>
<p>微信授权使用的是 OAuth2.0授权方式。主要有以下简略的步骤：<br>
第一步：用户同意授权，获取 code<br>
　　第二步：通过 code获取网页授权access_token<br>
　　第三步：刷新access_token（如果需要）<br>
　　第四步：拉取用户信息(需scope为 snsapi_userinfo)</p>
<h3 id="下面来具体api表示下怎么获取的-code-和-openid-吧">下面来具体api表示下怎么获取的 code 和 openid 吧</h3>
<h3 id="一获取code">一：获取code:</h3>
<p>通过https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect来获取code<br>
参数：<br>
APPID：应用唯一标识<br>
redirect_uri：授权后重定向的回调链接地址，用户同意后，code 会自动添加到后面。（请使用urlEncode对链接进行处理 （$url = urlencode('')） ）<br>
scope：是应用授权作用域 （一般有两种：一种是静默方式（snsapi_base); 一种是非静默方式（snsapi_userinfo），需要用户去手动同意才能获取用户信息）</p>
<p>微信中尤其提醒：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问</p>
<p>** code 是微信自动生成的。并且放在redirect_uri（重定向后的回调链接地址）后面,并且带上code和state参数</p>
<p>上面提到了 code。那么 code又是什么呢？<br>
code:作为换取 access_token的票据，每次用户授权带上的 code 都不一样。5分钟未被使用自动过期（过期的这里下面有讲）</p>
<h3 id="二然后授权成功之后-得到-code-就用-code-去获取access_token">二：然后授权成功之后。得到 code。就用 code 去获取access_token</h3>
<p>https://api.weixin.qq.com/sns/oauth2/access_token?appid=wx41cb8dbd827a16e9&amp;secret=d4624c36b6795d1d99dcf0547af5443d&amp;code=00137323023ab55775be09d6d8e75ffA&amp;grant_type=authorization_code<br>
参数说明：<br>
appid：应用唯一标识<br>
code：上一步已经获取到了<br>
secret：应用密钥AppSecret，在微信开放平台提交应用审核通过后获得</p>
<p>正确的返回<br>
&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, // 接口调用凭证 &quot;expires_in&quot;:7200, // access_token接口调用凭证超时时间 &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, // 用户刷新access_token &quot;openid&quot;:&quot;OPENID&quot;, // 授权用户唯一标识 &quot;scope&quot;:&quot;SCOPE&quot;, // 作用域 等</p>
<h3 id="三通过access_token-openid获取用户信息">三：通过access_token、openid获取用户信息</h3>
<p>https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID<br>
就会得到用户的信息：<br>
得到参数：<br>
openid：用户的唯一标识<br>
nickname：用户昵称<br>
sex： 男女<br>
等。。。<br>
特别注意：<br>
1、Appsecret 是应用接口使用密钥，泄漏后将可能导致应用数据泄漏、应用的用户数据泄漏等高风险后果；存储在客户端，极有可能被恶意窃取（如反编译获取Appsecret）； 2、access_token 为用户授权第三方应用发起接口调用的凭证（相当于用户登录态），存储在客户端，可能出现恶意获取access_token 后导致的用户数据泄漏、用户微信相关接口功能被恶意发起等行为； 3、refresh_token 为用户授权第三方应用的长效凭证，仅用于刷新access_token，但泄漏后相当于access_token 泄漏，风险同上。 建议将secret、用户数据（如access_token）放在App云端服务器，由云端中转接口调用请求。</p>
<h3 id="最后总结下详细的步骤">最后总结下详细的步骤：</h3>
<ul>
<li>1．用户关注微信公众账号。</li>
<li>2．微信公众账号提供用户请求授权页面URL。</li>
<li>3．用户点击授权页面URL，将向服务器发起请求</li>
<li>4．服务器询问用户是否同意授权给微信公众账号(scope为snsapi_base时无此步骤)</li>
<li>5．用户同意(scope为snsapi_base时无此步骤)</li>
<li>6．服务器将CODE通过回调传给微信公众账号</li>
<li>7．微信公众账号获得CODE</li>
<li>8．微信公众账号通过CODE向服务器请求Access Token</li>
<li>9．服务器返回Access Token和OpenID给微信公众账号</li>
<li>10．微信公众账号通过Access Token向服务器请求用户信息(scope为snsapi_base时无此步骤)</li>
<li>11．服务器将用户信息回送给微信公众账号(scope为snsapi_base时无此步骤)</li>
</ul>
<p>公众号链接(官网更权威)：<br>
https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html</p>
<p>https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Taro 小程序直播组件 LivePlayer 注意事项]]></title>
        <id>https://weidadeda.github.io/post/taro-xiao-cheng-xu-zhi-bo-zu-jian-liveplayer-zhu-yi-shi-xiang</id>
        <link href="https://weidadeda.github.io/post/taro-xiao-cheng-xu-zhi-bo-zu-jian-liveplayer-zhu-yi-shi-xiang">
        </link>
        <updated>2022-02-10T07:46:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-直播组件优先开通实时音频和视频管理后台申请对应的证书">1、直播组件优先开通实时音频和视频（管理后台），申请对应的证书</h3>
<h3 id="2-直播组件需要做系统权限验证麦克风和相机引导用户打开权限不然部分手机加载失败-insertliveplayerfailaccess-denied-因为权限有三个状态undefined-denied-authorizedauthorized代表系统权限已开">2、直播组件需要做【系统】权限验证，（麦克风和相机）,引导用户打开权限，不然部分手机加载失败（ insertLivePlayer:fail:access denied） 因为权限有三个状态(undefined、denied、authorized)，authorized代表系统权限已开</h3>
<pre><code>export const getSystemInfo = (keys: Tkey[], content = '') =&gt; {
  return new Promise((resolve) =&gt; {
    const systemInfo = wx.getAppAuthorizeSetting();
    console.log('system', systemInfo);
    if (!systemInfo) {
      return resolve({ code: -1, msg: '获取系统权限失败~' });
    }
    keys.forEach((item) =&gt; {
      if (systemInfo[item] !== 'authorized') {
        Taro.showModal({
          content,
          success: (res) =&gt; {
            if (res.confirm) {
              wx.openAppAuthorizeSetting({
                success: () =&gt; {
                  return resolve({ code: 100, msg: '打开系统授权页成功~' });
                },
                fail: () =&gt; {
                  return resolve({ code: 101, msg: '打开系统授权页失败~' });
                }
              });
            } else {
              return resolve({ code: 403, msg: '用户点击取消~' });
            }
          }
        });
        return resolve({ code: 401, msg: '权限没打开~' });
      }
    });
    return resolve({ code: 0, msg: '用户已开通对应权限~' });
  });
};
 
// 获取系统权限
      const res: any = await getSystemInfo(
        ['cameraAuthorized', 'microphoneAuthorized'],
        '检测到您没有打开麦克风和相机权限，部分功能将没法使用~'
      );
</code></pre>
<h3 id="3-直播组件同层渲染在全屏下失效需要单独处理全屏做coverviewcoverimage做原生覆盖能力处理不是全屏就同层渲染全屏处理时候顶层容器和直接子节点需要设置-visiblityvisiblepositionrelativez-index99999-必须得处理不然android-的coverview覆盖不了原生直播组件">3、直播组件同层渲染在全屏下失效，需要单独处理，全屏做CoverView\CoverImage做原生覆盖能力处理，不是全屏就同层渲染，全屏处理时候顶层容器和直接子节点需要设置 visiblity:visible;position:relative;z-index:99999; 必须得处理，不然android 的CoverView覆盖不了原生直播组件。</h3>
<pre><code>.cover-main{
    position: absolute;
    visibility: visible;
    z-index: 999999;
}
 
&lt;CoverView className={style['cover-main']}&gt;
                &lt;CoverView className={style['cover-main']}&gt;
                  &lt;CoverView className={style['live-control']} onClick={showTips}&gt;&lt;/CoverView&gt;
 
        {fullScreenFlag &amp;&amp; (
        &lt;&gt;
            {/*广告*/}
            &lt;Curtain /&gt;

            {/* 封面*/}
            {startStatus === false ? (
            &lt;CoverView className={style.cannot_see}&gt;
                &lt;CoverImage className={style.cannot_see_img} src={readyImg}&gt;&lt;/CoverImage&gt;
            &lt;/CoverView&gt;
            ) : teachStatus === false ? (
            &lt;CoverView className={style.cannot_see}&gt;
                &lt;CoverImage className={style.cannot_see_img} src={outImg}&gt;&lt;/CoverImage&gt;
            &lt;/CoverView&gt;
            ) : null}

            {/* 倒计时*/}
            {time &gt;= 1800 ? &lt;CountDown time={time} /&gt; : null}
        &lt;/&gt;
        )}

        {/*控制*/}
        &lt;CoverView
        className={`${style.control} ${tips ? style['up-ani'] : style['down-ani']}`}
        &gt;
        &lt;CoverView className={style.info}&gt;
            &lt;CoverView&gt;直播&lt;/CoverView&gt;
        &lt;/CoverView&gt;
        &lt;CoverView className={style['full-screen']} onClick={handleFullScreen}&gt;
            &lt;CoverImage
            className={style.icon}
            src={fullScreenFlag ? tuichuquanping : quanping}
            &gt;&lt;/CoverImage&gt;
            &lt;CoverView&gt;{fullScreenFlag ? '小屏播放' : '全屏播放'}&lt;/CoverView&gt;
        &lt;/CoverView&gt;
        &lt;/CoverView&gt;
    &lt;/CoverView&gt;
    &lt;/CoverView&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[瀑布流计算js源码]]></title>
        <id>https://weidadeda.github.io/post/pu-bu-liu-ji-suan-js-yuan-ma</id>
        <link href="https://weidadeda.github.io/post/pu-bu-liu-ji-suan-js-yuan-ma">
        </link>
        <updated>2022-02-10T07:35:44.000Z</updated>
        <content type="html"><![CDATA[<p>遇到问题时的解决方法及使用注意事项：</p>
<p>1、下拉刷新会导致瀑布流顺序错乱，重新new一下瀑布流即可。</p>
<p>2、图片宽高必须要让服务端返，前端去获取数据太多会导致性能非常慢。</p>
<p>3、dom加载时获取小程序的某个dom的宽度（列宽）为空，放在wx.nextTick中即可。还获取不到，就需要看自己要获取的dom是否已加载。</p>
<p>4、此代码抗揍，如果出问题先从自身找问题，再仔细阅读一遍此代码。</p>
<pre><code>class Waterfall {
  constructor(options) {
    this.initWaterfall(options);
  }
    /**
   * 初始化瀑布流
   * @param {Object} options
   * @param {Array&lt;Object&gt;} options.columns {width} - 此参数主要定义每列的宽度
   */
  initWaterfall(options) {
    this.columns = options.columns;
    this.formatedData = [];
    for (let column of options.columns) {
      this.formatedData.push({
        width: column.width,
        height: 0
      });
    }
  }
  imageUrlFeild = 'imageUrl'
 
  /**
   * 格式化从数据中获取图片url的方法
   * @param {Function | String | Number} fn - 若为函数，则需要返回瀑布流每项数据对应的图片字段
   */
 
  formatGetImageUrlMethod(fn) {
    this.imageUrlFeild = typeof fn === 'function' ? fn() : fn
  }
 
  /**
   * 向瀑布流中填充数据
   * @param {Object}  resource - 单个瀑布流项的数据源
   */
  getResourceInfo(resource) {
    const _self = this
    return new Promise(resolve =&gt; {
      if (resource[_self.imageUrlFeild]) {
        // getImageInfo方法在小程序中使用，h5中暂未测试，不过一般都是让服务端直接返回图片宽高，所以这个方法一般用不到，如果需要用到的话，必须加一层loading阻止用户操作
        wx.getImageInfo({
          src: resource[_self.imageUrlFeild],
          success(res) {
            resolve(res)
          },
          fail() {
            resolve()
          }
        })
      } else {
        resolve()
      }
    })
  }
 
  /**
   * 向瀑布流中补充数据
   * @param {Boolean} extraVal 瀑布流的卡片中图片之外的内容
   * @param {Array&lt;resource&gt;}  resources
   */
 
  async addResources(resources, extraVal) {
    // let promiseArray = []
    let newResourcesArray = Array.apply(null, Array(this.columns.length)).map(
      _ =&gt; []
    )
    for (let resource of resources) {
      // promiseArray.push(this.getResourceInfo(resource))
      // let imageInfo
      // imageInfo = await this.getResourceInfo(resource)
      const width = Number(resource.width) || 100;
      const height = Number(resource.height) || 100;
      // 获取最短列的索引
      const index = this.getShortestColumn();
      // 卡片宽度
      const imageWidth = this.formatedData[index].width;
      // 附加的卡片高度在这里是写死的，每个项目会有不同高度
      const extraHeight = extraVal ? extraVal : 0;
      // 获取卡片高度
      const cardHeight = imageWidth / (width / height) + extraHeight;
      // 当前列总高度
      this.formatedData[index].height += cardHeight;
      // 返回卡片高度
      resource.cardHeight = cardHeight;
      // 返回图片高度
      resource.computedHeight = cardHeight - extraVal;
      // 返回当前列的数组
      newResourcesArray[index].push(resource);
    }
    return newResourcesArray
  }
 
  /**
   * 最重要的地方
   * 获取当前数据中填充最短的列
   * 返回最短列的索引
   */
  getShortestColumn() {
    let minHeight = Infinity
    let minHeightColumnIndex = 0
    for (let index = this.formatedData.length - 1; index &gt; -1; index--) {
      //从后往前遍历，防止每列的高度相同的情况
      const height = this.formatedData[index].height
      if (height &lt;= minHeight) {
        minHeightColumnIndex = index
        minHeight = height
      }
    }
    return minHeightColumnIndex
  }
}
 
export default Waterfall;
 
 
// 例：双列瀑布流
let newList = new Waterfall({
      columns: [
        {
          width: 列宽
        },
        {
          width: 列宽
        }
      ]
    });
newList.addResources(lists, 卡片内除图片的额外高度).then(res =&gt; {});
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C端H5或小程序常见问题总结]]></title>
        <id>https://weidadeda.github.io/post/c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie</id>
        <link href="https://weidadeda.github.io/post/c-duan-h5-huo-xiao-cheng-xu-chang-jian-wen-ti-zong-jie">
        </link>
        <updated>2022-02-09T07:59:28.000Z</updated>
        <content type="html"><![CDATA[<p>开发C端时遇到的一些问题与解决方法，都记录下来，希望对你也有帮助。</p>
<h3 id="1部分机型拍照上传图片旋转问题">1.部分机型拍照上传图片旋转问题：</h3>
<p>直接从图片后面加参数‘?x-oss-process=image/auto-orient,1/resize,m_fixed’（加上参数之后会自动旋转回来，其他参数可参考阿里OSS官方文档https://help.aliyun.com/document_detail/44691.html?spm=a2c4g.11186623.6.1390.750ac1f6HTe92Q）</p>
<h3 id="2swiper3d两边留白效果">2.swiper3D两边留白效果：</h3>
<p>（小程序h5均适用），代码如下，需要注意的是必须给swiper父级元素加overflow-x:hidden</p>
<pre><code>.swiper-container {
  height: 100%;
  width: 600px;
  perspective: 1600px;
  overflow: visible;
  img {
    width: 100%;
    height: 720px;
    border-radius: 20px;
  }
}
.swiper-slide {
  padding: 0 24px;
  box-sizing: border-box;
  text-align: center;
  transition: transform 0.5s;
  transform-origin: 50% 50%;
  transform: scale(0.9);
  &amp;.swiper-slide-active {
    transform: scale(1);
  }
}
</code></pre>
<h3 id="3小程序的跳转十层限制不要一直用navigateto这样属于一直前进如果需要跳转回首页或者其他可以使用relaunch逻辑复杂时可自己写顶部导航栏包括返回按钮">3.小程序的跳转十层限制，不要一直用navigateTo，这样属于一直前进，如果需要跳转回首页或者其他可以使用reLaunch，逻辑复杂时可自己写顶部导航栏包括返回按钮。</h3>
<h3 id="4保存海报到本地推荐一波生成小程序海报的插件非常简单方便">4.保存海报到本地：推荐一波生成小程序海报的插件，非常简单方便</h3>
<p>taro-plugin-canvas (Taro环境使用)与wxa-plugin-canvas（普通小程序使用）<br>
tip:如果遇到非常规的情况，需要手写canvas并且宽高尺寸乘2保证清晰度。</p>
<h3 id="5input光标永远停留在最后">5.input光标永远停留在最后：</h3>
<pre><code>var el = document.getElementById(&quot;IPTname&quot;);
var range = document.createRange();
range.selectNodeContents(el);
range.collapse(false);
var sel = window.getSelection();
sel.removeAllRanges();
sel.addRange(range);
</code></pre>
<h3 id="6小程序获取用户授权用户信息用户定位用户相册访问权限等时需要处理拒绝时的情况-生成海报到自己相册的时候如果用户在授权的时候点击了拒绝如果不兼容拒绝授权则直接生成失败">6.小程序获取用户授权（用户信息/用户定位/用户相册访问权限等）时需要处理拒绝时的情况。生成海报到自己相册的时候如果用户在授权的时候点击了拒绝，如果不兼容拒绝授权则直接生成失败。</h3>
<h3 id="7监听移动端键盘弹出和收起事件">7.监听移动端键盘弹出和收起事件。</h3>
<p>在ios设备上,操作表单输入时,键盘弹出时会把页面顶起来,键盘收起时并不会把页面恢复成原来的样子,造成页面样式错乱,利用focusout和focusin事件,可以间接地监听到键盘的收起和弹出事件,然后操作页面滚动到想要的位置.</p>
<p>focusout触发时机:  当元素即将失去焦点时，focusout 事件被触发。focusout 事件和 blur 事件之间的主要区别在于后者不会冒泡。</p>
<p>focusin触发时机:    当元素即将接收 focus 事件时，focusin 事件被触发。 这个事件和 focus 事件的主要区别在于后者不会冒泡。</p>
<p>监听方式:</p>
<pre><code>let scrollTop = 0
//键盘收起
document.body.addEventListener('focusout',()=&gt;{
   document.body.scrollTop=document.documentElement.scrollTop=scrollTop
})
//键盘弹出
document.body.addEventListener('focusin',()=&gt;{
   scrollTop = document.body.scrollTop || document.documentElement.scrollTop
})
</code></pre>
<h3 id="8移动端代码返回上一页windowlocationback失效">8.移动端代码返回上一页（window.location.back()失效）</h3>
<p>尼玛。。移动端返回上一页有时候用window.location.back()不好使，无解。可以使用window.location.href = document.referrer。</p>
<h3 id="9单页面应用跳转路由之后再次使用echarts时不展示">9.单页面应用跳转路由之后再次使用echarts时不展示</h3>
<p>首次使用不展示，可以延迟加载，但是当路由跳转回来之后延迟都不管用，那么需要在init Echarts之前动态设置容器宽高，并且清空父元素，因为再次回来的时候之前的echarts实例已经是存在的了，可在调试中查看详情。</p>
<h3 id="10-视频黑边问题">10. 视频黑边问题</h3>
<p>给video标签（原生video标签）加一个object-fit:fill属性即可解决。要强调的是，千万不要使用Taro的Video标签，很坑，解决了黑边，全屏时又会导致视频变形，不用object:fill的话也能解决黑边，但是全屏时视频的退出全屏样式又会被覆盖。</p>
<h3 id="11-手机锁屏时倒计时停止">11. 手机锁屏时倒计时停止</h3>
<pre><code>window.addEventListener('visibilitychange',() =&gt; {
   if (
     //hidden为锁屏时或页面不展示时，可重新获取时间开始倒计时。
      document.visibilityState =='hidden'
   ) 
})
</code></pre>
<h3 id="12移动端实现省-市-区-街道四级联动">12.移动端实现省-市-区-街道四级联动</h3>
<p>需求是要实现地区四级联动，但是vant的插件只支持三级地区联动，就很尴尬，只能自己写，但是自己写的话UI与交互体验会很差，所以就想办法去和后端对接。其实很简单，写出来只是提醒大家可以这么实现，减少思考与踩坑的时间。三级联动选择完之后会返回地区编码，eg:Array&lt;{code:'110101',name:'东城区'}&gt;,然后去请求后端的接口将地区编码传过去，就能得到其街道的相关信息，然后简单过滤一下，放在Picker选择器中就可以实现。接下来就可以写业务逻辑了。</p>
<h3 id="13ios内webview中vue项目会出现大块白色遮罩">13.ios内webview中vue项目会出现大块白色遮罩</h3>
<p>问题描述：</p>
<p>A页面——&gt;B页面——&gt;ios自带的返回——&gt;白屏出现(像个魔鬼)——&gt;点击或滑动页面——&gt;问题解决</p>
<p>原因是，经过排查，发现在ios 机器上使用webview 开发Vue项目时候，go history (-1)，无法将body 的高度拉掉，使得遮住，触发轻点击，方可消除该遮罩</p>
<p>解决的理论：用于最重要的html 容器是container，然而因为设置html、body高度是100%，从而造成了 container 撑开父级，但浏览器默认滚动的scroll 并不是 container，而是body，某些因素，造成返回history 后，无法复原（ios 的锅），为此，将 container(app.vue中包裹的div，也可以是#app) 进行了绝对定位，并让它重新成为 scroll 的对象，从而解决问题。</p>
<pre><code>html, body {

 width: 100%;

 height: 100%;
 min-height: 100vh;

 margin: 0;

 padding: 0;

 position: relative;

}

.container {

 width: 100%;

height: 100vh;
 min-height: 100vh;

 background: #fff;

 overflow: scroll;

 -webkit-overflow-scrolling: touch;

 position: absolute;

 left:0;

 top:0;

}
</code></pre>
<h3 id="14在ios上a页面分享朋友圈之后跳转到-b-页面或进行别的操作">14.在ios上A页面分享朋友圈之后，跳转到 B 页面（或进行别的操作）</h3>
<p>注：离开 app的 A 页面去微信，再次回到 app 的时候跳转到 B 页面</p>
<p>visibilitychange：当用户最小化窗口或者切换选项卡的时候，api 就会发送visibilitychange事件，让开发者知道页面状态已更改。你可以检测事件并执行某些操作或行为。</p>
<pre><code>//这个方法在分享被触发的时候执行
initVisibilityChange() {
      if (typeof document.visibilityState != &quot;undefined&quot;) {
        this.visibleChange = &quot;visibilitychange&quot;;
        this.vibibleState = &quot;visibilityState&quot;;
      } else if (
        typeof (document as any).webkitVisibilityState != &quot;undefined&quot;
      ) {
        this.visibleChange = &quot;webkitvisibilitychange&quot;;
        this.vibibleState = &quot;webkitVisibilityState&quot;;
      }
      if (this.visibleChange) {
        document.addEventListener(
          this.visibleChange,
          this.onVisibilityChanged,
          false
        );
      }
    },
      /**
     * 从微信返回app可以在这里面处理事情
     */
    onVisibilityChanged(event: any) {
      var hidden = event.target.webkitHidden;
      if ((document as any)[this.vibibleState] == &quot;visible&quot;) {
          this.goRun(); // 做自己需要的逻辑处理
          this.removeVisibilityChange();
      }
    },
     // 移除app后台监听事件
    removeVisibilityChange() {
      document.removeEventListener(
        this.visibleChange,
        this.onVisibilityChanged,
        false
      );
    },
</code></pre>
<h3 id="15-从vue页面跳转到非vue页面点击返回ios设备上页面数据不刷新">15. 从vue页面跳转到非vue页面，点击返回，ios设备上页面数据不刷新。</h3>
<p>比如A页面定义了一个变量为true，点击跳转到非vue项目页面（php），点击返回，查看这个变量，在安卓上依然为ture，但是在ios上就变成了false。</p>
<p>解决方法：</p>
<pre><code>window.onpageshow=function(e){
　　if(e.persisted) {
　　　　window.location.reload()
　　}
};
</code></pre>
<h3 id="16-app点击自带返回按钮关闭页面以及禁用返回的踩坑记录">16. app点击自带返回按钮关闭页面以及禁用返回的踩坑记录</h3>
<p>http://note.youdao.com/s/4qUINhV0 （比较多，有道云链接发出来，希望对大家有帮助）</p>
<h3 id="17-wxchooseimage方法在安卓与ios上取到的base64格式不一样安卓没有dataimagejpgbase64前缀需要单独处理">17. wx.chooseImage方法在安卓与ios上取到的base64格式不一样，安卓没有data:image/jpg;base64前缀，需要单独处理</h3>
<h3 id="18-手机内h5点击input无法唤起自带键盘可以给input添加click事件手动触发focus事件">18. 手机内h5点击input无法唤起自带键盘：可以给input添加click事件手动触发focus事件。</h3>
<h3 id="19-canvas绘制圆角矩形方法">19. canvas绘制圆角矩形方法</h3>
<pre><code>// x、y、w、h与canvas的rect方法参数相同
//r代表圆角大小，1、2、3、4分别代表上左、上右、下右、下左
function drawRoundRect(ctx, x, y, w, h, r1, r2, r3, r4) {
  ctx.beginPath()
  ctx.moveTo(x + r1, y)
  ctx.arcTo(x + w, y, x + w, y + h, r2)
  ctx.arcTo(x + w, y + h, x, y + h, r3)
  ctx.arcTo(x, y + h, x, y, r4)
  ctx.arcTo(x, y, x + w, y, r1)
  ctx.closePath()
}
</code></pre>
<h3 id="20-post导出文件处理">20. POST导出文件处理</h3>
<ul>
<li>fetch请求方法中，增加类型处理，预设请求传入字段控制，返回为：response.blob()；</li>
<li>返回值处理：</li>
</ul>
<pre><code>const blob = new Blob([data], {type: &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;})
    const a = document.createElement(&quot;a&quot;);
    const filename ={
      exportDetail: '推广人员用户明细',
      exportRecord: '推广人员跟进记录明细'
    }
    a.href = URL.createObjectURL(data)
    a.download = filename[type] // 这里填保存成的文件名
    a.click()
    URL.revokeObjectURL(a.href)
　　 a.remove();
</code></pre>
<h3 id="21-解决css瀑布流只能竖向展示问题非排名或排序时可用">21. 解决css瀑布流只能竖向展示问题(非排名或排序时可用)</h3>
<pre><code class="language-css">// 父元素
column-count: 2;
width: 100%;
// 子元素
break-inside: avoid;
</code></pre>
<pre><code class="language-js">const oldList = lists;
const newList = [].concat(
  ...Array.from(
    oldList.reduce(
      (total, cur, index) =&gt; {
        total[index % 2].push(cur);
        return total;
      },
      { 0: [], 1: [], length: 2 }
    )
  )
);
</code></pre>
<h3 id="22-mpvue的坑">22. mpvue的坑</h3>
<ul>
<li>
<p>一定要遵循mpvue官方文档建议，不要将v-for用在组件上面，或者在v-for内嵌套组件，这样成倍增加wx.setData的数据量</p>
</li>
<li>
<p>在开发上拉加载更多的需求时不要使用小程序原生的scroll-view，直接使用page的onReachBottom事件</p>
</li>
<li>
<p>使用swiper时，不要嵌套过多swiper-item，不要在swiper-item中放入太多元素，有瀑布流等无限加载列表需求时，禁止使用swiper，会导致小程序卡死闪退</p>
</li>
<li>
<p>slot只能使用匿名，具名slot及scoped slot不能使用</p>
</li>
<li>
<p>在定义组件data时，不要将与view无关的数据定义到data中，直接定义到外部，特别时监听scroll事件的时候</p>
</li>
<li>
<p>wx对象的方法全部都挂在mpvue对象下，不需要直接调用wx的方法，特别是在兼容h5的时候</p>
</li>
<li>
<p>button open-type是获取用户手机号等需要绑定事件的类型时，不要使用click.stop或catch:tap，这样会导致不会触发获取用户手机号的回调方法</p>
</li>
<li>
<p>所有组件的created生命周期只在小程序加载的时候统一执行，即使使用了v-if也不能在每次加载组件的时候触发</p>
</li>
<li>
<p>如果要自定义tabbar最好自己实现一个，不要使用原生的custom定义，原生custom限制太多且不能使用mpvue实现</p>
</li>
</ul>
<h3 id="23-taro-hooks子组件条件渲染">23. Taro hooks子组件条件渲染</h3>
<p>若是希望子组件props未被重新赋值的情况下不渲染，使用memo包裹，它实现了class中PureComponent的效果，浅比较了一次。</p>
<pre><code>// 子组件
import Taro, { memo } from &quot;@tarojs/taro&quot;;
import { View } from &quot;@tarojs/components&quot;;
 
const Index = ({ data }) =&gt; {
  return (
    &lt;View&gt;
      {console.log(&quot;Test -- rander2&quot;, data)}
      {data.map((item, index) =&gt; {
        return &lt;View key={index}&gt;{item}&lt;/View&gt;;
      })}
    &lt;/View&gt;
  );
};
 
export default memo(Index);
</code></pre>
<p>若是希望在某些特定的prop改变的时候更新子组件</p>
<pre><code>// utils
import Taro from &quot;@tarojs/taro&quot;;
 
/**
  * 子组件条件渲染
  * @param {Function} render - 要渲染的组件函数
  * @param {Array}  observe - 渲染依据，从props接收的数据key，
  */
export const compareRender = (render, observe=[]) =&gt; {
  const compare = (prevProps, nextProps) =&gt; {
    let keep = true;
    for (let i = 0; i &lt; observe.length; i++) {
      if (prevProps[observe[i]] !== nextProps[observe[i]]) {
        keep = false;
        break;
      }
    }
    return keep;
  };
  return Taro.memo(render, compare);
};
</code></pre>
<pre><code>// 子组件
import Taro from &quot;@tarojs/taro&quot;;
import { View } from &quot;@tarojs/components&quot;;
 
import { compareRender } from &quot;@utils&quot;;
 
const Index = ({ data }) =&gt; {
  return (
    &lt;View&gt;
      {console.log(&quot;Test -- rander&quot;, data)}
      {data.map((item, index) =&gt; {
        return &lt;View key={index}&gt;{item}&lt;/View&gt;;
      })}
    &lt;/View&gt;
  );
};
 
export default compareRender(Index, [&quot;data&quot;]);
</code></pre>
<h3 id="24-关于在dva副作用中多个请求同步执行的优化">24. 关于在dva副作用中多个请求同步执行的优化</h3>
<p>经测试：<br>
const res1 = yield call(req1); const res2 = yield call (req2); const res3 = yield call (req3);  三个请求同步执行，平均耗时大约为120ms，页面加载、数据等待时间较长。<br>
优化：<br>
const [ res1, res2, res3] =  yield [ call(req1), call(req2), call(req3) ],  并发请求，平均耗时大约为20ms</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js获取文件大小 window.performance]]></title>
        <id>https://weidadeda.github.io/post/js-huo-qu-wen-jian-da-xiao</id>
        <link href="https://weidadeda.github.io/post/js-huo-qu-wen-jian-da-xiao">
        </link>
        <updated>2022-02-07T09:49:49.000Z</updated>
        <content type="html"><![CDATA[<p>背景：今天 每周例行技术分享 的时候，有位同事说 js 获取不到文件大小：浏览器默认不允许js 执行IO操作。 举了个例子，比如想获取一个图片地址的文件大小，因为之前做过图片上传功能所以比较敏感，感觉应该是可以的，虽然他说网上找过很多资料但是都不行，但是这种东西 只有自己试试才安心嘛~~</p>
<h3 id="失败方案-canvastoblob">失败方案 canvas.toBlob</h3>
<pre><code>function loadImg(url){
    return new Promise((res, rej) =&gt; {
        const img = new Image()
        img.crossOrigin = ''   // 防止img 画在canvas上时报跨域错误
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej()
        }
        img.src = url
    })
}

async function getImgSize(url) {
    const urlArr = url.split('.')
    const mime = &quot;image/&quot; + urlArr[urlArr.length-1]
    const img = await loadImg(url)
    const {width,height} = img
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img,0,0,width,height)
    canvas.toBlob(
        blob =&gt; {
            console.log(url,blob,(blob.size / 1000)+'KB')
        },
        mime
    );
}

getImgSize('https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg')
</code></pre>
<p>看日志输出<br>
<img src="https://weidadeda.github.io/post-images/1644227403808.jpg" alt="" loading="lazy"><br>
看着成了，但实际.... 与 本地 和 Network 差 十万八千里<br>
<img src="https://weidadeda.github.io/post-images/1644227440435.png" alt="" loading="lazy"><br>
<img src="https://weidadeda.github.io/post-images/1644227452558.jpg" alt="" loading="lazy"><br>
我尝试了几个图片,每个图片都比之前要大，而且增大程度不一定,这块估计是canvas画了一遍的原因。。。</p>
<h3 id="失败方法-canvastodataurl-dataurltoblob">失败方法 canvas.toDataURL + dataURLtoBlob</h3>
<pre><code>function loadImg(url){
    return new Promise((res, rej) =&gt; {
        const img = new Image()
        img.crossOrigin = ''   // 防止img 画在canvas上时报跨域错误
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej()
        }
        img.src = url
    })
}

async function getImgSize(url) {
    const urlArr = url.split('.')
    const mime = &quot;image/&quot; + urlArr[urlArr.length-1]
    const img = await loadImg(url)
    const {width,height} = img
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img,0,0,width,height);
    const blob =  dataURLtoBlob(canvas.toDataURL(mime));
    console.log(url,blob,(blob.size / 1000)+'KB')
}
function dataURLtoBlob(dataurl) {
    var arr = dataurl.split(',');
    var _arr = arr[1].substring(0,arr[1].length-2);
    var mime = arr[0].match(/:(.*?);/)[1],
        bstr =atob(_arr),
        n = bstr.length,
        u8arr = new Uint8Array(n);
    while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], {
        type: mime
    });
}

getImgSize('https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg')
</code></pre>
<p>看结果⬇️<br>
<img src="https://weidadeda.github.io/post-images/1644227621781.jpg" alt="" loading="lazy"><br>
。。。看来不能走canvas这条路了</p>
<h3 id="成功方案-performance">成功方案 performance</h3>
<p><img src="https://weidadeda.github.io/post-images/1644227695711.png" alt="" loading="lazy"><br>
难道真的没有办法了嘛？我盯着 浏览器Network 陷入沉思, 突然 Network 资源加载 的size在我眼里 越来越抢眼，貌似有个api可以获取到资源加载~~~~~ 走起</p>
<pre><code>function getImgSize(url){
    return new Promise((res, rej) =&gt; {
        var performance = window.performance || 
            window.msPerformance || 
            window.webkitPerformance;
        if (performance) {
            const img = new Image()
            img.crossOrigin = ''
            img.onload = function() {
                let [imgEntries] = performance.getEntriesByName(url)
                res(imgEntries)
            }
            img.onerror = function() {
                rej('图片加载失败')
            }
            img.src = url
        }else{
            rej('浏览器不持支持performance')
        }
    })
}
let url = 'https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg'
getImgSize(url).then(v=&gt;{
    console.log(v)
    console.log(v.decodedBodySize)
    console.log((v.decodedBodySize / 1000),'KB')
    // transferSize  判断是否缓存
})
</code></pre>
<blockquote>
<p>这块使用 decodedBodySize，因为 css js等资源 decodedBodySize 与本地大小一致<br>
<img src="https://weidadeda.github.io/post-images/1644227863370.png" alt="" loading="lazy"><br>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/decodedBodySize">decodedBodySize-MDN文档</a><br>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/encodedBodySize">encodedBodySize-MDN 文档</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/getEntriesByName">performance.getEntriesByName-MDN文档</a><br>
哈哈哈哈，成了～</p>
</blockquote>
<h3 id="多组数据验证">多组数据验证</h3>
<table>
<thead>
<tr>
<th style="text-align:left">图片地址</th>
<th style="text-align:center">本地size</th>
<th style="text-align:center">canvas.toBlob</th>
<th style="text-align:center">canvas.toDataURL + dataURLtoBlob</th>
<th style="text-align:center">performance</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">https://images.daojia.com/changsha/banner/pic/25675a8d10bfa08e9599d2deb9a44eae.jpeg</td>
<td style="text-align:center">20519</td>
<td style="text-align:center">36345</td>
<td style="text-align:center">36343</td>
<td style="text-align:center">20519</td>
</tr>
<tr>
<td style="text-align:left">https://images.daojia.com/dop/custom/dda52b42212b6bdea3e12d03ac97ffbe.png</td>
<td style="text-align:center">65511</td>
<td style="text-align:center">164303</td>
<td style="text-align:center">164302</td>
<td style="text-align:center">65511</td>
</tr>
<tr>
<td style="text-align:left">https://images.daojia.com/dop/custom/f8f0528c61e243699c309f5f25eab513.png</td>
<td style="text-align:center">14638</td>
<td style="text-align:center">36394</td>
<td style="text-align:center">36391</td>
<td style="text-align:center">14638</td>
</tr>
</tbody>
</table>
<h4 id="没有看错-performance-与本地的完全一样">没有看错 performance 与本地的完全一样</h4>
<h3 id="不限制于图片">不限制于图片</h3>
<pre><code>function loadJSFile(source) {
    return new Promise((res, rej) =&gt; {
        const node = document.createElement('script')
        node.async = false
        node.src = source

        const supportOnload = 'onload' in node
        if (supportOnload) {
            node.onload = function(){
                res(this)
            }
            node.onerror = () =&gt; {
                rej(`${source}加载失败`)
            }
        } else {
            node.onreadystatechange = function(){
                if (/loaded|complete/i.test(node.readyState)) {
                    res(this)
                }
            }
        }
        document.getElementsByTagName('head')[0].appendChild(node)
    })
}
function loadImgFile(url){
    return new Promise((res, rej) =&gt; {
        const img = new Image()
        img.crossOrigin = ''
        img.onload = function() {
            res(this)
        }
        img.onerror = function() {
            rej('图片加载失败')
        }
        img.src = url
    })
}

function loadCSSFile(source) {
    return new Promise((res, rej) =&gt; {
        var head = document.getElementsByTagName('head')[0];
        var link = document.createElement('link');
        link.type = 'text/css';
        link.rel = 'stylesheet';
        link.href = source;
        const supportOnload = 'onload' in link
        if (supportOnload) {
            link.onload = function(){
                res(this)
            }
            link.onerror = () =&gt; {
                rej(`${source}加载失败`)
            }
        } else {
            link.onreadystatechange = function(){
                if (/loaded|complete/i.test(link.readyState)) {
                    res(this)
                }
            }
        }
        head.appendChild(link);
    })
}
function getFileSize(url){
    return new Promise((res, rej) =&gt; {
    var performance = window.performance || 
        window.msPerformance || 
        window.webkitPerformance;
    if (performance) {
        let [imgEntries] = performance.getEntriesByName(url)
        if(imgEntries){
            console.log(imgEntries)
            console.log(imgEntries.decodedBodySize)
            console.log((imgEntries.decodedBodySize / 1000),'KB')
            res(imgEntries)
        }else{
            rej('资源加载有问题')
        }
    }else{
        rej('浏览器不持支持performance')
    }
})
}
(async function (){
    const css = 'https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css';
    await loadCSSFile(css)
    await getFileSize(css)

    const js = 'https://cdn.bootcdn.net/ajax/libs/vue/2.6.11/vue.min.js';
    await loadJSFile(js)
    await getFileSize(js)

    const img = 'https://images.daojia.com/dop/custom/f8f0528c61e243699c309f5f25eab513.png';
    await loadImgFile(img)
    await getFileSize(img)
})()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://weidadeda.github.io/post-images/1644228526757.png" alt="" loading="lazy"></figure>
<h3 id="兼容性">兼容性</h3>
<p>最后记得使用<a href="https://caniuse.com/?search=encodedBodySize">caniuse - performance</a>查看一下兼容性</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用yeoman开发一个自己的项目脚手架]]></title>
        <id>https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia</id>
        <link href="https://weidadeda.github.io/post/kai-fa-yi-ge-zi-ji-de-xiang-mu-jiao-shou-jia">
        </link>
        <updated>2022-02-07T07:37:02.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://weidadeda.github.io/post-images/1644219568486.gif" alt="" loading="lazy"><br>
上面是一个使用脚手架来初始化项目的典型例子。<br>
随着前端工程化的理念不断深入，越来越多的人选择使用脚手架来从零到一搭建自己的项目。其中大家最熟悉的就是create-react-app和vue-cli，它们可以帮助我们初始化配置、生成项目结构、自动安装依赖，最后我们一行指令即可运行项目开始开发，或者进行项目构建（build）。<br>
这些脚手架提供的都是普遍意义上的最佳实践，但是我在开发中发现，随着业务的不断发展，必然会出现需要针对业务开发的实际情况来进行调整。例如：</p>
<ol>
<li>
<p>项目架构的配置<br>
a. webpack/gulp的配置<br>
ⅰ. style/less/sass的选择和处理配置。<br>
ⅱ. Typescript和JavaScript的loader和babel的配置，比如babel-loader和tsc。<br>
ⅲ. 图片的配置，比如需要file-loader或者url-loader。<br>
ⅳ. 静态资源的配置。<br>
ⅴ. 企业内部，真对于某些特定功能的webpack-loader/webpack-plugin，比如打包完图片上传。<br>
b. 是否内置一些第三方框架供上手使用，比如Element-UI，Antd等。<br>
c. 项目的路由的设计和配置。<br>
d. 项目目录结构的设计和配置。<br>
e. 项目通用功能的有关代码，比如登陆和欢迎页等。<br>
f.通过调整插件与配置实现 Webpack 打包性能优化<br>
g.针对生产环境做的单独处理</p>
</li>
<li>
<p>项目开发中的配置<br>
a. eslint。<br>
b. style-lint。<br>
c. prettier。<br>
d. 单元测试jest或者其他单元测试框架。<br>
e. 项目文档的自动生成，比如docz。<br>
f. git相关的，比如git提交的校验，生成changelog<br>
g. npm相关，除非是开发npm包，否则npm相关的不是那么重要<br>
h. 与开发有关的工具，比如打包构建结果的包分析、比如相似代码自动生成</p>
</li>
<li>
<p>项目上线脚本，这个应该是可选项？更优的方法应该是使用内部的例如发布平台之类的工具完成，或者通过jekins或者gitlab-ci进行自动化发布，回滚等操作。上线发布回滚的动作可以完全交给非开发人员完成。<br>
a. 比如由nodejs编写的上线脚本，或者是用于上线的shell脚本。<br>
b. gitlab-ci的配置文件</p>
</li>
</ol>
<p>……<br>
总而言之，随着业务发展，我们往往会沉淀出一套更“个性化”的业务方案。这时候我们最直接的做法就是开发出一个该方案的脚手架来，以便今后能复用这些最佳实践与方案。<br>
那么就需要使用一个工具来帮我们做这些处理，我们使用的就是yoman。<a href="https://yeoman.io/">官网地址</a><br>
我们可以使用yeoman和yeoman的generator来更加便捷实现我们的脚手架，可以说基本是零成本。<br>
先说说Yeoman是什么，它想做什么？<br>
Yeamon帮助你快速的开展一个项目工程，提供最佳实践和工具，来让你保持高效率编码。</p>
<p>他们自己提供了一个构建生态系统，主要通过‘yo’这个命令来构建一个完整的项目或者项目的一部分。</p>
<p>通过官方的生成器，他们建立了一个Yeoman的工作流，这个流是由一个强大的,固定的客户端组建，包含工具和框架帮助开发者快速建立牛逼的web应用。他们尽量提供了开发者所需的东西。比如先下载对应模版项目，然后下载模版项目中的package.json中的包</p>
<p>作为良好文档和深入思考构建过程的思想者，Yeoman包含了检测（静态检测）、测试以及压缩等等一系列工具，让开发者能够更加专注于思考解决方案。</p>
<h3 id="如何使用">如何使用：</h3>
<p>1、npm install -g yo //权限不够，请加上 sudo，一般来说mac都需要。<br>
安装完成之后，你就拥有了1个命令 -- yo 可以选择自定义的，也可以搜索你想要的现成的，这里我们选择自己的。 官网提供的地址：http://yeoman.io/generators/<br>
那我们开始编写一个自己的generators。<br>
2、开发自己的generator<br>
创建项目<br>
全局安装generator-generator，然后使用创建项目，根据提示输出我们的generator项目的名字，yeoman规定项目名字必须以generator开头，所以我们可以选择generator-xxx作为我们的项目名<br>
npm i -g generator-generator<br>
yo generator<br>
创建好项目之后，我们可以发现已经自动为我们配置好了eslint，jest，husky</p>
<p>我们主要需要修改的代码位于generators/app内<br>
● index.js定义了我们使用此generator时的一些操作配置项<br>
● templates内存放的是要生成的项目的项目模板，项目模板也可以放在git上，然后通过download-git-repo下载到本地<br>
验证我们创建的项目</p>
<ol>
<li>在当前项目执行npm link使其被链接到全局</li>
<li>然后找一个目录，终端执行yo，此时便可以发现我们的generator已经出现在了选择列表中。然后选择我们的generator运行即可。等待完成，会发现成功的创建了一个叫做dummyfile.txt的文件夹。<br>
generators/app/index.js<br>
初始化的文件如下。</li>
</ol>
<pre><code>&quot;use strict&quot;;
const Generator = require(&quot;yeoman-generator&quot;);
const chalk = require(&quot;chalk&quot;);
const yosay = require(&quot;yosay&quot;);

module.exports = class extends Generator {
  prompting() {
    // Have Yeoman greet the user.
    this.log(
      yosay(
        `Welcome to the fantastic ${chalk.red(&quot;generator-rc-op&quot;)} generator!`
      )
    );

    const prompts = [
      {
        type: &quot;confirm&quot;,
        name: &quot;someAnswer&quot;,
        message: &quot;Would you like to enable this option?&quot;,
        default: true
      }
    ];

    return this.prompt(prompts).then(props =&gt; {
      // To access props later use this.props.someAnswer;
      this.props = props;
    });
  }

  writing() {
    this.fs.copy(
      this.templatePath(&quot;dummyfile.txt&quot;),
      this.destinationPath(&quot;dummyfile.txt&quot;)
    );
  }

  install() {
    this.installDependencies();
  }
};
</code></pre>
<p>从文件的内容可以看出主要操作是暴露出一个继承自Generator的类，在类的内部定义了部分生命周期方法，供yoeman在适当的时候调用。我们只需要完善这些方法就可以了。</p>
<h3 id="yeoman提供的生命周期如下">yeoman提供的生命周期如下：</h3>
<ol>
<li>initializing：初始化必要的依赖，或者比如检测新版本</li>
<li>prompting：用来处理终端的交互</li>
<li>default：这里指的是自己自定义的方法，而不是名为default的方法，自己定义的方法如果不想被调用，那么需要确保方法名以_为开头。</li>
<li>writing：将经过ejs模板渲染后的内容写入文件系统。</li>
<li>conflicts：勇于解决将文件内容写入文件系统时可能造成的冲突</li>
<li>install：安装项目的依赖，比如npm install 或者 bower install</li>
<li>end：做一些收尾的工作。</li>
</ol>
<p>这些生命周期方法均支持返回Promise来进行异步操作。</p>
<h3 id="内置常用工具">内置常用工具</h3>
<p>终端交互：内置了Inquirer提供终端交互<br>
模板填充：内置了ejs模板<br>
文件操作<br>
● this.fs.copyTpl：用于拷贝并且根据数据使用ejs模板渲染文件。此函数接受三个参数，源文件路径，目标文件路径，传给ejs用于渲染目标问价的数据。<br>
● this.fs.copy：将文件丛源路径复制到目标路径。<br>
● this.destinationPath() ：此函数返回最终生成项目的路径<br>
其他<br>
● this.npmInstall：实现npm isntall</p>
<pre><code>// 部分代码，完整代码见最下方链接
writing() {
    const done = this.async();
    this.log(&quot;⚙  Finish basic configuration.&quot;, chalk.green(&quot;✔&quot;));
    this.log(&quot;📂 Generate the project template and configuration...&quot;);
    let spinner = ora({
      text: `Download the template from ${GIT_BASE}${TPL_REPOSITORY}...`,
      spinner: ORA_SPINNER
    }).start();
    this._downloadTemplate(TPL_REPOSITORY)
      .then(() =&gt; {
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish downloading the template from ${GIT_BASE}${TPL_REPOSITORY}`
        });
        spinner = ora({
          text: `Copy files into the project folder...`,
          spinner: ORA_SPINNER
        }).start();
        const templateRoot = this.destinationPath(this.dirName, &quot;.tmp&quot;);
        this.log(`\n${templateRoot}`, &quot;templateRoot&quot;);
        const resoPath = path.resolve(templateRoot, &quot;../&quot;);
        this.log(resoPath, &quot;resoPath&quot;);
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish copying files into the project folder`
        });
        execSync(`cp -R ${resoPath}/.tmp/* ${resoPath}`, { stdio: &quot;inherit&quot; });
        spinner = ora({
          text: `Clean tmp files and folders...`,
          spinner: ORA_SPINNER
        }).start();
        fs.removeSync(templateRoot);
        spinner.stopAndPersist({
          symbol: chalk.green(&quot;   ✔&quot;),
          text: `Finish cleaning tmp files and folders`
        });
        // ExecSync(`rm -R ${resoPath}/.tmp`, { stdio: &quot;inherit&quot; });
        // 将新生成的项目的title换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/public/index.html`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/public/index.html`, str);
          }
        );
        // 将新生成的项目的package.json的name换成自定义的项目名称
        ejs.renderFile(
          `${resoPath}/package.json`,
          { dirName: this.dirName },
          function(err, str) {
            // Str =&gt; 输出渲染后的 HTML 字符串
            fs.writeFile(`${resoPath}/package.json`, str);
          }
        );
        done();
      })
      .catch(err =&gt; this.env.error(err));
  }
</code></pre>
<h3 id="其他可能用到的工具">其他可能用到的工具</h3>
<p>● ora：用于创建Spinner，即比如下载模板文件时需要展示的laoding效果。<br>
● chalk：用于打印彩色的信息<br>
● update-notifier<br>
● beeper<br>
● boxen<br>
调试<br>
由于yeoman是通过npm包的形式进行使用的，所以我们可以在我们开发的generator项目的跟目录下，执行npm link 将我们开发的generator链接到全局，这样我们直接使用yo命令查看可以使用的generator，就可以看到我们所开发的generator了，并且是实时生效的</p>
<h3 id="我的代码是在本地的用的npm-link没有上传到github或npm此处贴出其他大佬的项目代码-快动手试一下吧~">我的代码是在本地的，用的npm link，没有上传到github或npm，此处贴出其他大佬的项目代码。快动手试一下吧～</h3>
<p><a href="https://github.com/alienzhou/webpack-kickoff-template">模版完整代码</a>   注意要给ejs写入的空位<br>
<a href="https://github.com/alienzhou/generator-webpack-kickoff">脚手架完整代码</a></p>
<h3 id="参考文章">参考文章：</h3>
<p><a href="https://www.yuque.com/kongdepeng/rgpm60/qrluup">前端自动化工具 - yeoman</a><br>
<a href="https://zhuanlan.zhihu.com/p/66190308">如何快速开发一个自己的项目脚手架？</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用Object.create浅拷贝一个对象]]></title>
        <id>https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang</id>
        <link href="https://weidadeda.github.io/post/ru-he-yong-objectcreate-qian-kao-bei-yi-ge-dui-xiang">
        </link>
        <updated>2022-01-21T02:41:42.000Z</updated>
        <content type="html"><![CDATA[<p>// 首先得介绍一下深拷贝和浅拷贝（虽然大家都知道，但毕竟写文章，还是得照顾下不知道的同学）<br>
// 其次问下大家object.assign属于浅拷贝还是深拷贝<br>
// Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型<br>
// Object.getOwnPropertyDescriptors方法配合 Object.create() 方法可以实现浅拷贝。<br>
// <code>// Object.create( // Object.getPrototypeOf(obj), // Object.getOwnPropertyDescriptors(obj) // ); //</code></p>
]]></content>
    </entry>
</feed>